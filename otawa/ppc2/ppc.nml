

#line 1 "nmp/state.nmp"
// state definition for PowerPC

let REGS = 5
let nDBAT = 16 // ppc755, 8 otherwise
let nIBAT = 16 // ppc755, 8 otherwise
let nSR = 16
let nSPRG = 8 // ppc755, 4 otherwise

// 1.1.6 otawa_kind of instructions
// Might be used to know in which functional unit the instruction is executed

let IS_COND    = 0x00001
let IS_CONTROL = 0x00002
let IS_CALL    = 0x00004
let IS_RETURN  = 0x00008
let IS_MEM     = 0x00010
let IS_LOAD    = 0x00020
let IS_STORE   = 0x00040
let IS_INT     = 0x00080
let IS_FLOAT   = 0x00100
let IS_ALU     = 0x00200
let IS_MUL     = 0x00400
let IS_DIV     = 0x00800
let IS_SHIFT   = 0x01000
let IS_TRAP    = 0x02000
let IS_INTERN  = 0x04000
let IS_MULTI   = 0x08000
let IS_SPECIAL = 0x10000

// old kind of instructions
let ARITH = IS_ALU | IS_INT  //"0"       // Integer Add and Sub Instructions
let MULDIV = IS_ALU | IS_INT //"1"     // Integer Mul and Div Instructions
let INTCMP = IS_ALU | IS_INT //"2"     // Integer Compare Instructions
let LOGIC = IS_ALU | IS_INT //"3"       // Integer Logical instructions
let SHIFTROT = IS_ALU | IS_SHIFT | IS_INT //"4" // Int shift and rotate
let STORE = IS_MEM | IS_STORE | IS_INT //"5"       // Integer Stores including byte reverse, multiple and string
let LOAD = IS_MEM | IS_LOAD | IS_INT //"6"         // Integer Loads including byte reverse, multiple and string
let MEMSYNC = IS_INTERN //"7"   // Memory Synchronization Instructions
let BRANCH = IS_CONTROL //"8"
let CRLI = IS_INTERN //"9"         // Condition Register Logical Instructions
let SYSTEM = IS_CONTROL | IS_TRAP //"10"     // System Linkage Instructions
let TRAP = IS_CONTROL | IS_TRAP //"11"
let EXT = IS_INTERN //"12"           // External Control Instructions
let CONTROL = IS_INTERN //"13"   // Processor Control Instructions
let CACHE = IS_INTERN //"14"       // Cache Management Instructions



// 1.1.1 CR indexes (int)

let LT = 3
let GT = 2
let EQ = 1
let SO = 0

// 1.1.2 CR indexes (float)
let FX = 3
let FEX= 2
let VX = 1
let OX = 0

// 1.1.3 XER indexes
let SO_XER = 31
let OV_XER = 30
let CA_XER = 29

// 1.1.4 MSR indexes
let MSR_POW = 18
let MSR_ILE = 16
let MSR_EE = 15
let MSR_PR = 14
let MSR_FP = 13
let MSR_ME = 12
let MSR_FE0 = 11
let MSR_SE = 10
let MSR_BE = 9
let MSR_FE1 = 8
let MSR_IP = 6
let MSR_IR = 5
let MSR_DR = 4
let MSR_RI = 1
let MSR_LE = 0

// 1.1.5 exception types
let RESET = 0
let MACHINE_CHECK = 1
let DSI = 2
let ISI = 3
let EXTERNAL = 4
let ALIGNMENT = 5
let PROGRAM = 6
let FP_UNAVAIL = 7
let DECR = 8
let SYST_CALL = 9
let TRACE = 10
let FP_ASSIST = 11

// ------------------------------------------------------------------------- //
// 1.2 Types                                                                 //
// ------------------------------------------------------------------------- //
type bit       = card (  1 )
type half_byte = card (  4 )
type byte      = card (  8 )
type half_word = card ( 16 )
type word      = card ( 32 )
type long      = card ( 32 )
type double    = card ( 64 )
type slong     = int ( 32 )
type address   = card ( 32 )
type index     = card ( REGS )
type flot      = float ( 52 , 12 )
type flots     = float ( 23 , 9 )
type xflot     = float ( 64 , 16 )
type sflot     = float ( 31 , 9 )

// ------------------------------------------------------------------------- //
// 1.3  Memory and registers                                                 //
// ------------------------------------------------------------------------- //

// 1.3.1 GEP registers

reg PIA     [ 1 , address ]
reg CIA     [ 1 , address ]
reg NIA     [ 1 , address ]
	pc = 1

// 1.3.2 UISA model registers

mem M       [ 32 , byte      ]
mem M32     [ 32 , slong     ] alias = M [0]
mem M16     [ 32 , half_word ] alias = M [0]
reg GPR     [ 2 ** REGS , slong ]
reg CR      [ 8 , half_byte ]
reg XER     [ 1 , long ]
reg FPSCR   [ 1 , long ]
reg LR      [ 1 , long ]
reg CTR     [ 1 , long ]
reg UPMC	[ 4 , long ] // 750-755 specific register
reg USIA	[ 1 , address ] // 750-755 specific register
reg UMMCR	[ 2 , long ] // 750-755 specific register
reg FPR     [ 2 ** REGS , flot ]

reg TB		[ 1 , double ] // TBL and TBU

// 1.3.4 OEA model registers
  // Configuration registers
reg HID		[ 2 , long ] // 750-755 specific register. HID[2] : 755 only.
reg PVR		[ 1 , long ]
reg MSR 	[ 1 , long ]
  // Exception handling registers
reg SPRG	[ nSPRG , long ]
reg DAR		[ 1 , long ]
reg SRR		[ 2 , long ]
reg DSISR	[ 1 , long ]
  // Memory management registers
reg SDR1	[ 1 , long ]
reg IBAT	[ nIBAT , long ]
reg DBAT	[ nDBAT , long ]
reg DMISS       [ 1 , long ] // 750-755 specific register
reg DCMP        [ 1 , long ] // 750-755 specific register
reg HASH        [ 2 , long ] // 750-755 specific register
reg IMISS       [ 1 , long ] // 750-755 specific register
reg ICMP        [ 1 , long ] // 750-755 specific register
reg RPA         [ 1 , long ] // 750-755 specific register
reg SR		[ nSR , long ]
  // Performance monitor registers
reg PMC		[ 4 , long ] // 750-755 specific register
reg SIA		[ 1 , long ] // 750-755 specific register
reg MMCR	[ 2 , long ] // 750-755 specific register
  // Power/Thermal Management registers
reg THRM	[ 3 , long ] // 750-755 specific register
reg ICTC	[ 1 , long ] // 750-755 specific register
  // Miscellaneous registers
reg EAR 	[ 1 , long ]
reg DEC		[ 1 , long ]
reg DABR	[ 1 , long ]
reg IABR	[ 1 , long ] // 750-755 specific register
reg L2CR	[ 1 , long ] // 750-755 specific register Not supported on the 745
reg L2PM	[ 1 , long ] // 755 specific register

// ------------------------------------------------------------------------- //
// 1.4  Internal variables                                                   //
// ------------------------------------------------------------------------- //

var TMP_RES	         [ 1 , slong ]
var TMP_EA           [ 1 , address ]
var TMP_RESERVE      [ 1 , int ( 8 ) ]
var TMP_RESERVE_ADDR [ 1 , address ]

// TMP_ means local variables
var TMP_BYTE     [ 1 , byte ]
var TMP_SBYTE    [ 1 , int ( 8 ) ]
var TMP_HBYTE    [ 1 , half_byte ]
var TMP_HWORD    [ 1 , card ( 16 ) ]
var TMP_SHWORD   [ 1 , int ( 16 ) ]
var TMP_WORD     [ 1 , word ]
var TMP_MACRO    [ 1 , word ] // to be used in macros
var TMP_WORD1    [ 1 , word ]
var TMP_WORD2    [ 1 , word ]
var TMP_WORD3    [ 1 , word ]
var TMP_WORD4    [ 1 , word ]
var TMP_WORD5    [ 1 , word ]
var TMP_SWORD    [ 1 , int ( 32 ) ]
var TMP_SWORD1   [ 1 , int ( 32 ) ]
var TMP_SDWORD   [ 1 , int ( 64 ) ]
var TMP_DWORD    [ 1 , card ( 64 ) ]
var TMP_M_OP1    [ 1 , int ( 64 ) ]
var TMP_M_OP2    [ 1 , int ( 64 ) ]
var TMP_M_RES    [ 1 , int ( 64 ) ]


// 1.4.1 Aliases for TB
reg TBL [ 1 , card ( 32 ) ]
	alias = TB [ 31 ]
reg TBU [ 1 , card ( 32 ) ]
	alias = TB [ 63 ]

// 1.4.2 Aliases for Integer Temps

reg TMP_WORD_A1 [ 1 , card ( 16 ) ]
	alias = TMP_WORD [ 31 ]
reg TMP_WORD_A0 [ 1 , card ( 16 ) ]
	alias = TMP_WORD [ 15 ]
reg TMP_M_OP1_H1 [ 1 , int ( 32 ) ]
	alias = TMP_M_OP1 [ 63 ]
reg TMP_M_OP1_H0 [ 1 , int ( 32 ) ]
	alias = TMP_M_OP1 [ 31 ]
reg TMP_M_OP2_H1 [ 1 , int ( 32 ) ]
	alias = TMP_M_OP2 [ 63 ]
reg TMP_M_OP2_H0 [ 1 , int ( 32 ) ]
	alias = TMP_M_OP2 [ 31 ]
reg TMP_M_RES_H1 [ 1 , int ( 32 ) ]
	alias = TMP_M_RES [ 63 ]
reg TMP_M_RES_H0 [ 1 , int ( 32 ) ]
	alias = TMP_M_RES [ 31 ]

// 1.4.3 HalfWord Integer

reg TMP_SHWORD_A1 [ 1 , int ( 8 ) ]
    alias = TMP_SHWORD [ 15 ]

reg TMP_SHWORD_A0 [ 1 , int ( 8 ) ]
    alias = TMP_SHWORD [ 7 ]

// 1.4.4 Word Integers

reg TMP_SWORD_A3 [ 1 , int ( 8 ) ]
    alias = TMP_SWORD [ 31 ]

reg TMP_SWORD_A2 [ 1 , int ( 8 ) ]
    alias = TMP_SWORD [ 23 ]

reg TMP_SWORD_A1 [ 1 , int ( 8 ) ]
    alias = TMP_SWORD [ 15 ]

reg TMP_SWORD_A0 [ 1 , int ( 8 ) ]
    alias = TMP_SWORD [ 7 ]

// HKC-SET
// FPSCR bit optimization
reg fp_clear[1, card(32)]
// /HKC-SET


// Useful canonicals
canon word "fpi_testexcept"(word)
canon "fpi_clearexcept"(word)
canon "fpi_raiseexcept"(word)
canon word "FPI_DIVBYZERO"
canon word "FPI_INEXACT"
canon word "FPI_INVALID"
canon word "FPI_OVERFLOW"
canon word "FPI_UNDERFLOW"

canon "fpi_setround"(word)
canon word "fpi_getround"()
canon word "FPI_TONEAREST"
canon word "FPI_TOWARDZERO"
canon word "FPI_UPWARD"
canon word "FPI_DOWNWARD"
#line 4 "nmp/ppc_vle.nmp"

let proc = "ppc"
let with_vle = 1
let bit_order = "uppermost" // Be careful ; this is not the convention used in PPC manuals.
let M_is_little = "MSR & (0x01<<MSR_LE)" // MSR should be correctly initialized in the init rule below

let gliss_isize = "32,16"

// pseudo-IS selector
reg VLE[1,card(1)]

op multi = normal_isa | vle_isa


// normal instruction set
op normal_isa(x: instrs32)
	syntax = x.syntax
	image = x.image
	action = {
		PIA = CIA;
		CIA = NIA;
		NIA = NIA + 4;
		x.action;
	}
	instruction_set_select = VLE == 0
	instruction_set_name = "PPC"

op instrs32  =    uisa_instr
                | vea_instr
                | oea_instr
//                | essp_fp_instr


// VLE instruction set
op vle_isa(x: vle)
	syntax = x.syntax
	image = x.image
	action = { x.action; }
	instruction_set_select = VLE == 1
	instruction_set_name = "VLE"

op vle = vle16 	| vle32

op vle16(x: vle16_list)
	syntax = x.syntax
	image = x.image
	action = {
		PIA = CIA;
		CIA = NIA;
		NIA = NIA + 2;
		x.action;
	}

op vle32(x: vle32_all)
	syntax = x.syntax
	image = x.image
	action = {
		PIA = CIA;
		CIA = NIA;
		NIA = NIA + 4;
		x.action;
	}

op vle32_all =
	  vle32_list
	| vle_normal
	| vle_book_e
//	| essp_fp_instr

op vle_normal =
	  add							// add, add., addo, addo.
	| add_carrying					// addc
	| add_carry_cr_update			// addc.
	| add_carry_overflow			// addco
	| add_carry_overflow_cr_update	// addco.
	| add_extend					// adde
	| add_extend_cr_update			// adde.
	| add_extend_overflow			// addeo
	| add_extd_overflow_cr_upd		// addeo.
	| add_me						// addme
	| add_me_cr_update				// addme.
	| add_me_overflow				// addmeo
	| add_me_overflow_cr_update		// addmeo.
	| add_ze						// addze
	| add_ze_cr_update				// addze.
	| add_ze_overflow				// addzeo
	| add_ze_overflow_cr_update		// addzeo.
	| and
	| and_cr_update					// and.
	| andc							// andc
	| andc_cr_update				// andc.
	| cmp
	| cmp_log						// cmpl
	| cntlzw
	| cntlzw_cr_update				// cntlzw.
	| divw
	| divw_cr_update				// divw.
	| divw_overflow					// divwo
	| divw_overflow_cr_upd			// divwo.
	| divwus						// divwu
	| divwus_cr_update				// divwu.
	| divwus_overflow				// divwuo
	| divwus_overflow_cr_upd		// divwuo.
	| eqv
	| eqv_cr_update					// eqv.
	| extsb
	| extsb_cr_update				// extsb.
	| extsh
	| extsh_cr_update				// extsh.
	| isel
	| lb_zero_indexed				// lbzx
	| lb_zero_update_indexed		// lbzux
	| lhw_alg_indexed				// lhax
	| lhw_alg_update_indexed		// lhaux
	| lhw_br_index					// lhbrx
	| lhw_zero_indexed				// lhzx
	| lhw_zero_update_indexed		// lhzux
	| lw_zero_indexed				// lwzx
	| lw_zero_update_indexed		// lwzux
	| lw_br_index					// lwbrx
	| lwarx
	| mov_from_spr
	| mov_to_cr_field				// mtcrf
	| mov_to_cr_xer					// mcrxr
	| mov_to_spr
	| mult_hi						// mulhw
	| mult_hi_cr_update				// mulhw.
	| mult_hi_us					// mulhwu
	| mult_hi_us_cr_update			// mulhwu.
	| mult_lw						// mulw
	| mult_lw_cr_update				// mulw.
	| mult_lw_overflow				// mullwo
	| mult_lw_overflow_cr_upd		// mullwo.
	| nand
	| nand_cr_update				// nand.
	| neg
	| neg_cr_update					// neg.
	| neg_overflow					// nego
	| neg_overflow_cr_upd			// nego.
	| nor
	| nor_cr_update					// nor.
	| oea_mfmsr						// mfmsr
	| oea_mfspr	
	| oea_mtmsr						// mtmsr
	| oea_mtspr
	| or
	| or_cr_update					// or.
	| orc
	| orc_cr_update					// orc.
	| slw
	| slw_cr_update					// slw.
	| sraw
	| sraw_cr_update				// sraw.
	| srawi
	| srawi_cr_update				// srawi.
	| srw
	| srw_cr_update					// srw.
	| st_byte_indexed				// stbx
	| st_byte_update_indexed		// stbux
	| st_half_word_indexed			// sthx
	| st_half_word_update_indexed	// sthux
	| st_word_indexed				// stwx
	| st_word_update_indexed		// stwux
	| sthw_br_index					// sthbrx
	| ststw_index					// stswx
	| ststw_imm						// stswi
	| stw_br_index					// stwbrx
	| stwcx							// stwcx.
	| sub							// subf
	| sub_cr_update					// subf.
	| sub_overflow_enable			// subfo
	| sub_crup_overen				// subfo.
	| sub_carrying					// subfc
	| sub_carry_cr_update			// subfc.
	| sub_carry_overflow			// subfco
	| sub_carry_overflow_cr_update	// subfco.
	| sub_extend					// subfe
	| sub_extend_cr_update			// subfe.
	| sub_extend_overflow			// subfeo
	| sub_extd_overflow_cr_upd		// subfeo.
	| sub_me						// subfme
	| sub_me_cr_update				// subfme.
	| sub_me_overflow				// subfmeo
	| sub_me_overflow_cr_update		// subfmeo.
	| sub_ze						// subfze
	| sub_ze_cr_update				// subfze.
	| sub_ze_overflow				// subfzeo
	| sub_ze_overflow_cr_update		// subfzeo.
	| mov_from_cr 					// mfcr
	| tw
	| vea_dcba						// dcba
	| vea_dcbf						// dcbf
	| vea_dcbi						// dcbi
	| vea_dcbst						// dcbst
	| vea_dcbt						// dcbt
	| vea_dcbtst					// dcbtst	
	| vea_dcbz						// dcbz
	| vea_icbi						// icbi
	| xor
	| xor_cr_update					// xor.


op vle_book_e =
	  icbt
	| mbar
	| mfdcr
	| mtdcr
	| msync
	| tlbivax
	| tlbre
	| tlbsx
	| tlbsync
	| tlbwe
	| wrtee
	| wrteei


// instructions files
#line 1 "nmp/ppc32.nmp"
// ------------------------------------------------------------------------- //
// 1.1 Constants                                                             //
// ------------------------------------------------------------------------- //


// ------------------------------------------------------------------------- //
// 1.5 Addressing Modes                                                      //
// ------------------------------------------------------------------------- //


mode REG_IND_ZERO ( r : index ) =
     if r == 0 then
        0
     else
        GPR [ r ]
     endif
   syntax = format ( "r%d", r )
   image  = format ( "%5b", r )
   value  = r

mode REG_IND ( r : index ) = GPR [ r ]
   syntax = format ( "r%d", r )
   image  = format ( "%5b", r )
   value  = r

mode IMM24 ( n : int ( 24 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%24b", n )

mode IMM16 ( n : int ( 16 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%16b", n )

mode LS_COUNT ( NB : card ( 5 ) ) =
     if NB == 0 then
        32
     else
        NB
     endif
   syntax = format ( "%d", NB )
   image  = format ( "%5b", NB )

mode IADDR ( d : int ( 16 ) ) = d
   syntax = format ( "%d", d )
   image  = format ( "%16b", d )

mode SIMM ( n : int ( 14 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%14b", n )

mode SIMM5 ( n : int ( 5 ) ) = n
	syntax = format ( "%d", n )
	image  = format ( "%5b", n )

mode SIMM16 ( n : int ( 16 ) ) = n
	syntax = format ( "%d", n )
	image  = format ( "%16b", n )

mode UIMM16 ( n : card ( 16 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%16b", n )

// ------------------------------------------------------------------------- //
// 1.6 Macros                                                                //
// ------------------------------------------------------------------------- //


#line 71 "nmp/ppc32.nmp"
#line 84 "nmp/ppc32.nmp"

#line 100 "nmp/ppc32.nmp"
#line 111 "nmp/ppc32.nmp"
#line 141 "nmp/ppc32.nmp"
#line 148 "nmp/ppc32.nmp"

#line 172 "nmp/ppc32.nmp"
#line 200 "nmp/ppc32.nmp"
#line 208 "nmp/ppc32.nmp"
#line 216 "nmp/ppc32.nmp"
#line 222 "nmp/ppc32.nmp"



// ========================================================================= //
// read and written regs information coding
// ========================================================================= //

// USED_REGS will be the name of the extern function which will process the informations
// the function will accept an undefinited number of arguments.
// in C code the real function name can be redefined at will
// with #define USED_REGS other_function

// access types
let READ_REG    = 1
let WRITE_REG   = 2
let REG_RANGE   = 0x10
let READ_RANGE  = READ_REG | REG_RANGE
let WRITE_RANGE = WRITE_REG | REG_RANGE
// used by the extern function, this codes the end of the argument list
let END_REG     = 0
// this codes an unused argument, useful for multiple "conditional" arguments
let NO_REG      = -1

#line 247 "nmp/ppc32.nmp"

// reg banks macros
let BANK_PIA = 1
let BANK_CIA = 2
let BANK_NIA = 3

let BANK_GPR   = 4
let BANK_CR    = 5
let BANK_XER   = 6
let BANK_FPSCR = 7
let BANK_LR    = 8
let BANK_CTR   = 9
let BANK_UPMC  = 10
let BANK_USIA  = 11
let BANK_UMMCR = 12
let BANK_FPR   = 13

let BANK_TB    = 14

let BANK_HID   = 15
let BANK_PVR   = 16
let BANK_MSR   = 17

let BANK_SPRG  = 18
let BANK_DAR   = 19
let BANK_SRR   = 20
let BANK_DSISR = 21

let BANK_SDR1  = 22
let BANK_IBAT  = 23
let BANK_DBAT  = 24
let BANK_DMISS = 25
let BANK_DCMP  = 26
let BANK_HASH  = 27
let BANK_IMISS = 28
let BANK_ICMP  = 29
let BANK_RPA   = 30
let BANK_SR    = 31

let BANK_PMC   = 32
let BANK_SIA   = 33
let BANK_MMCR  = 34

let BANK_THRM  = 35
let BANK_ICTC  = 36

let BANK_EAR   = 37
let BANK_DEC   = 38
let BANK_DABR  = 39
let BANK_IABR  = 40
let BANK_L2CR  = 41
let BANK_L2PM  = 42

let BANK_TBL   = 43
let BANK_TBU   = 44


op uisa_instr   = uisa_base_instr
                | uisa_fp_instr

op init ()
	action = {
    	MSR = 0;
		MSR<MSR_FP..MSR_FP> = 1;
		MSR<MSR_PR..MSR_PR> = 0;
		MSR<MSR_FE1..MSR_FE1> = 0;
		MSR<MSR_FE0..MSR_FE0> = 0;
        MSR<MSR_LE..MSR_LE> = 0;
		TB = 0;
		FPR[0]=0.0; FPR[1]=0.0; FPR[2]=0.0; FPR[3]=0.0;
		FPR[4]=0.0; FPR[5]=0.0; FPR[6]=0.0; FPR[7]=0.0;
		FPR[8]=0.0; FPR[9]=0.0; FPR[10]=0.0; FPR[11]=0.0;
		FPR[12]=0.0; FPR[13]=0.0; FPR[14]=0.0; FPR[15]=0.0;
		FPR[16]=0.0; FPR[17]=0.0; FPR[18]=0.0; FPR[19]=0.0;
		FPR[20]=0.0; FPR[21]=0.0; FPR[22]=0.0; FPR[23]=0.0;
		FPR[24]=0.0; FPR[25]=0.0; FPR[26]=0.0; FPR[27]=0.0;
		FPR[28]=0.0; FPR[29]=0.0; FPR[30]=0.0; FPR[31]=0.0;
		CR[0]=0; CR[1]=0; CR[2]=0; CR[3]=0; CR[4]=0; CR[5]=0; CR[6]=0; CR[7]=0;
		L2PM = 0;
		XER = 0;

		// HKC
		FPSCR = 0;
		"fpi_setround"("FPI_TONEAREST");
		// /HKC
		// HKC-SET
		fp_clear = "FPI_INVALID" | "FPI_DIVBYZERO";
		// /HKC-SET
	}

op uisa_base_instr  = branch_instr
                    | non_branch_instr

// ------------------------------------------------------------------------- //
// 2.1 Branch Instructions
// ------------------------------------------------------------------------- //

op branch_instr ( x : branch_instr_action )
   image   = x.image
   syntax  = x.syntax
   action  = { x.action; }
   set_attr_branch = 1

   otawa_kind = BRANCH | x.otawa_kind

op branch_instr_action  = branch_uncond
                        | branch_cond

op branch_cond          = branch_cond_mem
                        | branch_cond_reg

// Unconditional Branch Instructions

op branch_uncond    = branch_rel
                    | branch_abs
                    | call_uncond

op call_uncond      = branch_link
                    | branch_link_abs


op branch_rel ( BRANCH_ADDR : IMM24 )
   syntax = format ( "b %s", BRANCH_ADDR.syntax )
   image  = format ( "010010%24b00", BRANCH_ADDR.image )
   action = {
               TMP_SWORD = BRANCH_ADDR; // sign extension
               NIA = CIA + ( TMP_SWORD << 2 );
            }
   set_attr_branch = 1

   otawa_kind = BRANCH

op branch_abs ( BRANCH_ADDR : IMM24 )
   syntax = format ( "ba %s", BRANCH_ADDR.syntax )
   image  = format ( "010010%24b10", BRANCH_ADDR.image )
   action = {
               TMP_SWORD = BRANCH_ADDR; // sign extension
               NIA = ( TMP_SWORD << 2 );
            }
   set_attr_branch = 1

   otawa_kind = BRANCH

op branch_link ( BRANCH_ADDR : IMM24 )
   syntax = format ( "bl 0x%08x", __IADDR + (coerce(int(32), BRANCH_ADDR ) << 2))
   image  = format ( "010010%24b01", BRANCH_ADDR.image )
   action = {
                TMP_SWORD = BRANCH_ADDR; // sign extension
                NIA = CIA + ( TMP_SWORD << 2 );
                LR  = CIA + 4;
             }
   otawa_kind = if BRANCH_ADDR == 1 then IS_ALU | IS_INT else IS_CONTROL | IS_CALL endif
   set_attr_branch = 1

op branch_link_abs ( BRANCH_ADDR : IMM24 )
   syntax = format ( "bla %s", BRANCH_ADDR.syntax )
   image  = format ( "010010%24b11", BRANCH_ADDR.image )
   action = {
               TMP_SWORD = BRANCH_ADDR; // sign extension
               NIA = ( TMP_SWORD << 2 );
               LR  = CIA + 4;
            }
   set_attr_branch = 1

   otawa_kind = BRANCH | IS_CALL

// Conditional Branch Instructions

op branch_cond_mem ( x : bran_cond_action )
   syntax = x.syntax
   image  = x.image
   action = {
               x.action;
            }
   set_attr_branch = 1

   otawa_kind = x.otawa_kind

// Conditional Branch Instructions

op bran_cond_action =   bran_cond_rel
                      | bran_cond_abs
                      | bran_cond_link
                      | bran_cond_link_abs

op bran_cond_rel ( BO : card ( 5 ), BI : card ( 5 ), BD : SIMM )
   syntax = format ( "bc %d,%d,%s", BO, BI, BD.syntax )
   image  = format ( "010000%5b%5b%14b00", BO, BI, BD.image )
   action = {
		if (!BO<2..2>) then
			CTR = CTR - 1;
		endif;
		TMP_SWORD = 31 - BI;
		TMP_SWORD1 = TMP_SWORD/4;
		TMP_SWORD = TMP_SWORD - TMP_SWORD1 * 4;
		if  ( ( BO<2..2> | ( CTR!=0 ^ BO<1..1> ) ) &
			  ( BO<4..4> | ( CR[TMP_SWORD1]<TMP_SWORD..TMP_SWORD> ^ !BO<3..3> ) ) ) then
			TMP_SWORD = BD;
            NIA = CIA + ( TMP_SWORD << 2 );
		endif;

		}
   set_attr_branch = 1

   otawa_kind = if  ( BO<2..2> & BO<4..4> ) then
			BRANCH
		else
			BRANCH | IS_COND
		endif

op bran_cond_abs ( BO : card ( 5 ), BI : card ( 5 ), BD : SIMM )
   syntax = format ( "bca %d,%d,%s", BO, BI, BD.syntax )
   image  = format ( "010000%5b%5b%14b10", BO, BI, BD.image )
   action = {
		if !BO<2..2> then
			CTR = CTR - 1;
		endif;
		TMP_SWORD = 31 - BI;
		TMP_SWORD1 = TMP_SWORD/4;
		TMP_SWORD = (TMP_SWORD - TMP_SWORD1 * 4);
		if  ( ( BO<2..2> | ( CTR!=0 ^ BO<1..1> ) ) &
			  ( BO<4..4> | ( CR[TMP_SWORD1]<TMP_SWORD..TMP_SWORD> ^ ! BO<3..3> ) ) ) then
			TMP_SWORD = BD;
            NIA = ( TMP_SWORD << 2 );
		endif;

	    }
   set_attr_branch = 1

   otawa_kind = if  ( BO<2..2> & BO<4..4> ) then
			BRANCH
		else
			BRANCH | IS_COND
		endif

op bran_cond_link ( BO : card ( 5 ), BI : card ( 5 ), BD : SIMM )
   syntax = format ( "bcl %d,%d,%s", BO, BI, BD.syntax )
   image  = format ( "010000%5b%5b%14b01", BO, BI, BD.image )
   action = {
		if !BO<2..2> then
			CTR = CTR - 1;
		endif;
		TMP_SWORD = 31 - BI;
		TMP_SWORD1 = TMP_SWORD/4;
		TMP_SWORD = (TMP_SWORD - TMP_SWORD1 * 4);
		if  ( ( BO<2..2> | ( CTR!=0 ^ BO<1..1> ) ) &
			  ( BO<4..4> | ( CR[TMP_SWORD1]<TMP_SWORD..TMP_SWORD> ^ !BO<3..3> ) ) ) then
			TMP_SWORD = BD;
            NIA = CIA + ( TMP_SWORD << 2 );
		endif;

		LR = CIA + 4;

		}
   otawa_kind =
   		if BD == 1 then IS_ALU | IS_INT
   		else if  ( BO<2..2> & BO<4..4> ) then BRANCH | IS_CALL
		else BRANCH | IS_CALL | IS_COND
		endif endif
   set_attr_branch = 1

op bran_cond_link_abs ( BO : card ( 5 ), BI : card ( 5 ), BD : SIMM )
   syntax = format ( "bcla %d,%d,%s", BO, BI, BD.syntax )
   image  = format ( "010000%5b%5b%14b11", BO, BI, BD.image )
   action = {
		if !BO<2..2> then
			CTR = CTR - 1;
		endif;
		TMP_SWORD = 31 - BI;
		TMP_SWORD1 = TMP_SWORD/4;
		TMP_SWORD = (TMP_SWORD - TMP_SWORD1 * 4);
		if  ( ( BO<2..2> | ( CTR!=0 ^ BO<1..1> ) ) &
			  ( BO<4..4> | ( CR[TMP_SWORD1]<TMP_SWORD..TMP_SWORD> ^ !BO<3..3> ) ) ) then
			TMP_SWORD = BD;
            NIA = ( TMP_SWORD << 2 );
		endif;
		LR = CIA + 4;

		}
   set_attr_branch = 1

   otawa_kind = if  ( BO<2..2> & BO<4..4> ) then
			BRANCH | IS_CALL
		else
			BRANCH | IS_CALL | IS_COND
		endif


// Branch Conditonal with Registers CTR and LR

op branch_cond_reg ( x : bran_cond_reg_action )
   syntax = x.syntax
   image  = x.image
   action = {
               x.action;
            }
   set_attr_branch = 1

   otawa_kind = x.otawa_kind

// Branch Conditional on LR and CTR

op bran_cond_reg_action =   bran_cond_ctr
                          | bran_cond_lr

op bran_cond_ctr =   branch_cond_ctr
                   | branch_cond_ctr_link


op branch_cond_ctr ( BO : card ( 5 ), BI : card ( 5 ) )
   syntax = format ( "bcctr %d,%d", BO, BI )
   image  = format ( "010011%5b%5b0000010000100000", BO, BI )
   action = {
		TMP_SWORD = 31 - BI;
		TMP_SWORD1 = TMP_SWORD/4;
		TMP_SWORD = (TMP_SWORD - TMP_SWORD1 * 4);
		if ( BO<4..4> | ( CR[TMP_SWORD1]<TMP_SWORD..TMP_SWORD>  ^ !BO <3..3> ) ) then
			NIA = ( CTR & 0xfffffffc );
		endif;
		}
   set_attr_branch = 1

   otawa_kind = if  ( BO<2..2> & BO<4..4> ) then
			BRANCH
		else
			BRANCH | IS_COND
		endif

op branch_cond_ctr_link ( BO : card ( 5 ), BI : card ( 5 ) )
   syntax = format ( "bcctrl %d,%d", BO, BI )
   image  = format ( "010011%5b%5b0000010000100001", BO, BI )
   action = {
		TMP_SWORD = 31 - BI;
		TMP_SWORD1 = TMP_SWORD/4;
		TMP_SWORD = (TMP_SWORD - TMP_SWORD1 * 4);
		if ( BO<4..4> | ( CR[TMP_SWORD1]<TMP_SWORD..TMP_SWORD>  ^ !BO <3..3> ) ) then
			NIA = ( CTR & 0xfffffffc );
		endif;
		LR = ( CIA + 4 );
		}
   set_attr_branch = 1

   otawa_kind = if  ( BO<2..2> & BO<4..4> ) then
			BRANCH | IS_CALL
		else
			BRANCH | IS_CALL | IS_COND
		endif

op bran_cond_lr =   branch_cond_lr
                  | branch_cond_lr_link

op branch_cond_lr ( BO : card ( 5 ), BI : card ( 5 ) )
   syntax = format ( "bclr %d,%d", BO, BI)
   image  = format ( "010011%5b%5b0000000000100000", BO, BI )
   action = {
		if !BO<2..2> then
			CTR = CTR - 1;
		endif;
		TMP_SWORD = 31 - BI;
		TMP_SWORD1 = TMP_SWORD/4;
		TMP_SWORD = (TMP_SWORD - TMP_SWORD1 * 4);
		if  ( ( BO<2..2> | ( CTR!=0 ^ BO<1..1> ) ) &
			  ( BO<4..4> | ( CR[TMP_SWORD1]<TMP_SWORD..TMP_SWORD> ^ !BO<3..3> ) ) ) then
			NIA = ( LR & 0xfffffffc );
		endif;
		}
	set_attr_branch = 1

	otawa_kind = if  ( BO<2..2> & BO<4..4> ) then
			BRANCH | IS_RETURN
		else
			BRANCH | IS_RETURN | IS_COND
		endif

op branch_cond_lr_link ( BO : card ( 5 ), BI : card ( 5 ) )
   syntax = format ( "bclrl %d,%d", BO, BI )
   image  = format ( "010011%5b%5b0000000000100001", BO, BI )
   action = {
		if !BO<2..2> then
			CTR = CTR - 1;
		endif;
		TMP_SWORD = 31 - BI;
		TMP_SWORD1 = TMP_SWORD/4;
		TMP_SWORD = (TMP_SWORD - TMP_SWORD1 * 4);
		if  ( ( BO<2..2> | ( CTR!=0 ^ BO<1..1> ) ) &
			  ( BO<4..4> | ( CR[TMP_SWORD1]<TMP_SWORD..TMP_SWORD> ^ !BO<3..3> ) ) ) then
			NIA = ( LR & 0xfffffffc );
		endif;
		LR = ( CIA + 4 );
		}
   set_attr_branch = 1

   otawa_kind =  IS_CALL | BRANCH | (if  ( BO<2..2> & BO<4..4> ) then 0 else IS_COND endif)


// ------------------------------------------------------------------------- //
// 2.2 Non Branch Instructions
// ------------------------------------------------------------------------- //

op non_branch_instr ( x : non_branch_instr_action )
   action = { x.action; }
   syntax = x.syntax
   image  = x.image
   otawa_kind = x.otawa_kind

op non_branch_instr_action =   sys_call
                             | load_store_instr
                             | int_instr
                             | flow_control_instr
                             | proce_control_instr
			     | mem_sync_instr
			     | trap_instr

// 2.2.1 System Call

op sys_call ( )
   syntax = "sc"
   image  = "01000100000000000000000000000010"
   action = { "sc_impl"("instr","state",M);}
   otawa_kind = SYSTEM
   is_branch = 1

// 2.2.2 Load and Store Instructions

op load_store_instr ( x : load_store_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = x.otawa_kind

op load_store_instr_action =   int_load
                             | int_store

// Integer Load Instructions
op int_load ( x : int_load_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = LOAD

op int_load_action =   int_load_byte
              | int_load_half_word
              | int_load_word
              | int_load_byte_rev   // New
              | int_load_multiple   // New
              | int_load_string     // New

// Integer Load Byte Instructions

op int_load_byte =   lb_zero
                   | lb_zero_indexed
                   | lb_zero_update
                   | lb_zero_update_indexed
// !!DEBUG!!
// !!DEBUG!!
// !!DEBUG!!
op lb_zero ( rd : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "lbz r%d,%s(%s)", rd, d.syntax, ra.syntax)
   image  = format ( "100010%5b%s%16b", rd, ra.image, d.image )
   action = {
               TMP_EA = ra + d;
               TMP_BYTE = M [ TMP_EA ];
               GPR [ rd ] = TMP_BYTE;
               GPR [ rd ] = ( 0x000000ff & GPR [ rd ] );
            }


op lb_zero_indexed ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "lbzx r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00010101110", rd, ra.image, rb.image )
   action = {
               TMP_EA = ra + rb;
               TMP_BYTE = M [ TMP_EA ];
               GPR [ rd ] = TMP_BYTE;
               GPR [ rd ] = ( 0x000000ff & GPR [ rd ] );
            }


op lb_zero_update ( rd : index, ra : index, d : IADDR )
   syntax = format ( "lbzu r%d,%s(r%d)", rd, d.syntax, ra )
   image  = format ( "100011%5b%5b%16b", rd, ra, d.image )
   action = {
	       if ((ra==0) || (ra == rd))
               then
		  "launch_exception"("instr",PROGRAM);
               endif;
               TMP_EA = GPR [ ra ] + d;
               TMP_BYTE = M [ TMP_EA ];
               GPR [ rd ] = TMP_BYTE;
               GPR [ rd ] = ( 0x000000ff & GPR [ rd ] );
               GPR [ ra ] = TMP_EA;
            }

op lb_zero_update_indexed ( rd : index, ra : index, rb : REG_IND )
   syntax = format ( "lbzux r%d,r%d,%s", rd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s00011101110", rd, ra, rb.image )
   action = {
	       if ((ra==0) || (ra == rd))
               then
		  "launch_exception"("instr",PROGRAM);
               endif;
               TMP_EA = GPR [ ra ] + rb;
               TMP_BYTE = M [ TMP_EA ];
               GPR [ rd ] = TMP_BYTE;
               GPR [ rd ] = ( 0x000000ff & GPR [ rd ] );
               GPR [ ra ] = TMP_EA;
            }

// Integer Load Half Word Instructions

op int_load_half_word =   lhw_zero
                        | lhw_zero_indexed
                        | lhw_zero_update
                        | lhw_zero_update_indexed
                        | lhw_alg
                        | lhw_alg_indexed
                        | lhw_alg_update
                        | lhw_alg_update_indexed

op lhw_zero ( rd : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "lhz r%d,%s(%s)", rd, d.syntax, ra.syntax )
   image  = format ( "101000%5b%s%16b", rd, ra.image, d.image )
   action = {

               TMP_EA = ra + d;
               //GPR [ rd ] = 0;

               TMP_SHWORD_A1 = M [ TMP_EA ];
               TMP_SHWORD_A0 = M [ TMP_EA + 1 ];

               GPR [ rd ] = TMP_SHWORD;

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);

            }

op lhw_zero_indexed ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "lhzx r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01000101110", rd, ra.image, rb.image )
   action = {

               TMP_EA = ra + rb;

               TMP_SHWORD_A1 = M [ TMP_EA ];
               TMP_SHWORD_A0 = M [ TMP_EA + 1 ];

               GPR [ rd ] = TMP_SHWORD;

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);
            }

op lhw_zero_update ( rd : index, ra : index, d : IADDR )
   syntax = format ( "lhzu r%d,%s(r%d)", rd, d.syntax, ra )
   image  = format ( "101001%5b%5b%16b", rd, ra, d.image )
   action = {
 	       if ((ra==0) || (ra == rd))
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

               TMP_EA = GPR [ ra ] + d;
               GPR [ rd ] = 0;
               TMP_SHWORD_A1 = M [ TMP_EA ];
               TMP_SHWORD_A0 = M [ TMP_EA + 1 ];
               GPR [ rd ] = TMP_SHWORD;
               GPR [ ra ] = TMP_EA;
               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);
            }

op lhw_zero_update_indexed ( rd : index, ra : index, rb : REG_IND )
   syntax = format ( "lhzux r%d,r%d,%s", rd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s01001101110", rd, ra, rb.image )
   action = {
	       if ((ra==0) || (ra == rd))
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

               TMP_EA = GPR [ ra ] + rb;
               //GPR [ rd ] = 0;
               TMP_SHWORD_A1 = M [ TMP_EA ];
               TMP_SHWORD_A0 = M [ TMP_EA + 1 ];
               GPR [ rd ] = TMP_SHWORD;
               GPR [ ra ] = TMP_EA;
               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);
            }

op lhw_alg ( rd : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "lha r%d,%s(%s)", rd, d.syntax, ra.syntax )
   image  = format ( "101010%5b%s%16b", rd, ra.image, d.image )
   action = {

               TMP_EA = ra + d;
               GPR [ rd ] = 0;
               TMP_BYTE = M [ TMP_EA ];
               TMP_SHWORD_A1 = M [ TMP_EA ];
               TMP_SHWORD_A0 = M [ TMP_EA + 1 ];
               GPR [ rd ] = TMP_SHWORD;
               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);
               if TMP_BYTE < 7..7 > then
                  GPR [ rd ] =  0xffff0000 | GPR [ rd ];
               endif;
            }

op lhw_alg_indexed ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "lhax r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01010101110", rd, ra.image, rb.image )
   action = {
               TMP_EA = ra + rb;
               GPR [ rd ] = 0;
               TMP_BYTE = M [ TMP_EA ];
               TMP_SHWORD_A1 = M [ TMP_EA ];
               TMP_SHWORD_A0 = M [ TMP_EA + 1 ];
               GPR [ rd ] = TMP_SHWORD;
               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);
               if TMP_BYTE < 7..7 > then
                  GPR [ rd ] =  0xffff0000 | GPR [ rd ];
               endif;

            }

op lhw_alg_update ( rd : index, ra : index, d : IADDR )
   syntax = format ( "lhau r%d,%s(r%d)", rd, d.syntax, ra )
   image  = format ( "101011%5b%5b%16b", rd, ra, d.image )
   action = {
	       if ((ra==0) || (ra == rd))
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

               TMP_EA = GPR [ ra ] + d;
               GPR [ rd ] = 0;
               TMP_BYTE = M [ TMP_EA ];

               TMP_SHWORD_A1 = M [ TMP_EA ];
               TMP_SHWORD_A0 = M [ TMP_EA + 1 ];

               GPR [ rd ] = TMP_SHWORD;

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);

               if TMP_BYTE < 7..7 > then
                  GPR [ rd ] =  0xffff0000 | GPR [ rd ];
               endif;

               GPR [ ra ] = TMP_EA;

            }

op lhw_alg_update_indexed ( rd : index, ra : index, rb : REG_IND )
   syntax = format ( "lhaux r%d,r%d,%s", rd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s01011101110", rd, ra, rb.image )
   action = {
	       if ((ra==0) || (ra == rd))
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

               TMP_EA = GPR [ ra ] + rb;
               GPR [ rd ] = 0;
               TMP_BYTE = M [ TMP_EA ];

               TMP_SHWORD_A1 = M [ TMP_EA ];
               TMP_SHWORD_A0 = M [ TMP_EA + 1 ];

               GPR [ rd ] = TMP_SHWORD;

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);

               if TMP_BYTE < 7..7 > then
                  GPR [ rd ] =  0xffff0000 | GPR [ rd ];
               endif;

               GPR [ ra ] = TMP_EA;

            }


// Integer Load Word Instructions

op int_load_word =   lw_zero
                   | lw_zero_indexed
                   | lw_zero_update
                   | lw_zero_update_indexed

op lw_zero ( rd : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "lwz r%d,%s(%s)", rd, d.syntax, ra.syntax )
   image  = format ( "100000%5b%s%16b", rd, ra.image, d.image )
   action = {

               TMP_EA = ra + d;
               GPR [ rd ] = M32 [TMP_EA];

            }

op lw_zero_indexed ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "lwzx r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000101110", rd, ra.image, rb.image )
   action = {

               TMP_EA = ra + rb;

               GPR [ rd ] = M32 [ TMP_EA ];

            }

op lw_zero_update ( rd : index, ra : index, d : IADDR )
   syntax = format ( "lwzu r%d,%s(r%d)", rd, d.syntax, ra )
   image  = format ( "100001%5b%5b%16b", rd, ra, d.image )
   action = {
	       if ((ra==0) || (ra == rd))
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

               TMP_EA = GPR [ ra ] + d;

               GPR [ rd ] = M32 [ TMP_EA ];

               GPR [ ra ] = TMP_EA;

            }

op lw_zero_update_indexed ( rd : index, ra : index, rb : REG_IND )
   syntax = format ( "lwzux r%d,r%d,%s", rd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s00001101110", rd, ra, rb.image )
   action = {
	       if ((ra==0) || (ra == rd))
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

               TMP_EA = GPR [ ra ] + rb;

               GPR [ rd ] = M32 [ TMP_EA ];

               GPR [ ra ] = TMP_EA;

            }

// Integer Load with Byte reversal Instructions

op int_load_byte_rev =   lhw_br_index
                       | lw_br_index

op lhw_br_index ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "lhbrx r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11000101100", rd, ra.image, rb.image )
   action = {

               TMP_EA = ra + rb;
               //GPR [ rd ] = 0;

               GPR [ rd ] = M16 [ TMP_EA ];
			   GPR [ rd ] = GPR [ rd ] & 0x0000ffff;
            }

op lw_br_index ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "lwbrx r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000101100", rd, ra.image, rb.image )
   action = {

               TMP_EA = ra + rb;
               //GPR [ rd ] = 0;

               GPR [ rd ] = M32 [ TMP_EA ];

            }

// Integer Load Multiple Instructions

op int_load_multiple ( rd : index, ra : REG_IND_ZERO, d : IMM16 )
   syntax = format ( "lmw r%d,%s(%s)", rd , d.syntax, ra.syntax )
   image  = format ( "101110%5b%s%s", rd, ra.image, d.image )
   action = {

               TMP_EA = ra + d;
               TMP_BYTE =  rd;
               recurs;

            }
    recurs = {

                if TMP_BYTE <= 31 then

                   GPR [ TMP_BYTE ] = M32 [ TMP_EA ];

                   TMP_BYTE = TMP_BYTE + 1;
                   TMP_EA = TMP_EA + 4;
                   recurs; // recursiveness is OK : it is compiled as labels and gotos
                endif;

             }
    otawa_kind = LOAD | IS_MULTI

// Integer Load String Instructions

op int_load_string =   lstw_imm
                     | lstw_index

op lstw_imm ( rd : index, ra : REG_IND_ZERO, NB : LS_COUNT )
   syntax = format ( "lswi r%d,%s,%s", rd, ra.syntax, NB.syntax )
   image  = format ( "011111%5b%s%5b10010101010", rd, ra.image, NB.image )
   action = {

               TMP_WORD = rd - 1;
               TMP_BYTE = 0;
               TMP_EA = ra;
			   TMP_SHWORD = NB;
               recurs;

            }
   recurs = {

               if TMP_SHWORD >= 0 then

                  if TMP_BYTE == 0 then
                     TMP_WORD = ( TMP_WORD + 1 ) % 32;
                     GPR [ TMP_WORD ] = 0;
                  endif;

                  TMP_WORD1 = M [ TMP_EA ];
                  TMP_WORD1 = TMP_WORD1 << ( ( 31 - TMP_BYTE ) - 7);
                  TMP_WORD1 = TMP_WORD1 & ( 0x000000ff << ( ( 31 - TMP_BYTE ) - 7));
                  GPR [ TMP_WORD ] = GPR [ TMP_WORD ] | TMP_WORD1;

                  TMP_BYTE = TMP_BYTE + 8;
				  if TMP_BYTE == 32 then TMP_BYTE = 0; endif;
                  TMP_EA = TMP_EA + 1;
                  TMP_SHWORD = TMP_SHWORD - 1;
                  recurs;

               endif;

           }

op lstw_index ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "lswx r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000101010", rd, ra.image, rb.image )
   action = {
	       if (((ra==0) && (rd == 0)) || (ra == rd) || (rb == rd))
               then
		  "launch_exception"("instr",PROGRAM);
               endif;


               TMP_WORD = rd - 1;
               TMP_SBYTE = XER < 6..0 >;
               TMP_BYTE = 0;
               TMP_EA = ra + rb;
               recurs;

            }
   recurs = {

               if TMP_SBYTE >= 0 then

                  if TMP_BYTE == 0 then
                     TMP_WORD = ( TMP_WORD + 1 ) % 32;
                     GPR [ TMP_WORD ] = 0;
                  endif;

                  TMP_WORD1 = M [ TMP_EA ];
                  TMP_WORD1 = TMP_WORD1 << ( ( 31 - TMP_BYTE ) - 7);
                  TMP_WORD1 = TMP_WORD1 & ( 0x000000ff << ( ( 31 - TMP_BYTE ) - 7));
                  GPR [ TMP_WORD ] = GPR [ TMP_WORD ] | TMP_WORD1;

                  TMP_BYTE = TMP_BYTE + 8;
				  if TMP_BYTE == 32 then TMP_BYTE = 0; endif;
                  TMP_EA = TMP_EA + 1;
                  TMP_SBYTE = TMP_SBYTE - 1;
                  recurs;

               endif;

           }


// Integer Store Instructions
op int_store ( x : int_store_action )
   image   = x.image
   syntax  = x.syntax
   action  = { x.action; }
   otawa_kind = STORE

op int_store_action =   int_store_byte
               | int_store_half_word
               | int_store_word
               | int_store_byte_rev   // New
               | int_store_multiple   // New
               | int_store_string     // New

// Integer Store Byte Instructions

op int_store_byte =   st_byte
                    | st_byte_indexed
                    | st_byte_update
                    | st_byte_update_indexed

op st_byte ( rs : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "stb r%d,%s(%s)", rs, d.syntax, ra.syntax )
   image  = format ( "100110%5b%s%16b", rs, ra.image, d.image )
   action = {

               TMP_EA = ra + d;

               TMP_SWORD = GPR [ rs ];

               M [ TMP_EA ] = TMP_SWORD_A0;

            }

op st_byte_indexed ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "stbx r%d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00110101110", rs, ra.image, rb.image )
   action = {

               TMP_EA = ra + rb;

               TMP_SWORD = GPR [ rs ];

               M [ TMP_EA ] = TMP_SWORD_A0;

            }

op st_byte_update ( rs : index, ra : index, d : IADDR )
   syntax = format ( "stbu r%d,%s(r%d)", rs, d.syntax, ra )
   image  = format ( "100111%5b%5b%16b", rs, ra, d.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		TMP_EA = GPR [ ra ] + d;

		TMP_SWORD = GPR [ rs ];

		M [ TMP_EA ] = TMP_SWORD_A0;

		GPR [ ra ] = TMP_EA;

		}

op st_byte_update_indexed ( rs : index, ra : index, rb : REG_IND )
   syntax = format ( "stbux r%d,r%d,%s", rs, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s00111101110", rs, ra, rb.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		TMP_EA = GPR [ ra ] + rb;

		TMP_SWORD = GPR [ rs ];

		M [ TMP_EA ] = TMP_SWORD_A0;

		GPR [ ra ] = TMP_EA;

		}

// Integer Store Half Word Instructions

op int_store_half_word =   st_half_word
                         | st_half_word_indexed
                         | st_half_word_update
                         | st_half_word_update_indexed

op st_half_word ( rs : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "sth r%d,%s(%s)", rs, d.syntax, ra.syntax )
   image  = format ( "101100%5b%s%16b", rs, ra.image, d.image )
   action = {

               TMP_EA = ra + d;
               M16 [ TMP_EA ] = GPR [rs];

            }


op st_half_word_indexed ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "sthx r%d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01100101110", rs, ra.image, rb.image )
   action = {

               TMP_EA = ra + rb;
               M16 [ TMP_EA ] = GPR [ rs ];

            }

op st_half_word_update ( rs : index, ra : index, d : IADDR )
   syntax = format ( "sthu r%d,%s(r%d)", rs, d.syntax, ra )
   image  = format ( "101101%5b%5b%16b", rs, ra, d.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		TMP_EA = GPR [ ra ] + d;

		M16 [ TMP_EA ] = GPR [ rs ];

		GPR [ ra ] = TMP_EA;

		}

op st_half_word_update_indexed ( rs : index, ra : index, rb : REG_IND )
   syntax = format ( "sthux r%d,r%d,%s", rs, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s01101101110", rs, ra, rb.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		TMP_EA = GPR [ ra ] + rb;

		M16 [ TMP_EA ] = GPR [ rs ];

		GPR [ ra ] = TMP_EA;

		}

// Integer Store Word Instructions

op int_store_word =   st_word
                    | st_word_indexed
                    | st_word_update
                    | st_word_update_indexed

op st_word ( rs : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "stw r%d,%s(%s)", rs, d.syntax, ra.syntax )
   image  = format ( "100100%5b%s%16b", rs, ra.image, d.image )
   action = {

		TMP_EA = ra + d;

		M32 [ TMP_EA ] = GPR [ rs ];

		}

op st_word_indexed ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "stwx r%d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00100101110", rs, ra.image, rb.image )
   action = {

		TMP_EA = ra + rb;

		M32 [ TMP_EA ] = GPR [ rs ];

		}

op st_word_update ( rs : index, ra : index, d : IADDR )
   syntax = format ( "stwu r%d,%s(r%d)", rs, d.syntax, ra )
   image  = format ( "100101%5b%5b%16b", rs, ra, d.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		TMP_EA = GPR [ ra ] + d;

		M32 [ TMP_EA ] = GPR [ rs ];

		GPR [ ra ] = TMP_EA;

		}

op st_word_update_indexed ( rs : index, ra : index, rb : REG_IND )
   syntax = format ( "stwux r%d,r%d,%s", rs, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s00101101110", rs, ra, rb.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		TMP_EA = GPR [ ra ] + rb;

		M32 [ TMP_EA ] = GPR [ rs ];

		GPR [ ra ] = TMP_EA;

		}

// Integer Store with Byte reversal Instructions

op int_store_byte_rev =   sthw_br_index
                        | stw_br_index

op sthw_br_index ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "sthbrx r%d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11100101100", rs, ra.image, rb.image )
   action = {

		TMP_EA = ra + rb;

		M16 [ TMP_EA ]  = GPR [ rs ];

		}

op stw_br_index ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "stwbrx r%d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100101100", rs, ra.image, rb.image )
   action = {

		TMP_EA = ra + rb;
		M32 [ TMP_EA ] = GPR [ rs ];

		}

// Integer Store Multiple Instructions

op int_store_multiple ( rs : index, ra : REG_IND_ZERO, d : IMM16 )
   syntax = format ( "stmw r%d,%s(%s)", rs, d.syntax, ra.syntax )
   image  = format ( "101111%5b%s%s", rs, ra.image, d.image )
   action = {

		TMP_EA = ra + d;
		TMP_WORD = rs;
		recurs;
// ToDo: TMP_EA must be a multiple of four. Otherwise alignment exception or results boundedly undefined

		}
   recurs = {

		if TMP_WORD <= 31 then
			M32 [ TMP_EA ] = GPR [ TMP_WORD ];
			TMP_WORD = TMP_WORD + 1;
			TMP_EA = TMP_EA + 4;
			recurs;
		endif;

		}
   otawa_kind = STORE | IS_MULTI

// Integer Store String Instructions

op int_store_string =   ststw_imm
                      | ststw_index

op ststw_imm ( rs : index, ra : REG_IND_ZERO, NB : LS_COUNT )
   syntax = format ( "stswi r%d,%s,%s", rs, ra.syntax, NB.syntax )
   image  = format ( "011111%5b%s%5b10110101010", rs, ra.image, NB.image )
   action = {

		TMP_WORD = rs - 1;
		TMP_BYTE = 0;
		TMP_EA = ra;
		if NB == 0 then
			TMP_SWORD = 32;
		else
			TMP_SWORD = NB;
		endif;
		recurs;

		}
   recurs = {

		if TMP_SWORD >= 0 then

			if TMP_BYTE == 0 then
				TMP_WORD = ( TMP_WORD + 1 ) % 32;
			endif;

			M [ TMP_EA ] = GPR [ TMP_WORD ] < (31-TMP_BYTE)..( (31-TMP_BYTE) -7) >;
			TMP_BYTE = TMP_BYTE + 8;

			if TMP_BYTE == 32 then
				TMP_BYTE = 0;
			endif;

			TMP_EA = TMP_EA + 1;
			TMP_SWORD = TMP_SWORD - 1;
			recurs;

		endif;

		}

op ststw_index ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "stswx r%d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100101010", rs, ra.image, rb.image )
   action = {

		TMP_WORD = rs - 1;
		TMP_SBYTE = XER < 6..0 >;
		TMP_BYTE = 0;
		TMP_EA = ra + rb;
		recurs;

		}
   recurs = {

		if TMP_SBYTE >= 0 then

			if TMP_BYTE == 0 then
				TMP_WORD = ( TMP_WORD + 1 ) % 32;
			endif;

			M [ TMP_EA ] = GPR [ TMP_WORD ] < (31-TMP_BYTE)..( (31-TMP_BYTE) - 7 ) >;
			TMP_BYTE = TMP_BYTE + 8;

			if TMP_BYTE == 32 then
				TMP_BYTE = 0;
			endif;

			TMP_EA = TMP_EA + 1;
			TMP_SBYTE = TMP_SBYTE - 1;
			recurs;

		endif;

		}
	// !!TOFIX!!

// 2.2.3 Integer Instructions

op int_instr ( x : int_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = x.otawa_kind

op int_instr_action =   int_arithmetic
                      | int_compare
                      | int_logical
                      | int_rotate_shift

// Integer Arithmetic Instructions

op int_arithmetic =   int_add
                    | int_subtract
                    | int_multiply
                    | int_divide
                    | int_negate

// Integer Add Instructions
op int_add ( x : int_add_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = ARITH

op int_add_action =   add
             | add_immediate
             | add_carry
             | add_extended
             | add_mone_extended
             | add_zero_extended


// Add Instructions
op add ( rd : index, ra : REG_IND, rb : REG_IND ,Rc : card (1) , Oe : card(1))
	syntax = format ( "add%s%s r%d,%s,%s",
   		if Oe then "o" else "" endif,
   		if Rc then "." else "" endif, rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s%1b100001010%1b", rd, ra.image, rb.image, Oe, Rc )
   action = {

		TMP_RES = ra + rb;
		if Oe then
				if (ra >= 0 &&  rb >= 0 && TMP_RES < 0) then 
#line 1512 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1512 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1512 "nmp/ppc32.nmp"
    else 
#line 1512 "nmp/ppc32.nmp"
		if (ra < 0 &&  rb < 0 && TMP_RES >= 0) then 
#line 1512 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1512 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1512 "nmp/ppc32.nmp"
     	else 
#line 1512 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1512 "nmp/ppc32.nmp"
		endif; 
#line 1512 "nmp/ppc32.nmp"
	endif;
#line 1512 "nmp/ppc32.nmp"
;
#line 1512 "nmp/ppc32.nmp"
#line 1513 "nmp/ppc32.nmp"
		endif;

		GPR[rd] = TMP_RES;

		if Rc then
				CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1518 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1518 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1518 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1518 "nmp/ppc32.nmp"
;
#line 1518 "nmp/ppc32.nmp"
#line 1519 "nmp/ppc32.nmp"
       	endif;
        }


// Add Immediate Instructions

op add_immediate =   add_imm
                   | add_imm_shifted
                   | add_imm_carry
                   | add_imm_carry_record

op add_imm ( rd : index, ra : REG_IND_ZERO, da : SIMM16 )
   syntax = format ( "addi r%d,%s,%s", rd, ra.syntax, da.syntax)
   image  = format ( "001110%5b%s%s", rd, ra.image, da.image)
   action = {
                GPR [ rd ] = ra + da;
            }

op add_imm_shifted ( rd : index, ra : REG_IND_ZERO, da : SIMM16 )
   syntax = format ( "addis r%d,%s,%s", rd, ra.syntax, da.syntax)
   image  = format ( "001111%5b%s%s", rd, ra.image, da.image)
   action = {
               TMP_SWORD = da;
                GPR [ rd ] = ra + ( TMP_SWORD << 16 );
            }

op add_imm_carry ( rd : index, ra : REG_IND, imm : SIMM16 )
   syntax = format ( "addic r%d,%s,%s", rd, ra.syntax, imm.syntax )
   image  = format ( "001100%5b%s%s", rd, ra.image, imm.image )
   action = {

		TMP_RES = ra + imm;         // Set carry bit
			if (ra >= 0 &&  imm >= 0) then 
#line 1551 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1551 "nmp/ppc32.nmp"
	else 
#line 1551 "nmp/ppc32.nmp"
		if (ra<0 &&  imm<0) then 
#line 1551 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1551 "nmp/ppc32.nmp"
		else 
#line 1551 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1551 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1551 "nmp/ppc32.nmp"
			else 
#line 1551 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1551 "nmp/ppc32.nmp"
			endif; 
#line 1551 "nmp/ppc32.nmp"
		endif; 
#line 1551 "nmp/ppc32.nmp"
	endif; 
#line 1551 "nmp/ppc32.nmp"
;
#line 1551 "nmp/ppc32.nmp"
#line 1552 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

       	}

op add_imm_carry_record ( rd : index, ra : REG_IND, imm : SIMM16 )
   syntax = format ( "addic. r%d,%s,%s", rd, ra.syntax, imm.syntax )
   image  = format ( "001101%5b%s%s", rd, ra.image, imm.image )
   action = {

		TMP_RES = ra + imm;         // Set carry bit
			if (ra >= 0 &&  imm >= 0) then 
#line 1562 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1562 "nmp/ppc32.nmp"
	else 
#line 1562 "nmp/ppc32.nmp"
		if (ra<0 &&  imm<0) then 
#line 1562 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1562 "nmp/ppc32.nmp"
		else 
#line 1562 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1562 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1562 "nmp/ppc32.nmp"
			else 
#line 1562 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1562 "nmp/ppc32.nmp"
			endif; 
#line 1562 "nmp/ppc32.nmp"
		endif; 
#line 1562 "nmp/ppc32.nmp"
	endif; 
#line 1562 "nmp/ppc32.nmp"
;
#line 1562 "nmp/ppc32.nmp"
#line 1563 "nmp/ppc32.nmp"

		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1566 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1566 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1566 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1566 "nmp/ppc32.nmp"
;
#line 1566 "nmp/ppc32.nmp"
#line 1567 "nmp/ppc32.nmp"
  		}

// Add with carry Instructions

op add_carry =   add_carrying
               | add_carry_cr_update
               | add_carry_overflow
               | add_carry_overflow_cr_update

op add_carrying ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "addc r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010100", rd, ra.image, rb.image )
   action = {

		TMP_RES = ra + rb;
			if (ra >= 0 &&  rb >= 0) then 
#line 1582 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1582 "nmp/ppc32.nmp"
	else 
#line 1582 "nmp/ppc32.nmp"
		if (ra<0 &&  rb<0) then 
#line 1582 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1582 "nmp/ppc32.nmp"
		else 
#line 1582 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1582 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1582 "nmp/ppc32.nmp"
			else 
#line 1582 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1582 "nmp/ppc32.nmp"
			endif; 
#line 1582 "nmp/ppc32.nmp"
		endif; 
#line 1582 "nmp/ppc32.nmp"
	endif; 
#line 1582 "nmp/ppc32.nmp"
;
#line 1582 "nmp/ppc32.nmp"
#line 1583 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;
        }

op add_carry_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "addc. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010101", rd, ra.image, rb.image )
   action = {

		TMP_RES = ra + rb;
			if (ra >= 0 &&  rb >= 0) then 
#line 1592 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1592 "nmp/ppc32.nmp"
	else 
#line 1592 "nmp/ppc32.nmp"
		if (ra<0 &&  rb<0) then 
#line 1592 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1592 "nmp/ppc32.nmp"
		else 
#line 1592 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1592 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1592 "nmp/ppc32.nmp"
			else 
#line 1592 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1592 "nmp/ppc32.nmp"
			endif; 
#line 1592 "nmp/ppc32.nmp"
		endif; 
#line 1592 "nmp/ppc32.nmp"
	endif; 
#line 1592 "nmp/ppc32.nmp"
;
#line 1592 "nmp/ppc32.nmp"
#line 1593 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1595 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1595 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1595 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1595 "nmp/ppc32.nmp"
;
#line 1595 "nmp/ppc32.nmp"
#line 1596 "nmp/ppc32.nmp"
        }

op add_carry_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "addco r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000010100", rd, ra.image, rb.image )
   action = {

		TMP_RES = ra + rb;

			if (ra >= 0 &&  rb >= 0) then 
#line 1605 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1605 "nmp/ppc32.nmp"
	else 
#line 1605 "nmp/ppc32.nmp"
		if (ra<0 &&  rb<0) then 
#line 1605 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1605 "nmp/ppc32.nmp"
		else 
#line 1605 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1605 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1605 "nmp/ppc32.nmp"
			else 
#line 1605 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1605 "nmp/ppc32.nmp"
			endif; 
#line 1605 "nmp/ppc32.nmp"
		endif; 
#line 1605 "nmp/ppc32.nmp"
	endif; 
#line 1605 "nmp/ppc32.nmp"
;
#line 1605 "nmp/ppc32.nmp"
#line 1606 "nmp/ppc32.nmp"
			if (ra >= 0 &&  rb >= 0 && TMP_RES < 0) then 
#line 1606 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1606 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1606 "nmp/ppc32.nmp"
    else 
#line 1606 "nmp/ppc32.nmp"
		if (ra < 0 &&  rb < 0 && TMP_RES >= 0) then 
#line 1606 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1606 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1606 "nmp/ppc32.nmp"
     	else 
#line 1606 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1606 "nmp/ppc32.nmp"
		endif; 
#line 1606 "nmp/ppc32.nmp"
	endif;
#line 1606 "nmp/ppc32.nmp"
;
#line 1606 "nmp/ppc32.nmp"
#line 1607 "nmp/ppc32.nmp"

		GPR[rd] = TMP_RES;
      	}

op add_carry_overflow_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "addco. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000010101", rd, ra.image, rb.image )
   action = {

		TMP_RES = ra + rb;

			if (ra >= 0 &&  rb >= 0) then 
#line 1618 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1618 "nmp/ppc32.nmp"
	else 
#line 1618 "nmp/ppc32.nmp"
		if (ra<0 &&  rb<0) then 
#line 1618 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1618 "nmp/ppc32.nmp"
		else 
#line 1618 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1618 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1618 "nmp/ppc32.nmp"
			else 
#line 1618 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1618 "nmp/ppc32.nmp"
			endif; 
#line 1618 "nmp/ppc32.nmp"
		endif; 
#line 1618 "nmp/ppc32.nmp"
	endif; 
#line 1618 "nmp/ppc32.nmp"
;
#line 1618 "nmp/ppc32.nmp"
#line 1619 "nmp/ppc32.nmp"
			if (ra >= 0 &&  rb >= 0 && TMP_RES < 0) then 
#line 1619 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1619 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1619 "nmp/ppc32.nmp"
    else 
#line 1619 "nmp/ppc32.nmp"
		if (ra < 0 &&  rb < 0 && TMP_RES >= 0) then 
#line 1619 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1619 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1619 "nmp/ppc32.nmp"
     	else 
#line 1619 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1619 "nmp/ppc32.nmp"
		endif; 
#line 1619 "nmp/ppc32.nmp"
	endif;
#line 1619 "nmp/ppc32.nmp"
;
#line 1619 "nmp/ppc32.nmp"
#line 1620 "nmp/ppc32.nmp"

		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1623 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1623 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1623 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1623 "nmp/ppc32.nmp"
;
#line 1623 "nmp/ppc32.nmp"
#line 1624 "nmp/ppc32.nmp"
	  	}

// Add extended Instructions

op add_extended =   add_extend
                  | add_extend_cr_update
                  | add_extend_overflow
                  | add_extd_overflow_cr_upd

op add_extend ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "adde r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00100010100", rd, ra.image, rb.image )
   action = {

    	TMP_RES = ra + rb + XER < CA_XER..CA_XER >;
			//if (XER < CA_XER..CA_XER> == 1 && ra == 0 &&  rb == -1) then \
#line 1639 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1639 "nmp/ppc32.nmp"
	//else \
#line 1639 "nmp/ppc32.nmp"
		if (XER < CA_XER..CA_XER> == 0 || (((ra>=0 &&  rb>=0) || (ra<0 &&  rb<0)) &&  TMP_RES!=0) ) then 
#line 1639 "nmp/ppc32.nmp"
				if (ra >= 0 &&  rb >= 0) then 
#line 1639 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1639 "nmp/ppc32.nmp"
	else 
#line 1639 "nmp/ppc32.nmp"
		if (ra<0 &&  rb<0) then 
#line 1639 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1639 "nmp/ppc32.nmp"
		else 
#line 1639 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1639 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1639 "nmp/ppc32.nmp"
			else 
#line 1639 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1639 "nmp/ppc32.nmp"
			endif; 
#line 1639 "nmp/ppc32.nmp"
		endif; 
#line 1639 "nmp/ppc32.nmp"
	endif; 
#line 1639 "nmp/ppc32.nmp"
; 
#line 1639 "nmp/ppc32.nmp"
		else 
#line 1639 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1639 "nmp/ppc32.nmp"
		endif; 
#line 1639 "nmp/ppc32.nmp"
	//endif; \
#line 1639 "nmp/ppc32.nmp"
;
#line 1639 "nmp/ppc32.nmp"
#line 1640 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

       	}

op add_extend_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "adde. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00100010101", rd, ra.image, rb.image )
   action = {

      	TMP_RES = ra + rb + XER <CA_XER..CA_XER>;
			//if (XER < CA_XER..CA_XER> == 1 && ra == 0 &&  rb == -1) then \
#line 1650 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1650 "nmp/ppc32.nmp"
	//else \
#line 1650 "nmp/ppc32.nmp"
		if (XER < CA_XER..CA_XER> == 0 || (((ra>=0 &&  rb>=0) || (ra<0 &&  rb<0)) &&  TMP_RES!=0) ) then 
#line 1650 "nmp/ppc32.nmp"
				if (ra >= 0 &&  rb >= 0) then 
#line 1650 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1650 "nmp/ppc32.nmp"
	else 
#line 1650 "nmp/ppc32.nmp"
		if (ra<0 &&  rb<0) then 
#line 1650 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1650 "nmp/ppc32.nmp"
		else 
#line 1650 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1650 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1650 "nmp/ppc32.nmp"
			else 
#line 1650 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1650 "nmp/ppc32.nmp"
			endif; 
#line 1650 "nmp/ppc32.nmp"
		endif; 
#line 1650 "nmp/ppc32.nmp"
	endif; 
#line 1650 "nmp/ppc32.nmp"
; 
#line 1650 "nmp/ppc32.nmp"
		else 
#line 1650 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1650 "nmp/ppc32.nmp"
		endif; 
#line 1650 "nmp/ppc32.nmp"
	//endif; \
#line 1650 "nmp/ppc32.nmp"
;
#line 1650 "nmp/ppc32.nmp"
#line 1651 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1653 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1653 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1653 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1653 "nmp/ppc32.nmp"
;
#line 1653 "nmp/ppc32.nmp"
#line 1654 "nmp/ppc32.nmp"
		}

op add_extend_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "addeo r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100010100", rd, ra.image, rb.image )
   action = {

      	TMP_RES = ra + rb + XER <CA_XER..CA_XER>;
			//if (XER < CA_XER..CA_XER> == 1 && ra == 0 &&  rb == -1) then \
#line 1662 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1662 "nmp/ppc32.nmp"
	//else \
#line 1662 "nmp/ppc32.nmp"
		if (XER < CA_XER..CA_XER> == 0 || (((ra>=0 &&  rb>=0) || (ra<0 &&  rb<0)) &&  TMP_RES!=0) ) then 
#line 1662 "nmp/ppc32.nmp"
				if (ra >= 0 &&  rb >= 0) then 
#line 1662 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1662 "nmp/ppc32.nmp"
	else 
#line 1662 "nmp/ppc32.nmp"
		if (ra<0 &&  rb<0) then 
#line 1662 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1662 "nmp/ppc32.nmp"
		else 
#line 1662 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1662 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1662 "nmp/ppc32.nmp"
			else 
#line 1662 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1662 "nmp/ppc32.nmp"
			endif; 
#line 1662 "nmp/ppc32.nmp"
		endif; 
#line 1662 "nmp/ppc32.nmp"
	endif; 
#line 1662 "nmp/ppc32.nmp"
; 
#line 1662 "nmp/ppc32.nmp"
		else 
#line 1662 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1662 "nmp/ppc32.nmp"
		endif; 
#line 1662 "nmp/ppc32.nmp"
	//endif; \
#line 1662 "nmp/ppc32.nmp"
;
#line 1662 "nmp/ppc32.nmp"
#line 1663 "nmp/ppc32.nmp"
			if (ra >= 0 &&  rb >= 0 && TMP_RES < 0) then 
#line 1663 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1663 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1663 "nmp/ppc32.nmp"
    else 
#line 1663 "nmp/ppc32.nmp"
		if (ra < 0 &&  rb < 0 && TMP_RES >= 0) then 
#line 1663 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1663 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1663 "nmp/ppc32.nmp"
     	else 
#line 1663 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1663 "nmp/ppc32.nmp"
		endif; 
#line 1663 "nmp/ppc32.nmp"
	endif;
#line 1663 "nmp/ppc32.nmp"
;
#line 1663 "nmp/ppc32.nmp"
#line 1664 "nmp/ppc32.nmp"
		TMP_RES = GPR[rd];

     	}

op add_extd_overflow_cr_upd ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "addeo. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100010101", rd, ra.image, rb.image )
   action = {

      	TMP_RES = ra + rb + XER <CA_XER..CA_XER>;
			//if (XER < CA_XER..CA_XER >  == 1 && ra == 0 &&  rb == -1) then \
#line 1674 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1674 "nmp/ppc32.nmp"
	//else \
#line 1674 "nmp/ppc32.nmp"
		if (XER < CA_XER..CA_XER >  == 0 || (((ra>=0 &&  rb>=0) || (ra<0 &&  rb<0)) &&  TMP_RES!=0) ) then 
#line 1674 "nmp/ppc32.nmp"
				if (ra >= 0 &&  rb >= 0) then 
#line 1674 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1674 "nmp/ppc32.nmp"
	else 
#line 1674 "nmp/ppc32.nmp"
		if (ra<0 &&  rb<0) then 
#line 1674 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1674 "nmp/ppc32.nmp"
		else 
#line 1674 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1674 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1674 "nmp/ppc32.nmp"
			else 
#line 1674 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1674 "nmp/ppc32.nmp"
			endif; 
#line 1674 "nmp/ppc32.nmp"
		endif; 
#line 1674 "nmp/ppc32.nmp"
	endif; 
#line 1674 "nmp/ppc32.nmp"
; 
#line 1674 "nmp/ppc32.nmp"
		else 
#line 1674 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1674 "nmp/ppc32.nmp"
		endif; 
#line 1674 "nmp/ppc32.nmp"
	//endif; \
#line 1674 "nmp/ppc32.nmp"
;
#line 1674 "nmp/ppc32.nmp"
#line 1675 "nmp/ppc32.nmp"
			if (ra >= 0 &&  rb >= 0 && TMP_RES < 0) then 
#line 1675 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1675 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1675 "nmp/ppc32.nmp"
    else 
#line 1675 "nmp/ppc32.nmp"
		if (ra < 0 &&  rb < 0 && TMP_RES >= 0) then 
#line 1675 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1675 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1675 "nmp/ppc32.nmp"
     	else 
#line 1675 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1675 "nmp/ppc32.nmp"
		endif; 
#line 1675 "nmp/ppc32.nmp"
	endif;
#line 1675 "nmp/ppc32.nmp"
;
#line 1675 "nmp/ppc32.nmp"
#line 1676 "nmp/ppc32.nmp"

		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1679 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1679 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1679 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1679 "nmp/ppc32.nmp"
;
#line 1679 "nmp/ppc32.nmp"
#line 1680 "nmp/ppc32.nmp"
  		}

// Add minus one Instructions

op add_mone_extended =   add_me
                       | add_me_cr_update
                       | add_me_overflow
                       | add_me_overflow_cr_update

op add_me ( rd : index, ra : REG_IND)
   syntax = format ( "addme r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000111010100", rd, ra.image )
   action = {

 		TMP_RES = ra + XER <CA_XER..CA_XER> + 0xffffffff;
			//if (XER<CA_XER..CA_XER> == 1 && ra == 0 && -1 == -1) then \
#line 1695 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1695 "nmp/ppc32.nmp"
	//else \
#line 1695 "nmp/ppc32.nmp"
		if (XER<CA_XER..CA_XER> == 0 || (((ra>=0 && -1>=0) || (ra<0 && -1<0)) && TMP_RES!=0) ) then 
#line 1695 "nmp/ppc32.nmp"
				if (ra >= 0 && -1 >= 0) then 
#line 1695 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1695 "nmp/ppc32.nmp"
	else 
#line 1695 "nmp/ppc32.nmp"
		if (ra<0 && -1<0) then 
#line 1695 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1695 "nmp/ppc32.nmp"
		else 
#line 1695 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1695 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1695 "nmp/ppc32.nmp"
			else 
#line 1695 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1695 "nmp/ppc32.nmp"
			endif; 
#line 1695 "nmp/ppc32.nmp"
		endif; 
#line 1695 "nmp/ppc32.nmp"
	endif; 
#line 1695 "nmp/ppc32.nmp"
; 
#line 1695 "nmp/ppc32.nmp"
		else 
#line 1695 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1695 "nmp/ppc32.nmp"
		endif; 
#line 1695 "nmp/ppc32.nmp"
	//endif; \
#line 1695 "nmp/ppc32.nmp"
;
#line 1695 "nmp/ppc32.nmp"
#line 1696 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;
       	}

op add_me_cr_update ( rd : index, ra : REG_IND)
   syntax = format ( "addme. r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000111010101", rd, ra.image )
   action = {

 		TMP_RES = ra + XER <CA_XER..CA_XER> + 0xffffffff;
			//if (XER <CA_XER..CA_XER> == 1 && ra == 0 && -1 == -1) then \
#line 1705 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1705 "nmp/ppc32.nmp"
	//else \
#line 1705 "nmp/ppc32.nmp"
		if (XER <CA_XER..CA_XER> == 0 || (((ra>=0 && -1>=0) || (ra<0 && -1<0)) && TMP_RES!=0) ) then 
#line 1705 "nmp/ppc32.nmp"
				if (ra >= 0 && -1 >= 0) then 
#line 1705 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1705 "nmp/ppc32.nmp"
	else 
#line 1705 "nmp/ppc32.nmp"
		if (ra<0 && -1<0) then 
#line 1705 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1705 "nmp/ppc32.nmp"
		else 
#line 1705 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1705 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1705 "nmp/ppc32.nmp"
			else 
#line 1705 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1705 "nmp/ppc32.nmp"
			endif; 
#line 1705 "nmp/ppc32.nmp"
		endif; 
#line 1705 "nmp/ppc32.nmp"
	endif; 
#line 1705 "nmp/ppc32.nmp"
; 
#line 1705 "nmp/ppc32.nmp"
		else 
#line 1705 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1705 "nmp/ppc32.nmp"
		endif; 
#line 1705 "nmp/ppc32.nmp"
	//endif; \
#line 1705 "nmp/ppc32.nmp"
;
#line 1705 "nmp/ppc32.nmp"
#line 1706 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1708 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1708 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1708 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1708 "nmp/ppc32.nmp"
;
#line 1708 "nmp/ppc32.nmp"
#line 1709 "nmp/ppc32.nmp"
     	}

op add_me_overflow ( rd : index, ra : REG_IND)
   syntax = format ( "addmeo r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010111010100", rd, ra.image )
   action = {

 		TMP_RES = ra + XER <CA_XER..CA_XER> + 0xffffffff;
			//if (XER <CA_XER..CA_XER> == 1 && ra == 0 && -1 == -1) then \
#line 1717 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1717 "nmp/ppc32.nmp"
	//else \
#line 1717 "nmp/ppc32.nmp"
		if (XER <CA_XER..CA_XER> == 0 || (((ra>=0 && -1>=0) || (ra<0 && -1<0)) && TMP_RES!=0) ) then 
#line 1717 "nmp/ppc32.nmp"
				if (ra >= 0 && -1 >= 0) then 
#line 1717 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1717 "nmp/ppc32.nmp"
	else 
#line 1717 "nmp/ppc32.nmp"
		if (ra<0 && -1<0) then 
#line 1717 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1717 "nmp/ppc32.nmp"
		else 
#line 1717 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1717 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1717 "nmp/ppc32.nmp"
			else 
#line 1717 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1717 "nmp/ppc32.nmp"
			endif; 
#line 1717 "nmp/ppc32.nmp"
		endif; 
#line 1717 "nmp/ppc32.nmp"
	endif; 
#line 1717 "nmp/ppc32.nmp"
; 
#line 1717 "nmp/ppc32.nmp"
		else 
#line 1717 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1717 "nmp/ppc32.nmp"
		endif; 
#line 1717 "nmp/ppc32.nmp"
	//endif; \
#line 1717 "nmp/ppc32.nmp"
;
#line 1717 "nmp/ppc32.nmp"
#line 1718 "nmp/ppc32.nmp"
			if (ra >= 0 &&  -1 >= 0 && TMP_RES < 0) then 
#line 1718 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1718 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1718 "nmp/ppc32.nmp"
    else 
#line 1718 "nmp/ppc32.nmp"
		if (ra < 0 &&  -1 < 0 && TMP_RES >= 0) then 
#line 1718 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1718 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1718 "nmp/ppc32.nmp"
     	else 
#line 1718 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1718 "nmp/ppc32.nmp"
		endif; 
#line 1718 "nmp/ppc32.nmp"
	endif;
#line 1718 "nmp/ppc32.nmp"
;
#line 1718 "nmp/ppc32.nmp"
#line 1719 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

    	}

op add_me_overflow_cr_update ( rd : index, ra : REG_IND)
   syntax = format ( "addmeo. r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010111010101", rd, ra.image )
   action = {

 		TMP_RES = ra + XER <CA_XER..CA_XER> + 0xffffffff;
			//if (XER <CA_XER..CA_XER> == 1 && ra == 0 && -1 == -1) then \
#line 1729 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1729 "nmp/ppc32.nmp"
	//else \
#line 1729 "nmp/ppc32.nmp"
		if (XER <CA_XER..CA_XER> == 0 || (((ra>=0 && -1>=0) || (ra<0 && -1<0)) && TMP_RES!=0) ) then 
#line 1729 "nmp/ppc32.nmp"
				if (ra >= 0 && -1 >= 0) then 
#line 1729 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1729 "nmp/ppc32.nmp"
	else 
#line 1729 "nmp/ppc32.nmp"
		if (ra<0 && -1<0) then 
#line 1729 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1729 "nmp/ppc32.nmp"
		else 
#line 1729 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1729 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1729 "nmp/ppc32.nmp"
			else 
#line 1729 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1729 "nmp/ppc32.nmp"
			endif; 
#line 1729 "nmp/ppc32.nmp"
		endif; 
#line 1729 "nmp/ppc32.nmp"
	endif; 
#line 1729 "nmp/ppc32.nmp"
; 
#line 1729 "nmp/ppc32.nmp"
		else 
#line 1729 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1729 "nmp/ppc32.nmp"
		endif; 
#line 1729 "nmp/ppc32.nmp"
	//endif; \
#line 1729 "nmp/ppc32.nmp"
;
#line 1729 "nmp/ppc32.nmp"
#line 1730 "nmp/ppc32.nmp"
			if (ra >= 0 &&  -1 >= 0 && TMP_RES < 0) then 
#line 1730 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1730 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1730 "nmp/ppc32.nmp"
    else 
#line 1730 "nmp/ppc32.nmp"
		if (ra < 0 &&  -1 < 0 && TMP_RES >= 0) then 
#line 1730 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1730 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1730 "nmp/ppc32.nmp"
     	else 
#line 1730 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1730 "nmp/ppc32.nmp"
		endif; 
#line 1730 "nmp/ppc32.nmp"
	endif;
#line 1730 "nmp/ppc32.nmp"
;
#line 1730 "nmp/ppc32.nmp"
#line 1731 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1733 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1733 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1733 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1733 "nmp/ppc32.nmp"
;
#line 1733 "nmp/ppc32.nmp"
#line 1734 "nmp/ppc32.nmp"
  		}

// Add zero extended Instructions

op add_zero_extended =   add_ze
                       | add_ze_cr_update
                       | add_ze_overflow
                       | add_ze_overflow_cr_update

op add_ze ( rd : index, ra : REG_IND)
   syntax = format ( "addze r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000110010100", rd, ra.image )
   action = {

 		TMP_RES = ra + XER <CA_XER..CA_XER>;
			//if (XER<CA_XER..CA_XER> == 1 && ra == 0 && 0 == -1) then \
#line 1749 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1749 "nmp/ppc32.nmp"
	//else \
#line 1749 "nmp/ppc32.nmp"
		if (XER<CA_XER..CA_XER> == 0 || (((ra>=0 && 0>=0) || (ra<0 && 0<0)) && TMP_RES!=0) ) then 
#line 1749 "nmp/ppc32.nmp"
				if (ra >= 0 && 0 >= 0) then 
#line 1749 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1749 "nmp/ppc32.nmp"
	else 
#line 1749 "nmp/ppc32.nmp"
		if (ra<0 && 0<0) then 
#line 1749 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1749 "nmp/ppc32.nmp"
		else 
#line 1749 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1749 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1749 "nmp/ppc32.nmp"
			else 
#line 1749 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1749 "nmp/ppc32.nmp"
			endif; 
#line 1749 "nmp/ppc32.nmp"
		endif; 
#line 1749 "nmp/ppc32.nmp"
	endif; 
#line 1749 "nmp/ppc32.nmp"
; 
#line 1749 "nmp/ppc32.nmp"
		else 
#line 1749 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1749 "nmp/ppc32.nmp"
		endif; 
#line 1749 "nmp/ppc32.nmp"
	//endif; \
#line 1749 "nmp/ppc32.nmp"
;
#line 1749 "nmp/ppc32.nmp"
#line 1750 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

  		}

op add_ze_cr_update ( rd : index, ra : REG_IND)
   syntax = format ( "addze. r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000110010101", rd, ra.image )
   action = {
 		TMP_RES = ra + XER <CA_XER..CA_XER>;
			//if (XER<CA_XER..CA_XER> == 1 && ra == 0 && 0 == -1) then \
#line 1759 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1759 "nmp/ppc32.nmp"
	//else \
#line 1759 "nmp/ppc32.nmp"
		if (XER<CA_XER..CA_XER> == 0 || (((ra>=0 && 0>=0) || (ra<0 && 0<0)) && TMP_RES!=0) ) then 
#line 1759 "nmp/ppc32.nmp"
				if (ra >= 0 && 0 >= 0) then 
#line 1759 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1759 "nmp/ppc32.nmp"
	else 
#line 1759 "nmp/ppc32.nmp"
		if (ra<0 && 0<0) then 
#line 1759 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1759 "nmp/ppc32.nmp"
		else 
#line 1759 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1759 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1759 "nmp/ppc32.nmp"
			else 
#line 1759 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1759 "nmp/ppc32.nmp"
			endif; 
#line 1759 "nmp/ppc32.nmp"
		endif; 
#line 1759 "nmp/ppc32.nmp"
	endif; 
#line 1759 "nmp/ppc32.nmp"
; 
#line 1759 "nmp/ppc32.nmp"
		else 
#line 1759 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1759 "nmp/ppc32.nmp"
		endif; 
#line 1759 "nmp/ppc32.nmp"
	//endif; \
#line 1759 "nmp/ppc32.nmp"
;
#line 1759 "nmp/ppc32.nmp"
#line 1760 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1762 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1762 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1762 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1762 "nmp/ppc32.nmp"
;
#line 1762 "nmp/ppc32.nmp"
#line 1763 "nmp/ppc32.nmp"
      	}

op add_ze_overflow ( rd : index, ra : REG_IND)
   syntax = format ( "addzeo r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010110010100", rd, ra.image )
   action = {

 		TMP_RES = ra + XER <CA_XER..CA_XER>;
			//if (XER<CA_XER..CA_XER> == 1 && ra == 0 && 0 == -1) then \
#line 1771 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1771 "nmp/ppc32.nmp"
	//else \
#line 1771 "nmp/ppc32.nmp"
		if (XER<CA_XER..CA_XER> == 0 || (((ra>=0 && 0>=0) || (ra<0 && 0<0)) && TMP_RES!=0) ) then 
#line 1771 "nmp/ppc32.nmp"
				if (ra >= 0 && 0 >= 0) then 
#line 1771 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1771 "nmp/ppc32.nmp"
	else 
#line 1771 "nmp/ppc32.nmp"
		if (ra<0 && 0<0) then 
#line 1771 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1771 "nmp/ppc32.nmp"
		else 
#line 1771 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1771 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1771 "nmp/ppc32.nmp"
			else 
#line 1771 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1771 "nmp/ppc32.nmp"
			endif; 
#line 1771 "nmp/ppc32.nmp"
		endif; 
#line 1771 "nmp/ppc32.nmp"
	endif; 
#line 1771 "nmp/ppc32.nmp"
; 
#line 1771 "nmp/ppc32.nmp"
		else 
#line 1771 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1771 "nmp/ppc32.nmp"
		endif; 
#line 1771 "nmp/ppc32.nmp"
	//endif; \
#line 1771 "nmp/ppc32.nmp"
;
#line 1771 "nmp/ppc32.nmp"
#line 1772 "nmp/ppc32.nmp"
			if (ra >= 0 && 0 >= 0 && TMP_RES < 0) then 
#line 1772 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1772 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1772 "nmp/ppc32.nmp"
    else 
#line 1772 "nmp/ppc32.nmp"
		if (ra < 0 && 0 < 0 && TMP_RES >= 0) then 
#line 1772 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1772 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1772 "nmp/ppc32.nmp"
     	else 
#line 1772 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1772 "nmp/ppc32.nmp"
		endif; 
#line 1772 "nmp/ppc32.nmp"
	endif;
#line 1772 "nmp/ppc32.nmp"
;
#line 1772 "nmp/ppc32.nmp"
#line 1773 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

		}

op add_ze_overflow_cr_update ( rd : index, ra : REG_IND)
   syntax = format ( "addzeo. r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010110010101", rd, ra.image )
   action = {

 		TMP_RES = ra + XER <CA_XER..CA_XER>;
			//if (XER<CA_XER..CA_XER> == 1 && ra == 0 && 0 == -1) then \
#line 1783 "nmp/ppc32.nmp"
	//	XER <CA_XER..CA_XER> = 0; \
#line 1783 "nmp/ppc32.nmp"
	//else \
#line 1783 "nmp/ppc32.nmp"
		if (XER<CA_XER..CA_XER> == 0 || (((ra>=0 && 0>=0) || (ra<0 && 0<0)) && TMP_RES!=0) ) then 
#line 1783 "nmp/ppc32.nmp"
				if (ra >= 0 && 0 >= 0) then 
#line 1783 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 1783 "nmp/ppc32.nmp"
	else 
#line 1783 "nmp/ppc32.nmp"
		if (ra<0 && 0<0) then 
#line 1783 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1783 "nmp/ppc32.nmp"
		else 
#line 1783 "nmp/ppc32.nmp"
			if (TMP_RES>=0) then 
#line 1783 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 1783 "nmp/ppc32.nmp"
			else 
#line 1783 "nmp/ppc32.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 1783 "nmp/ppc32.nmp"
			endif; 
#line 1783 "nmp/ppc32.nmp"
		endif; 
#line 1783 "nmp/ppc32.nmp"
	endif; 
#line 1783 "nmp/ppc32.nmp"
; 
#line 1783 "nmp/ppc32.nmp"
		else 
#line 1783 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 1783 "nmp/ppc32.nmp"
		endif; 
#line 1783 "nmp/ppc32.nmp"
	//endif; \
#line 1783 "nmp/ppc32.nmp"
;
#line 1783 "nmp/ppc32.nmp"
#line 1784 "nmp/ppc32.nmp"
			if (ra >= 0 && 0 >= 0 && TMP_RES < 0) then 
#line 1784 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1784 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1784 "nmp/ppc32.nmp"
    else 
#line 1784 "nmp/ppc32.nmp"
		if (ra < 0 && 0 < 0 && TMP_RES >= 0) then 
#line 1784 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1784 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1784 "nmp/ppc32.nmp"
     	else 
#line 1784 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1784 "nmp/ppc32.nmp"
		endif; 
#line 1784 "nmp/ppc32.nmp"
	endif;
#line 1784 "nmp/ppc32.nmp"
;
#line 1784 "nmp/ppc32.nmp"
#line 1785 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1787 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1787 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1787 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1787 "nmp/ppc32.nmp"
;
#line 1787 "nmp/ppc32.nmp"
#line 1788 "nmp/ppc32.nmp"
		}

// Integer Subtract Instructions
op int_subtract (x: int_subtract_action)
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = ARITH

op int_subtract_action =   sub_from
                  | sub_imm_carry_rec
                  | sub_carry
                  | sub_extended
                  | sub_mone_extended
                  | sub_zero_extended

op sub_from =   sub
              | sub_cr_update
              | sub_overflow_enable
              | sub_crup_overen

// Subtract Instructions

op sub ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subf r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00001010000", rd, ra.image, rb.image )
   action = {

               GPR [ rd ] = ~ra + rb + 1;

            }

op sub_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subf. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00001010001", rd, ra.image, rb.image )
   action = {

		TMP_RES = ~ra + rb + 1;
	  	GPR [ rd ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1827 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1827 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1827 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1827 "nmp/ppc32.nmp"
;
#line 1827 "nmp/ppc32.nmp"
#line 1828 "nmp/ppc32.nmp"
		}

op sub_overflow_enable ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subfo r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10001010000", rd, ra.image, rb.image )
   action = {

      	TMP_RES = ~ra + rb + 1;

			if ra >= 0 then 
#line 1837 "nmp/ppc32.nmp"
		if  rb >= 0 then 
#line 1837 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1837 "nmp/ppc32.nmp"
		else 
#line 1837 "nmp/ppc32.nmp"
			if TMP_RES < 0 then 
#line 1837 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1837 "nmp/ppc32.nmp"
			else 
#line 1837 "nmp/ppc32.nmp"
				XER <OV_XER..OV_XER> = 1; 
#line 1837 "nmp/ppc32.nmp"
	    	  	XER <SO_XER..SO_XER> = 1; 
#line 1837 "nmp/ppc32.nmp"
			endif; 
#line 1837 "nmp/ppc32.nmp"
		endif; 
#line 1837 "nmp/ppc32.nmp"
	else 
#line 1837 "nmp/ppc32.nmp"
		if ra == 0x80000000 then 
#line 1837 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1837 "nmp/ppc32.nmp"
    	  	XER <SO_XER..SO_XER> = 1; 
#line 1837 "nmp/ppc32.nmp"
		else 
#line 1837 "nmp/ppc32.nmp"
			if  rb < 0 then 
#line 1837 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1837 "nmp/ppc32.nmp"
			else 
#line 1837 "nmp/ppc32.nmp"
				if TMP_RES < 0 then 
#line 1837 "nmp/ppc32.nmp"
					XER <OV_XER..OV_XER> = 1; 
#line 1837 "nmp/ppc32.nmp"
      				XER <SO_XER..SO_XER> = 1; 
#line 1837 "nmp/ppc32.nmp"
				else 
#line 1837 "nmp/ppc32.nmp"
		          	XER <OV_XER..OV_XER> = 0; 
#line 1837 "nmp/ppc32.nmp"
				endif; 
#line 1837 "nmp/ppc32.nmp"
			endif; 
#line 1837 "nmp/ppc32.nmp"
		endif; 
#line 1837 "nmp/ppc32.nmp"
	endif; 
#line 1837 "nmp/ppc32.nmp"
;
#line 1837 "nmp/ppc32.nmp"
#line 1838 "nmp/ppc32.nmp"
  		GPR[rd] = TMP_RES;
		}

op sub_crup_overen ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subfo. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10001010001", rd, ra.image, rb.image )
   action = {

      	TMP_RES = ~ra + rb + 1;
			if ra >= 0 then 
#line 1847 "nmp/ppc32.nmp"
		if  rb >= 0 then 
#line 1847 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1847 "nmp/ppc32.nmp"
		else 
#line 1847 "nmp/ppc32.nmp"
			if TMP_RES < 0 then 
#line 1847 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1847 "nmp/ppc32.nmp"
			else 
#line 1847 "nmp/ppc32.nmp"
				XER <OV_XER..OV_XER> = 1; 
#line 1847 "nmp/ppc32.nmp"
	    	  	XER <SO_XER..SO_XER> = 1; 
#line 1847 "nmp/ppc32.nmp"
			endif; 
#line 1847 "nmp/ppc32.nmp"
		endif; 
#line 1847 "nmp/ppc32.nmp"
	else 
#line 1847 "nmp/ppc32.nmp"
		if ra == 0x80000000 then 
#line 1847 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1847 "nmp/ppc32.nmp"
    	  	XER <SO_XER..SO_XER> = 1; 
#line 1847 "nmp/ppc32.nmp"
		else 
#line 1847 "nmp/ppc32.nmp"
			if  rb < 0 then 
#line 1847 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1847 "nmp/ppc32.nmp"
			else 
#line 1847 "nmp/ppc32.nmp"
				if TMP_RES < 0 then 
#line 1847 "nmp/ppc32.nmp"
					XER <OV_XER..OV_XER> = 1; 
#line 1847 "nmp/ppc32.nmp"
      				XER <SO_XER..SO_XER> = 1; 
#line 1847 "nmp/ppc32.nmp"
				else 
#line 1847 "nmp/ppc32.nmp"
		          	XER <OV_XER..OV_XER> = 0; 
#line 1847 "nmp/ppc32.nmp"
				endif; 
#line 1847 "nmp/ppc32.nmp"
			endif; 
#line 1847 "nmp/ppc32.nmp"
		endif; 
#line 1847 "nmp/ppc32.nmp"
	endif; 
#line 1847 "nmp/ppc32.nmp"
;
#line 1847 "nmp/ppc32.nmp"
#line 1848 "nmp/ppc32.nmp"
		GPR[rd]=TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1849 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1849 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1849 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1849 "nmp/ppc32.nmp"
;
#line 1849 "nmp/ppc32.nmp"
#line 1850 "nmp/ppc32.nmp"
		}

// Subtract Immediate Instruction

op sub_imm_carry_rec ( rd : index, ra : REG_IND, imm : IMM16 )
   syntax = format ( "subfic r%d,%s,%s", rd, ra.syntax, imm.syntax )
   image  = format ( "001000%5b%s%s", rd, ra.image, imm.image )
   action = {

		TMP_RES = ~ra + 1 + imm;
        	if (ra >= 0 && imm < 0) then 
#line 1860 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 1860 "nmp/ppc32.nmp"
	else 
#line 1860 "nmp/ppc32.nmp"
		if (ra < 0 && imm >= 0) then 
#line 1860 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 1860 "nmp/ppc32.nmp"
		else 
#line 1860 "nmp/ppc32.nmp"
			if 1 == 1 then 
#line 1860 "nmp/ppc32.nmp"
				if ra > imm then 
#line 1860 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1860 "nmp/ppc32.nmp"
				else 
#line 1860 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1860 "nmp/ppc32.nmp"
				endif; 
#line 1860 "nmp/ppc32.nmp"
			else 
#line 1860 "nmp/ppc32.nmp"
				if ra >= imm then 
#line 1860 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1860 "nmp/ppc32.nmp"
				else 
#line 1860 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1860 "nmp/ppc32.nmp"
				endif; 
#line 1860 "nmp/ppc32.nmp"
			endif; 
#line 1860 "nmp/ppc32.nmp"
		endif; 
#line 1860 "nmp/ppc32.nmp"
	endif;
#line 1860 "nmp/ppc32.nmp"
;
#line 1860 "nmp/ppc32.nmp"
#line 1861 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

    	}

// Subtract with carry Instructions

op sub_carry =   sub_carrying
               | sub_carry_cr_update
               | sub_carry_overflow
               | sub_carry_overflow_cr_update

op sub_carrying ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subfc r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010000", rd, ra.image, rb.image )
   action = {

  		TMP_RES = ~ra + rb + 1;
			if (ra >= 0 && rb < 0) then 
#line 1878 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 1878 "nmp/ppc32.nmp"
	else 
#line 1878 "nmp/ppc32.nmp"
		if (ra < 0 && rb >= 0) then 
#line 1878 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 1878 "nmp/ppc32.nmp"
		else 
#line 1878 "nmp/ppc32.nmp"
			if 1 == 1 then 
#line 1878 "nmp/ppc32.nmp"
				if ra > rb then 
#line 1878 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1878 "nmp/ppc32.nmp"
				else 
#line 1878 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1878 "nmp/ppc32.nmp"
				endif; 
#line 1878 "nmp/ppc32.nmp"
			else 
#line 1878 "nmp/ppc32.nmp"
				if ra >= rb then 
#line 1878 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1878 "nmp/ppc32.nmp"
				else 
#line 1878 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1878 "nmp/ppc32.nmp"
				endif; 
#line 1878 "nmp/ppc32.nmp"
			endif; 
#line 1878 "nmp/ppc32.nmp"
		endif; 
#line 1878 "nmp/ppc32.nmp"
	endif;
#line 1878 "nmp/ppc32.nmp"
;
#line 1878 "nmp/ppc32.nmp"
#line 1879 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;
   		}

op sub_carry_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subfc. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010001", rd, ra.image, rb.image )
   action = {

    	TMP_RES = ~ra + rb + 1;

			if (ra >= 0 && rb < 0) then 
#line 1889 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 1889 "nmp/ppc32.nmp"
	else 
#line 1889 "nmp/ppc32.nmp"
		if (ra < 0 && rb >= 0) then 
#line 1889 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 1889 "nmp/ppc32.nmp"
		else 
#line 1889 "nmp/ppc32.nmp"
			if 1 == 1 then 
#line 1889 "nmp/ppc32.nmp"
				if ra > rb then 
#line 1889 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1889 "nmp/ppc32.nmp"
				else 
#line 1889 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1889 "nmp/ppc32.nmp"
				endif; 
#line 1889 "nmp/ppc32.nmp"
			else 
#line 1889 "nmp/ppc32.nmp"
				if ra >= rb then 
#line 1889 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1889 "nmp/ppc32.nmp"
				else 
#line 1889 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1889 "nmp/ppc32.nmp"
				endif; 
#line 1889 "nmp/ppc32.nmp"
			endif; 
#line 1889 "nmp/ppc32.nmp"
		endif; 
#line 1889 "nmp/ppc32.nmp"
	endif;
#line 1889 "nmp/ppc32.nmp"
;
#line 1889 "nmp/ppc32.nmp"
#line 1890 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1891 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1891 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1891 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1891 "nmp/ppc32.nmp"
;
#line 1891 "nmp/ppc32.nmp"
#line 1892 "nmp/ppc32.nmp"
     	}

op sub_carry_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subfco r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000010000", rd, ra.image, rb.image )
   action = {

    	TMP_RES = ~ra + rb + 1;

			if (ra >= 0 && rb < 0) then 
#line 1901 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 1901 "nmp/ppc32.nmp"
	else 
#line 1901 "nmp/ppc32.nmp"
		if (ra < 0 && rb >= 0) then 
#line 1901 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 1901 "nmp/ppc32.nmp"
		else 
#line 1901 "nmp/ppc32.nmp"
			if 1 == 1 then 
#line 1901 "nmp/ppc32.nmp"
				if ra > rb then 
#line 1901 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1901 "nmp/ppc32.nmp"
				else 
#line 1901 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1901 "nmp/ppc32.nmp"
				endif; 
#line 1901 "nmp/ppc32.nmp"
			else 
#line 1901 "nmp/ppc32.nmp"
				if ra >= rb then 
#line 1901 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1901 "nmp/ppc32.nmp"
				else 
#line 1901 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1901 "nmp/ppc32.nmp"
				endif; 
#line 1901 "nmp/ppc32.nmp"
			endif; 
#line 1901 "nmp/ppc32.nmp"
		endif; 
#line 1901 "nmp/ppc32.nmp"
	endif;
#line 1901 "nmp/ppc32.nmp"
;
#line 1901 "nmp/ppc32.nmp"
#line 1902 "nmp/ppc32.nmp"
			if ra >= 0 then 
#line 1902 "nmp/ppc32.nmp"
		if rb >= 0 then 
#line 1902 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1902 "nmp/ppc32.nmp"
		else 
#line 1902 "nmp/ppc32.nmp"
			if TMP_RES < 0 then 
#line 1902 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1902 "nmp/ppc32.nmp"
			else 
#line 1902 "nmp/ppc32.nmp"
				XER <OV_XER..OV_XER> = 1; 
#line 1902 "nmp/ppc32.nmp"
	    	  	XER <SO_XER..SO_XER> = 1; 
#line 1902 "nmp/ppc32.nmp"
			endif; 
#line 1902 "nmp/ppc32.nmp"
		endif; 
#line 1902 "nmp/ppc32.nmp"
	else 
#line 1902 "nmp/ppc32.nmp"
		if ra == 0x80000000 then 
#line 1902 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1902 "nmp/ppc32.nmp"
    	  	XER <SO_XER..SO_XER> = 1; 
#line 1902 "nmp/ppc32.nmp"
		else 
#line 1902 "nmp/ppc32.nmp"
			if rb < 0 then 
#line 1902 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1902 "nmp/ppc32.nmp"
			else 
#line 1902 "nmp/ppc32.nmp"
				if TMP_RES < 0 then 
#line 1902 "nmp/ppc32.nmp"
					XER <OV_XER..OV_XER> = 1; 
#line 1902 "nmp/ppc32.nmp"
      				XER <SO_XER..SO_XER> = 1; 
#line 1902 "nmp/ppc32.nmp"
				else 
#line 1902 "nmp/ppc32.nmp"
		          	XER <OV_XER..OV_XER> = 0; 
#line 1902 "nmp/ppc32.nmp"
				endif; 
#line 1902 "nmp/ppc32.nmp"
			endif; 
#line 1902 "nmp/ppc32.nmp"
		endif; 
#line 1902 "nmp/ppc32.nmp"
	endif; 
#line 1902 "nmp/ppc32.nmp"
;
#line 1902 "nmp/ppc32.nmp"
#line 1903 "nmp/ppc32.nmp"

		GPR[rd] = TMP_RES;
		}

op sub_carry_overflow_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subfco. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000010001", rd, ra.image, rb.image )
   action = {

    	TMP_RES = ~ra + rb + 1;

			if (ra >= 0 && rb < 0) then 
#line 1914 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 1914 "nmp/ppc32.nmp"
	else 
#line 1914 "nmp/ppc32.nmp"
		if (ra < 0 && rb >= 0) then 
#line 1914 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 1914 "nmp/ppc32.nmp"
		else 
#line 1914 "nmp/ppc32.nmp"
			if 1 == 1 then 
#line 1914 "nmp/ppc32.nmp"
				if ra > rb then 
#line 1914 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1914 "nmp/ppc32.nmp"
				else 
#line 1914 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1914 "nmp/ppc32.nmp"
				endif; 
#line 1914 "nmp/ppc32.nmp"
			else 
#line 1914 "nmp/ppc32.nmp"
				if ra >= rb then 
#line 1914 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1914 "nmp/ppc32.nmp"
				else 
#line 1914 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1914 "nmp/ppc32.nmp"
				endif; 
#line 1914 "nmp/ppc32.nmp"
			endif; 
#line 1914 "nmp/ppc32.nmp"
		endif; 
#line 1914 "nmp/ppc32.nmp"
	endif;
#line 1914 "nmp/ppc32.nmp"
;
#line 1914 "nmp/ppc32.nmp"
#line 1915 "nmp/ppc32.nmp"
			if ra >= 0 then 
#line 1915 "nmp/ppc32.nmp"
		if rb >= 0 then 
#line 1915 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1915 "nmp/ppc32.nmp"
		else 
#line 1915 "nmp/ppc32.nmp"
			if TMP_RES < 0 then 
#line 1915 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1915 "nmp/ppc32.nmp"
			else 
#line 1915 "nmp/ppc32.nmp"
				XER <OV_XER..OV_XER> = 1; 
#line 1915 "nmp/ppc32.nmp"
	    	  	XER <SO_XER..SO_XER> = 1; 
#line 1915 "nmp/ppc32.nmp"
			endif; 
#line 1915 "nmp/ppc32.nmp"
		endif; 
#line 1915 "nmp/ppc32.nmp"
	else 
#line 1915 "nmp/ppc32.nmp"
		if ra == 0x80000000 then 
#line 1915 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1915 "nmp/ppc32.nmp"
    	  	XER <SO_XER..SO_XER> = 1; 
#line 1915 "nmp/ppc32.nmp"
		else 
#line 1915 "nmp/ppc32.nmp"
			if rb < 0 then 
#line 1915 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1915 "nmp/ppc32.nmp"
			else 
#line 1915 "nmp/ppc32.nmp"
				if TMP_RES < 0 then 
#line 1915 "nmp/ppc32.nmp"
					XER <OV_XER..OV_XER> = 1; 
#line 1915 "nmp/ppc32.nmp"
      				XER <SO_XER..SO_XER> = 1; 
#line 1915 "nmp/ppc32.nmp"
				else 
#line 1915 "nmp/ppc32.nmp"
		          	XER <OV_XER..OV_XER> = 0; 
#line 1915 "nmp/ppc32.nmp"
				endif; 
#line 1915 "nmp/ppc32.nmp"
			endif; 
#line 1915 "nmp/ppc32.nmp"
		endif; 
#line 1915 "nmp/ppc32.nmp"
	endif; 
#line 1915 "nmp/ppc32.nmp"
;
#line 1915 "nmp/ppc32.nmp"
#line 1916 "nmp/ppc32.nmp"

		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1919 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1919 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1919 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1919 "nmp/ppc32.nmp"
;
#line 1919 "nmp/ppc32.nmp"
#line 1920 "nmp/ppc32.nmp"
     	}

// Subtract extended Instructions

op sub_extended =   sub_extend
                  | sub_extend_cr_update
                  | sub_extend_overflow
                  | sub_extd_overflow_cr_upd

op sub_extend ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subfe r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00100010000", rd, ra.image, rb.image )
   action = {

		TMP_RES = ~ra + rb + XER <CA_XER..CA_XER>;
			if (ra >= 0 && rb < 0) then 
#line 1935 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 1935 "nmp/ppc32.nmp"
	else 
#line 1935 "nmp/ppc32.nmp"
		if (ra < 0 && rb >= 0) then 
#line 1935 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 1935 "nmp/ppc32.nmp"
		else 
#line 1935 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 1935 "nmp/ppc32.nmp"
				if ra > rb then 
#line 1935 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1935 "nmp/ppc32.nmp"
				else 
#line 1935 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1935 "nmp/ppc32.nmp"
				endif; 
#line 1935 "nmp/ppc32.nmp"
			else 
#line 1935 "nmp/ppc32.nmp"
				if ra >= rb then 
#line 1935 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1935 "nmp/ppc32.nmp"
				else 
#line 1935 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1935 "nmp/ppc32.nmp"
				endif; 
#line 1935 "nmp/ppc32.nmp"
			endif; 
#line 1935 "nmp/ppc32.nmp"
		endif; 
#line 1935 "nmp/ppc32.nmp"
	endif;
#line 1935 "nmp/ppc32.nmp"
;
#line 1935 "nmp/ppc32.nmp"
#line 1936 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

     	}

op sub_extend_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subfe. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00100010001", rd, ra.image, rb.image )
   action = {

		TMP_RES = ~ra + rb + XER <CA_XER..CA_XER>;
			if (ra >= 0 && rb < 0) then 
#line 1946 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 1946 "nmp/ppc32.nmp"
	else 
#line 1946 "nmp/ppc32.nmp"
		if (ra < 0 && rb >= 0) then 
#line 1946 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 1946 "nmp/ppc32.nmp"
		else 
#line 1946 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 1946 "nmp/ppc32.nmp"
				if ra > rb then 
#line 1946 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1946 "nmp/ppc32.nmp"
				else 
#line 1946 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1946 "nmp/ppc32.nmp"
				endif; 
#line 1946 "nmp/ppc32.nmp"
			else 
#line 1946 "nmp/ppc32.nmp"
				if ra >= rb then 
#line 1946 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1946 "nmp/ppc32.nmp"
				else 
#line 1946 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1946 "nmp/ppc32.nmp"
				endif; 
#line 1946 "nmp/ppc32.nmp"
			endif; 
#line 1946 "nmp/ppc32.nmp"
		endif; 
#line 1946 "nmp/ppc32.nmp"
	endif;
#line 1946 "nmp/ppc32.nmp"
;
#line 1946 "nmp/ppc32.nmp"
#line 1947 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1949 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1949 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1949 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1949 "nmp/ppc32.nmp"
;
#line 1949 "nmp/ppc32.nmp"
#line 1950 "nmp/ppc32.nmp"
      	}

op sub_extend_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subfeo r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100010000", rd, ra.image, rb.image )
   action = {

		TMP_RES = ~ra + rb + XER <CA_XER..CA_XER>;
			if (ra >= 0 && rb < 0) then 
#line 1958 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 1958 "nmp/ppc32.nmp"
	else 
#line 1958 "nmp/ppc32.nmp"
		if (ra < 0 && rb >= 0) then 
#line 1958 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 1958 "nmp/ppc32.nmp"
		else 
#line 1958 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 1958 "nmp/ppc32.nmp"
				if ra > rb then 
#line 1958 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1958 "nmp/ppc32.nmp"
				else 
#line 1958 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1958 "nmp/ppc32.nmp"
				endif; 
#line 1958 "nmp/ppc32.nmp"
			else 
#line 1958 "nmp/ppc32.nmp"
				if ra >= rb then 
#line 1958 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1958 "nmp/ppc32.nmp"
				else 
#line 1958 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1958 "nmp/ppc32.nmp"
				endif; 
#line 1958 "nmp/ppc32.nmp"
			endif; 
#line 1958 "nmp/ppc32.nmp"
		endif; 
#line 1958 "nmp/ppc32.nmp"
	endif;
#line 1958 "nmp/ppc32.nmp"
;
#line 1958 "nmp/ppc32.nmp"
#line 1959 "nmp/ppc32.nmp"
			if TMP_RES==0 then 
#line 1959 "nmp/ppc32.nmp"
			if (~ra >= 0 && rb >= 0 && XER<CA_XER..CA_XER> < 0) then 
#line 1959 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1959 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1959 "nmp/ppc32.nmp"
    else 
#line 1959 "nmp/ppc32.nmp"
		if (~ra < 0 && rb < 0 && XER<CA_XER..CA_XER> >= 0) then 
#line 1959 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1959 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1959 "nmp/ppc32.nmp"
     	else 
#line 1959 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1959 "nmp/ppc32.nmp"
		endif; 
#line 1959 "nmp/ppc32.nmp"
	endif;
#line 1959 "nmp/ppc32.nmp"
; 
#line 1959 "nmp/ppc32.nmp"
	else 
#line 1959 "nmp/ppc32.nmp"
			if ra >= 0 then 
#line 1959 "nmp/ppc32.nmp"
		if rb >= 0 then 
#line 1959 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1959 "nmp/ppc32.nmp"
		else 
#line 1959 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> < 0 then 
#line 1959 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1959 "nmp/ppc32.nmp"
			else 
#line 1959 "nmp/ppc32.nmp"
				XER <OV_XER..OV_XER> = 1; 
#line 1959 "nmp/ppc32.nmp"
	    	  	XER <SO_XER..SO_XER> = 1; 
#line 1959 "nmp/ppc32.nmp"
			endif; 
#line 1959 "nmp/ppc32.nmp"
		endif; 
#line 1959 "nmp/ppc32.nmp"
	else 
#line 1959 "nmp/ppc32.nmp"
		if ra == 0x80000000 then 
#line 1959 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1959 "nmp/ppc32.nmp"
    	  	XER <SO_XER..SO_XER> = 1; 
#line 1959 "nmp/ppc32.nmp"
		else 
#line 1959 "nmp/ppc32.nmp"
			if rb < 0 then 
#line 1959 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1959 "nmp/ppc32.nmp"
			else 
#line 1959 "nmp/ppc32.nmp"
				if XER<CA_XER..CA_XER> < 0 then 
#line 1959 "nmp/ppc32.nmp"
					XER <OV_XER..OV_XER> = 1; 
#line 1959 "nmp/ppc32.nmp"
      				XER <SO_XER..SO_XER> = 1; 
#line 1959 "nmp/ppc32.nmp"
				else 
#line 1959 "nmp/ppc32.nmp"
		          	XER <OV_XER..OV_XER> = 0; 
#line 1959 "nmp/ppc32.nmp"
				endif; 
#line 1959 "nmp/ppc32.nmp"
			endif; 
#line 1959 "nmp/ppc32.nmp"
		endif; 
#line 1959 "nmp/ppc32.nmp"
	endif; 
#line 1959 "nmp/ppc32.nmp"
; 
#line 1959 "nmp/ppc32.nmp"
	endif; 
#line 1959 "nmp/ppc32.nmp"
;
#line 1959 "nmp/ppc32.nmp"
#line 1960 "nmp/ppc32.nmp"
    	GPR[rd] = TMP_RES;

		}

op sub_extd_overflow_cr_upd ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "subfeo. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100010001", rd, ra.image, rb.image )
   action = {

		TMP_RES = ~ra + rb + XER <CA_XER..CA_XER>;
			if (ra >= 0 && rb < 0) then 
#line 1970 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 1970 "nmp/ppc32.nmp"
	else 
#line 1970 "nmp/ppc32.nmp"
		if (ra < 0 && rb >= 0) then 
#line 1970 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 1970 "nmp/ppc32.nmp"
		else 
#line 1970 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 1970 "nmp/ppc32.nmp"
				if ra > rb then 
#line 1970 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1970 "nmp/ppc32.nmp"
				else 
#line 1970 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1970 "nmp/ppc32.nmp"
				endif; 
#line 1970 "nmp/ppc32.nmp"
			else 
#line 1970 "nmp/ppc32.nmp"
				if ra >= rb then 
#line 1970 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1970 "nmp/ppc32.nmp"
				else 
#line 1970 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1970 "nmp/ppc32.nmp"
				endif; 
#line 1970 "nmp/ppc32.nmp"
			endif; 
#line 1970 "nmp/ppc32.nmp"
		endif; 
#line 1970 "nmp/ppc32.nmp"
	endif;
#line 1970 "nmp/ppc32.nmp"
;
#line 1970 "nmp/ppc32.nmp"
#line 1971 "nmp/ppc32.nmp"
			if TMP_RES==0 then 
#line 1971 "nmp/ppc32.nmp"
			if (~ra >= 0 && rb >= 0 && XER<CA_XER..CA_XER> < 0) then 
#line 1971 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 1971 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 1971 "nmp/ppc32.nmp"
    else 
#line 1971 "nmp/ppc32.nmp"
		if (~ra < 0 && rb < 0 && XER<CA_XER..CA_XER> >= 0) then 
#line 1971 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1971 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 1971 "nmp/ppc32.nmp"
     	else 
#line 1971 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1971 "nmp/ppc32.nmp"
		endif; 
#line 1971 "nmp/ppc32.nmp"
	endif;
#line 1971 "nmp/ppc32.nmp"
; 
#line 1971 "nmp/ppc32.nmp"
	else 
#line 1971 "nmp/ppc32.nmp"
			if ra >= 0 then 
#line 1971 "nmp/ppc32.nmp"
		if rb >= 0 then 
#line 1971 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 1971 "nmp/ppc32.nmp"
		else 
#line 1971 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> < 0 then 
#line 1971 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1971 "nmp/ppc32.nmp"
			else 
#line 1971 "nmp/ppc32.nmp"
				XER <OV_XER..OV_XER> = 1; 
#line 1971 "nmp/ppc32.nmp"
	    	  	XER <SO_XER..SO_XER> = 1; 
#line 1971 "nmp/ppc32.nmp"
			endif; 
#line 1971 "nmp/ppc32.nmp"
		endif; 
#line 1971 "nmp/ppc32.nmp"
	else 
#line 1971 "nmp/ppc32.nmp"
		if ra == 0x80000000 then 
#line 1971 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 1971 "nmp/ppc32.nmp"
    	  	XER <SO_XER..SO_XER> = 1; 
#line 1971 "nmp/ppc32.nmp"
		else 
#line 1971 "nmp/ppc32.nmp"
			if rb < 0 then 
#line 1971 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 1971 "nmp/ppc32.nmp"
			else 
#line 1971 "nmp/ppc32.nmp"
				if XER<CA_XER..CA_XER> < 0 then 
#line 1971 "nmp/ppc32.nmp"
					XER <OV_XER..OV_XER> = 1; 
#line 1971 "nmp/ppc32.nmp"
      				XER <SO_XER..SO_XER> = 1; 
#line 1971 "nmp/ppc32.nmp"
				else 
#line 1971 "nmp/ppc32.nmp"
		          	XER <OV_XER..OV_XER> = 0; 
#line 1971 "nmp/ppc32.nmp"
				endif; 
#line 1971 "nmp/ppc32.nmp"
			endif; 
#line 1971 "nmp/ppc32.nmp"
		endif; 
#line 1971 "nmp/ppc32.nmp"
	endif; 
#line 1971 "nmp/ppc32.nmp"
; 
#line 1971 "nmp/ppc32.nmp"
	endif; 
#line 1971 "nmp/ppc32.nmp"
;
#line 1971 "nmp/ppc32.nmp"
#line 1972 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 1974 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 1974 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 1974 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 1974 "nmp/ppc32.nmp"
;
#line 1974 "nmp/ppc32.nmp"
#line 1975 "nmp/ppc32.nmp"
		}

// Subtract minus one Instructions

op sub_mone_extended =   sub_me
                       | sub_me_cr_update
                       | sub_me_overflow
                       | sub_me_overflow_cr_update

op sub_me ( rd : index, ra : REG_IND)
   syntax = format ( "subfme r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000111010000", rd, ra.image )
   action = {

     	TMP_RES = ~ra + XER <CA_XER..CA_XER> + 0xffffffff;
			if (ra >= 0 && -1 < 0) then 
#line 1990 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 1990 "nmp/ppc32.nmp"
	else 
#line 1990 "nmp/ppc32.nmp"
		if (ra < 0 && -1 >= 0) then 
#line 1990 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 1990 "nmp/ppc32.nmp"
		else 
#line 1990 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 1990 "nmp/ppc32.nmp"
				if ra > -1 then 
#line 1990 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1990 "nmp/ppc32.nmp"
				else 
#line 1990 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1990 "nmp/ppc32.nmp"
				endif; 
#line 1990 "nmp/ppc32.nmp"
			else 
#line 1990 "nmp/ppc32.nmp"
				if ra >= -1 then 
#line 1990 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 1990 "nmp/ppc32.nmp"
				else 
#line 1990 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 1990 "nmp/ppc32.nmp"
				endif; 
#line 1990 "nmp/ppc32.nmp"
			endif; 
#line 1990 "nmp/ppc32.nmp"
		endif; 
#line 1990 "nmp/ppc32.nmp"
	endif;
#line 1990 "nmp/ppc32.nmp"
;
#line 1990 "nmp/ppc32.nmp"
#line 1991 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;
       	}

op sub_me_cr_update ( rd : index, ra : REG_IND)
   syntax = format ( "subfme. r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000111010001", rd, ra.image )
   action = {

     	TMP_RES = ~ra + XER <CA_XER..CA_XER> + 0xffffffff;
			if (ra >= 0 && -1 < 0) then 
#line 2000 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 2000 "nmp/ppc32.nmp"
	else 
#line 2000 "nmp/ppc32.nmp"
		if (ra < 0 && -1 >= 0) then 
#line 2000 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 2000 "nmp/ppc32.nmp"
		else 
#line 2000 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 2000 "nmp/ppc32.nmp"
				if ra > -1 then 
#line 2000 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2000 "nmp/ppc32.nmp"
				else 
#line 2000 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2000 "nmp/ppc32.nmp"
				endif; 
#line 2000 "nmp/ppc32.nmp"
			else 
#line 2000 "nmp/ppc32.nmp"
				if ra >= -1 then 
#line 2000 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2000 "nmp/ppc32.nmp"
				else 
#line 2000 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2000 "nmp/ppc32.nmp"
				endif; 
#line 2000 "nmp/ppc32.nmp"
			endif; 
#line 2000 "nmp/ppc32.nmp"
		endif; 
#line 2000 "nmp/ppc32.nmp"
	endif;
#line 2000 "nmp/ppc32.nmp"
;
#line 2000 "nmp/ppc32.nmp"
#line 2001 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2003 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2003 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2003 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2003 "nmp/ppc32.nmp"
;
#line 2003 "nmp/ppc32.nmp"
#line 2004 "nmp/ppc32.nmp"
       	}

op sub_me_overflow ( rd : index, ra : REG_IND)
   syntax = format ( "subfmeo r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010111010000", rd, ra.image )
   action = {
     	TMP_RES = ~ra + XER <CA_XER..CA_XER> + 0xffffffff;
			if (ra >= 0 && -1 < 0) then 
#line 2011 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 2011 "nmp/ppc32.nmp"
	else 
#line 2011 "nmp/ppc32.nmp"
		if (ra < 0 && -1 >= 0) then 
#line 2011 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 2011 "nmp/ppc32.nmp"
		else 
#line 2011 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 2011 "nmp/ppc32.nmp"
				if ra > -1 then 
#line 2011 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2011 "nmp/ppc32.nmp"
				else 
#line 2011 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2011 "nmp/ppc32.nmp"
				endif; 
#line 2011 "nmp/ppc32.nmp"
			else 
#line 2011 "nmp/ppc32.nmp"
				if ra >= -1 then 
#line 2011 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2011 "nmp/ppc32.nmp"
				else 
#line 2011 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2011 "nmp/ppc32.nmp"
				endif; 
#line 2011 "nmp/ppc32.nmp"
			endif; 
#line 2011 "nmp/ppc32.nmp"
		endif; 
#line 2011 "nmp/ppc32.nmp"
	endif;
#line 2011 "nmp/ppc32.nmp"
;
#line 2011 "nmp/ppc32.nmp"
#line 2012 "nmp/ppc32.nmp"
			if TMP_RES==0 then 
#line 2012 "nmp/ppc32.nmp"
			if (~ra >= 0 && -1 >= 0 && XER<CA_XER..CA_XER> < 0) then 
#line 2012 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2012 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 2012 "nmp/ppc32.nmp"
    else 
#line 2012 "nmp/ppc32.nmp"
		if (~ra < 0 && -1 < 0 && XER<CA_XER..CA_XER> >= 0) then 
#line 2012 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 2012 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 2012 "nmp/ppc32.nmp"
     	else 
#line 2012 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 2012 "nmp/ppc32.nmp"
		endif; 
#line 2012 "nmp/ppc32.nmp"
	endif;
#line 2012 "nmp/ppc32.nmp"
; 
#line 2012 "nmp/ppc32.nmp"
	else 
#line 2012 "nmp/ppc32.nmp"
			if ra >= 0 then 
#line 2012 "nmp/ppc32.nmp"
		if -1 >= 0 then 
#line 2012 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 2012 "nmp/ppc32.nmp"
		else 
#line 2012 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> < 0 then 
#line 2012 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 2012 "nmp/ppc32.nmp"
			else 
#line 2012 "nmp/ppc32.nmp"
				XER <OV_XER..OV_XER> = 1; 
#line 2012 "nmp/ppc32.nmp"
	    	  	XER <SO_XER..SO_XER> = 1; 
#line 2012 "nmp/ppc32.nmp"
			endif; 
#line 2012 "nmp/ppc32.nmp"
		endif; 
#line 2012 "nmp/ppc32.nmp"
	else 
#line 2012 "nmp/ppc32.nmp"
		if ra == 0x80000000 then 
#line 2012 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 2012 "nmp/ppc32.nmp"
    	  	XER <SO_XER..SO_XER> = 1; 
#line 2012 "nmp/ppc32.nmp"
		else 
#line 2012 "nmp/ppc32.nmp"
			if -1 < 0 then 
#line 2012 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 2012 "nmp/ppc32.nmp"
			else 
#line 2012 "nmp/ppc32.nmp"
				if XER<CA_XER..CA_XER> < 0 then 
#line 2012 "nmp/ppc32.nmp"
					XER <OV_XER..OV_XER> = 1; 
#line 2012 "nmp/ppc32.nmp"
      				XER <SO_XER..SO_XER> = 1; 
#line 2012 "nmp/ppc32.nmp"
				else 
#line 2012 "nmp/ppc32.nmp"
		          	XER <OV_XER..OV_XER> = 0; 
#line 2012 "nmp/ppc32.nmp"
				endif; 
#line 2012 "nmp/ppc32.nmp"
			endif; 
#line 2012 "nmp/ppc32.nmp"
		endif; 
#line 2012 "nmp/ppc32.nmp"
	endif; 
#line 2012 "nmp/ppc32.nmp"
; 
#line 2012 "nmp/ppc32.nmp"
	endif; 
#line 2012 "nmp/ppc32.nmp"
;
#line 2012 "nmp/ppc32.nmp"
#line 2013 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

		}

op sub_me_overflow_cr_update ( rd : index, ra : REG_IND)
   syntax = format ( "subfmeo. r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010111010001", rd, ra.image )
   action = {

     	TMP_RES = ~ra + XER <CA_XER..CA_XER> + 0xffffffff;
			if (ra >= 0 && -1 < 0) then 
#line 2023 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 2023 "nmp/ppc32.nmp"
	else 
#line 2023 "nmp/ppc32.nmp"
		if (ra < 0 && -1 >= 0) then 
#line 2023 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 2023 "nmp/ppc32.nmp"
		else 
#line 2023 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 2023 "nmp/ppc32.nmp"
				if ra > -1 then 
#line 2023 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2023 "nmp/ppc32.nmp"
				else 
#line 2023 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2023 "nmp/ppc32.nmp"
				endif; 
#line 2023 "nmp/ppc32.nmp"
			else 
#line 2023 "nmp/ppc32.nmp"
				if ra >= -1 then 
#line 2023 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2023 "nmp/ppc32.nmp"
				else 
#line 2023 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2023 "nmp/ppc32.nmp"
				endif; 
#line 2023 "nmp/ppc32.nmp"
			endif; 
#line 2023 "nmp/ppc32.nmp"
		endif; 
#line 2023 "nmp/ppc32.nmp"
	endif;
#line 2023 "nmp/ppc32.nmp"
;
#line 2023 "nmp/ppc32.nmp"
#line 2024 "nmp/ppc32.nmp"
			if TMP_RES==0 then 
#line 2024 "nmp/ppc32.nmp"
			if (~ra >= 0 && -1 >= 0 && XER<CA_XER..CA_XER> < 0) then 
#line 2024 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2024 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 2024 "nmp/ppc32.nmp"
    else 
#line 2024 "nmp/ppc32.nmp"
		if (~ra < 0 && -1 < 0 && XER<CA_XER..CA_XER> >= 0) then 
#line 2024 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 2024 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 2024 "nmp/ppc32.nmp"
     	else 
#line 2024 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 2024 "nmp/ppc32.nmp"
		endif; 
#line 2024 "nmp/ppc32.nmp"
	endif;
#line 2024 "nmp/ppc32.nmp"
; 
#line 2024 "nmp/ppc32.nmp"
	else 
#line 2024 "nmp/ppc32.nmp"
			if ra >= 0 then 
#line 2024 "nmp/ppc32.nmp"
		if -1 >= 0 then 
#line 2024 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 2024 "nmp/ppc32.nmp"
		else 
#line 2024 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> < 0 then 
#line 2024 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 2024 "nmp/ppc32.nmp"
			else 
#line 2024 "nmp/ppc32.nmp"
				XER <OV_XER..OV_XER> = 1; 
#line 2024 "nmp/ppc32.nmp"
	    	  	XER <SO_XER..SO_XER> = 1; 
#line 2024 "nmp/ppc32.nmp"
			endif; 
#line 2024 "nmp/ppc32.nmp"
		endif; 
#line 2024 "nmp/ppc32.nmp"
	else 
#line 2024 "nmp/ppc32.nmp"
		if ra == 0x80000000 then 
#line 2024 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 2024 "nmp/ppc32.nmp"
    	  	XER <SO_XER..SO_XER> = 1; 
#line 2024 "nmp/ppc32.nmp"
		else 
#line 2024 "nmp/ppc32.nmp"
			if -1 < 0 then 
#line 2024 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 2024 "nmp/ppc32.nmp"
			else 
#line 2024 "nmp/ppc32.nmp"
				if XER<CA_XER..CA_XER> < 0 then 
#line 2024 "nmp/ppc32.nmp"
					XER <OV_XER..OV_XER> = 1; 
#line 2024 "nmp/ppc32.nmp"
      				XER <SO_XER..SO_XER> = 1; 
#line 2024 "nmp/ppc32.nmp"
				else 
#line 2024 "nmp/ppc32.nmp"
		          	XER <OV_XER..OV_XER> = 0; 
#line 2024 "nmp/ppc32.nmp"
				endif; 
#line 2024 "nmp/ppc32.nmp"
			endif; 
#line 2024 "nmp/ppc32.nmp"
		endif; 
#line 2024 "nmp/ppc32.nmp"
	endif; 
#line 2024 "nmp/ppc32.nmp"
; 
#line 2024 "nmp/ppc32.nmp"
	endif; 
#line 2024 "nmp/ppc32.nmp"
;
#line 2024 "nmp/ppc32.nmp"
#line 2025 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2027 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2027 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2027 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2027 "nmp/ppc32.nmp"
;
#line 2027 "nmp/ppc32.nmp"
#line 2028 "nmp/ppc32.nmp"
       	}

// Subtract zero extended Instructions

op sub_zero_extended =   sub_ze
                       | sub_ze_cr_update
                       | sub_ze_overflow
                       | sub_ze_overflow_cr_update

op sub_ze ( rd : index, ra : REG_IND)
   syntax = format ( "subfze r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000110010000", rd, ra.image )
   action = {

		TMP_RES = ~ra + XER <CA_XER..CA_XER>;
			if (ra >= 0 && 0 < 0) then 
#line 2043 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 2043 "nmp/ppc32.nmp"
	else 
#line 2043 "nmp/ppc32.nmp"
		if (ra < 0 && 0 >= 0) then 
#line 2043 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 2043 "nmp/ppc32.nmp"
		else 
#line 2043 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 2043 "nmp/ppc32.nmp"
				if ra > 0 then 
#line 2043 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2043 "nmp/ppc32.nmp"
				else 
#line 2043 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2043 "nmp/ppc32.nmp"
				endif; 
#line 2043 "nmp/ppc32.nmp"
			else 
#line 2043 "nmp/ppc32.nmp"
				if ra >= 0 then 
#line 2043 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2043 "nmp/ppc32.nmp"
				else 
#line 2043 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2043 "nmp/ppc32.nmp"
				endif; 
#line 2043 "nmp/ppc32.nmp"
			endif; 
#line 2043 "nmp/ppc32.nmp"
		endif; 
#line 2043 "nmp/ppc32.nmp"
	endif;
#line 2043 "nmp/ppc32.nmp"
;
#line 2043 "nmp/ppc32.nmp"
#line 2044 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;
		}

op sub_ze_cr_update ( rd : index, ra : REG_IND)
   syntax = format ( "subfze. r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000110010001", rd, ra.image )
   action = {

		TMP_RES = ~ra + XER <CA_XER..CA_XER>;
			if (ra >= 0 && 0 < 0) then 
#line 2053 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 2053 "nmp/ppc32.nmp"
	else 
#line 2053 "nmp/ppc32.nmp"
		if (ra < 0 && 0 >= 0) then 
#line 2053 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 2053 "nmp/ppc32.nmp"
		else 
#line 2053 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 2053 "nmp/ppc32.nmp"
				if ra > 0 then 
#line 2053 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2053 "nmp/ppc32.nmp"
				else 
#line 2053 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2053 "nmp/ppc32.nmp"
				endif; 
#line 2053 "nmp/ppc32.nmp"
			else 
#line 2053 "nmp/ppc32.nmp"
				if ra >= 0 then 
#line 2053 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2053 "nmp/ppc32.nmp"
				else 
#line 2053 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2053 "nmp/ppc32.nmp"
				endif; 
#line 2053 "nmp/ppc32.nmp"
			endif; 
#line 2053 "nmp/ppc32.nmp"
		endif; 
#line 2053 "nmp/ppc32.nmp"
	endif;
#line 2053 "nmp/ppc32.nmp"
;
#line 2053 "nmp/ppc32.nmp"
#line 2054 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2056 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2056 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2056 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2056 "nmp/ppc32.nmp"
;
#line 2056 "nmp/ppc32.nmp"
#line 2057 "nmp/ppc32.nmp"
       	}

op sub_ze_overflow ( rd : index, ra : REG_IND)
   syntax = format ( "subfzeo r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010110010000", rd, ra.image )
   action = {

		TMP_RES = ~ra + XER <CA_XER..CA_XER>;
			if (ra >= 0 && 0 < 0) then 
#line 2065 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 2065 "nmp/ppc32.nmp"
	else 
#line 2065 "nmp/ppc32.nmp"
		if (ra < 0 && 0 >= 0) then 
#line 2065 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 2065 "nmp/ppc32.nmp"
		else 
#line 2065 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 2065 "nmp/ppc32.nmp"
				if ra > 0 then 
#line 2065 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2065 "nmp/ppc32.nmp"
				else 
#line 2065 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2065 "nmp/ppc32.nmp"
				endif; 
#line 2065 "nmp/ppc32.nmp"
			else 
#line 2065 "nmp/ppc32.nmp"
				if ra >= 0 then 
#line 2065 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2065 "nmp/ppc32.nmp"
				else 
#line 2065 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2065 "nmp/ppc32.nmp"
				endif; 
#line 2065 "nmp/ppc32.nmp"
			endif; 
#line 2065 "nmp/ppc32.nmp"
		endif; 
#line 2065 "nmp/ppc32.nmp"
	endif;
#line 2065 "nmp/ppc32.nmp"
;
#line 2065 "nmp/ppc32.nmp"
#line 2066 "nmp/ppc32.nmp"
			if TMP_RES==0 then 
#line 2066 "nmp/ppc32.nmp"
			if (~ra >= 0 && 0 >= 0 && XER<CA_XER..CA_XER> < 0) then 
#line 2066 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2066 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 2066 "nmp/ppc32.nmp"
    else 
#line 2066 "nmp/ppc32.nmp"
		if (~ra < 0 && 0 < 0 && XER<CA_XER..CA_XER> >= 0) then 
#line 2066 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 2066 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 2066 "nmp/ppc32.nmp"
     	else 
#line 2066 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 2066 "nmp/ppc32.nmp"
		endif; 
#line 2066 "nmp/ppc32.nmp"
	endif;
#line 2066 "nmp/ppc32.nmp"
; 
#line 2066 "nmp/ppc32.nmp"
	else 
#line 2066 "nmp/ppc32.nmp"
			if ra >= 0 then 
#line 2066 "nmp/ppc32.nmp"
		if 0 >= 0 then 
#line 2066 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 2066 "nmp/ppc32.nmp"
		else 
#line 2066 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> < 0 then 
#line 2066 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 2066 "nmp/ppc32.nmp"
			else 
#line 2066 "nmp/ppc32.nmp"
				XER <OV_XER..OV_XER> = 1; 
#line 2066 "nmp/ppc32.nmp"
	    	  	XER <SO_XER..SO_XER> = 1; 
#line 2066 "nmp/ppc32.nmp"
			endif; 
#line 2066 "nmp/ppc32.nmp"
		endif; 
#line 2066 "nmp/ppc32.nmp"
	else 
#line 2066 "nmp/ppc32.nmp"
		if ra == 0x80000000 then 
#line 2066 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 2066 "nmp/ppc32.nmp"
    	  	XER <SO_XER..SO_XER> = 1; 
#line 2066 "nmp/ppc32.nmp"
		else 
#line 2066 "nmp/ppc32.nmp"
			if 0 < 0 then 
#line 2066 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 2066 "nmp/ppc32.nmp"
			else 
#line 2066 "nmp/ppc32.nmp"
				if XER<CA_XER..CA_XER> < 0 then 
#line 2066 "nmp/ppc32.nmp"
					XER <OV_XER..OV_XER> = 1; 
#line 2066 "nmp/ppc32.nmp"
      				XER <SO_XER..SO_XER> = 1; 
#line 2066 "nmp/ppc32.nmp"
				else 
#line 2066 "nmp/ppc32.nmp"
		          	XER <OV_XER..OV_XER> = 0; 
#line 2066 "nmp/ppc32.nmp"
				endif; 
#line 2066 "nmp/ppc32.nmp"
			endif; 
#line 2066 "nmp/ppc32.nmp"
		endif; 
#line 2066 "nmp/ppc32.nmp"
	endif; 
#line 2066 "nmp/ppc32.nmp"
; 
#line 2066 "nmp/ppc32.nmp"
	endif; 
#line 2066 "nmp/ppc32.nmp"
;
#line 2066 "nmp/ppc32.nmp"
#line 2067 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

		}

op sub_ze_overflow_cr_update ( rd : index, ra : REG_IND)
   syntax = format ( "subfzeo. r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010110010001", rd, ra.image )
   action = {
		TMP_RES = ~ra + XER <CA_XER..CA_XER>;
			if (ra >= 0 && 0 < 0) then 
#line 2076 "nmp/ppc32.nmp"
		XER <CA_XER..CA_XER> = 1; 
#line 2076 "nmp/ppc32.nmp"
	else 
#line 2076 "nmp/ppc32.nmp"
		if (ra < 0 && 0 >= 0) then 
#line 2076 "nmp/ppc32.nmp"
			XER <CA_XER..CA_XER> = 0; 
#line 2076 "nmp/ppc32.nmp"
		else 
#line 2076 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> == 1 then 
#line 2076 "nmp/ppc32.nmp"
				if ra > 0 then 
#line 2076 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2076 "nmp/ppc32.nmp"
				else 
#line 2076 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2076 "nmp/ppc32.nmp"
				endif; 
#line 2076 "nmp/ppc32.nmp"
			else 
#line 2076 "nmp/ppc32.nmp"
				if ra >= 0 then 
#line 2076 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 0; 
#line 2076 "nmp/ppc32.nmp"
				else 
#line 2076 "nmp/ppc32.nmp"
					XER <CA_XER..CA_XER> = 1; 
#line 2076 "nmp/ppc32.nmp"
				endif; 
#line 2076 "nmp/ppc32.nmp"
			endif; 
#line 2076 "nmp/ppc32.nmp"
		endif; 
#line 2076 "nmp/ppc32.nmp"
	endif;
#line 2076 "nmp/ppc32.nmp"
;
#line 2076 "nmp/ppc32.nmp"
#line 2077 "nmp/ppc32.nmp"
			if TMP_RES==0 then 
#line 2077 "nmp/ppc32.nmp"
			if (~ra >= 0 && 0 >= 0 && XER<CA_XER..CA_XER> < 0) then 
#line 2077 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2077 "nmp/ppc32.nmp"
      	XER <SO_XER..SO_XER> = 1; 
#line 2077 "nmp/ppc32.nmp"
    else 
#line 2077 "nmp/ppc32.nmp"
		if (~ra < 0 && 0 < 0 && XER<CA_XER..CA_XER> >= 0) then 
#line 2077 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 2077 "nmp/ppc32.nmp"
          	XER <SO_XER..SO_XER> = 1; 
#line 2077 "nmp/ppc32.nmp"
     	else 
#line 2077 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 2077 "nmp/ppc32.nmp"
		endif; 
#line 2077 "nmp/ppc32.nmp"
	endif;
#line 2077 "nmp/ppc32.nmp"
; 
#line 2077 "nmp/ppc32.nmp"
	else 
#line 2077 "nmp/ppc32.nmp"
			if ra >= 0 then 
#line 2077 "nmp/ppc32.nmp"
		if 0 >= 0 then 
#line 2077 "nmp/ppc32.nmp"
          	XER <OV_XER..OV_XER> = 0; 
#line 2077 "nmp/ppc32.nmp"
		else 
#line 2077 "nmp/ppc32.nmp"
			if XER<CA_XER..CA_XER> < 0 then 
#line 2077 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 2077 "nmp/ppc32.nmp"
			else 
#line 2077 "nmp/ppc32.nmp"
				XER <OV_XER..OV_XER> = 1; 
#line 2077 "nmp/ppc32.nmp"
	    	  	XER <SO_XER..SO_XER> = 1; 
#line 2077 "nmp/ppc32.nmp"
			endif; 
#line 2077 "nmp/ppc32.nmp"
		endif; 
#line 2077 "nmp/ppc32.nmp"
	else 
#line 2077 "nmp/ppc32.nmp"
		if ra == 0x80000000 then 
#line 2077 "nmp/ppc32.nmp"
			XER <OV_XER..OV_XER> = 1; 
#line 2077 "nmp/ppc32.nmp"
    	  	XER <SO_XER..SO_XER> = 1; 
#line 2077 "nmp/ppc32.nmp"
		else 
#line 2077 "nmp/ppc32.nmp"
			if 0 < 0 then 
#line 2077 "nmp/ppc32.nmp"
	          	XER <OV_XER..OV_XER> = 0; 
#line 2077 "nmp/ppc32.nmp"
			else 
#line 2077 "nmp/ppc32.nmp"
				if XER<CA_XER..CA_XER> < 0 then 
#line 2077 "nmp/ppc32.nmp"
					XER <OV_XER..OV_XER> = 1; 
#line 2077 "nmp/ppc32.nmp"
      				XER <SO_XER..SO_XER> = 1; 
#line 2077 "nmp/ppc32.nmp"
				else 
#line 2077 "nmp/ppc32.nmp"
		          	XER <OV_XER..OV_XER> = 0; 
#line 2077 "nmp/ppc32.nmp"
				endif; 
#line 2077 "nmp/ppc32.nmp"
			endif; 
#line 2077 "nmp/ppc32.nmp"
		endif; 
#line 2077 "nmp/ppc32.nmp"
	endif; 
#line 2077 "nmp/ppc32.nmp"
; 
#line 2077 "nmp/ppc32.nmp"
	endif; 
#line 2077 "nmp/ppc32.nmp"
;
#line 2077 "nmp/ppc32.nmp"
#line 2078 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2080 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2080 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2080 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2080 "nmp/ppc32.nmp"
;
#line 2080 "nmp/ppc32.nmp"
#line 2081 "nmp/ppc32.nmp"
  		}

// Integer Multiply Instructions
op int_multiply ( x : int_multiply_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = MULDIV | IS_MUL

op int_multiply_action =   mult_low
                  | mult_low_imm
                  | mult_high
                  | mult_high_unsig

// Multiply Low Instructions

op mult_low =   mult_lw
              | mult_lw_cr_update
              | mult_lw_overflow
              | mult_lw_overflow_cr_upd

op mult_lw ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "mullw r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00111010110", rd, ra.image, rb.image )
   action = {

		GPR [ rd ] = ra * rb;

       	}

op mult_lw_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "mullw. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00111010111", rd, ra.image, rb.image )
   action = {

		 TMP_RES = ra * rb;
		 GPR [ rd ] = TMP_RES ;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2118 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2118 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2118 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2118 "nmp/ppc32.nmp"
;
#line 2118 "nmp/ppc32.nmp"
#line 2119 "nmp/ppc32.nmp"
        }
 
op mult_lw_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "mullwo r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10111010110", rd, ra.image, rb.image )
   action = {

     	TMP_RES = ra * rb;
			TMP_M_OP1_H0 = ra; 
#line 2127 "nmp/ppc32.nmp"
	TMP_M_OP2_H0 =  rb; 
#line 2127 "nmp/ppc32.nmp"
	TMP_M_RES_H0 = TMP_RES ; 
#line 2127 "nmp/ppc32.nmp"
	
#line 2127 "nmp/ppc32.nmp"
	if ra < 0 then 
#line 2127 "nmp/ppc32.nmp"
		TMP_M_OP1_H1 = 0xffffffff; 
#line 2127 "nmp/ppc32.nmp"
	else 
#line 2127 "nmp/ppc32.nmp"
		TMP_M_OP1_H1 = 0; 
#line 2127 "nmp/ppc32.nmp"
	endif; 
#line 2127 "nmp/ppc32.nmp"
	if  rb < 0 then 
#line 2127 "nmp/ppc32.nmp"
		TMP_M_OP2_H1 = 0xffffffff; 
#line 2127 "nmp/ppc32.nmp"
	else 
#line 2127 "nmp/ppc32.nmp"
		TMP_M_OP2_H1 = 0; 
#line 2127 "nmp/ppc32.nmp"
	endif; 
#line 2127 "nmp/ppc32.nmp"
	if TMP_RES  < 0 then 
#line 2127 "nmp/ppc32.nmp"
		TMP_M_RES_H1 = 0xffffffff; 
#line 2127 "nmp/ppc32.nmp"
	else 
#line 2127 "nmp/ppc32.nmp"
		TMP_M_RES_H1 = 0; 
#line 2127 "nmp/ppc32.nmp"
	endif; 
#line 2127 "nmp/ppc32.nmp"
	
#line 2127 "nmp/ppc32.nmp"
	if TMP_M_OP1*TMP_M_OP2 != TMP_M_RES then 
#line 2127 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2127 "nmp/ppc32.nmp"
    	XER <SO_XER..SO_XER> = 1; 
#line 2127 "nmp/ppc32.nmp"
	else 
#line 2127 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 0; 
#line 2127 "nmp/ppc32.nmp"
	endif; 
#line 2127 "nmp/ppc32.nmp"
;
#line 2127 "nmp/ppc32.nmp"
#line 2128 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

		}

op mult_lw_overflow_cr_upd ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "mullwo. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10111010111", rd, ra.image, rb.image )
   action = {

     	TMP_RES = ra * rb;
			TMP_M_OP1_H0 = ra; 
#line 2138 "nmp/ppc32.nmp"
	TMP_M_OP2_H0 =  rb; 
#line 2138 "nmp/ppc32.nmp"
	TMP_M_RES_H0 = TMP_RES ; 
#line 2138 "nmp/ppc32.nmp"
	
#line 2138 "nmp/ppc32.nmp"
	if ra < 0 then 
#line 2138 "nmp/ppc32.nmp"
		TMP_M_OP1_H1 = 0xffffffff; 
#line 2138 "nmp/ppc32.nmp"
	else 
#line 2138 "nmp/ppc32.nmp"
		TMP_M_OP1_H1 = 0; 
#line 2138 "nmp/ppc32.nmp"
	endif; 
#line 2138 "nmp/ppc32.nmp"
	if  rb < 0 then 
#line 2138 "nmp/ppc32.nmp"
		TMP_M_OP2_H1 = 0xffffffff; 
#line 2138 "nmp/ppc32.nmp"
	else 
#line 2138 "nmp/ppc32.nmp"
		TMP_M_OP2_H1 = 0; 
#line 2138 "nmp/ppc32.nmp"
	endif; 
#line 2138 "nmp/ppc32.nmp"
	if TMP_RES  < 0 then 
#line 2138 "nmp/ppc32.nmp"
		TMP_M_RES_H1 = 0xffffffff; 
#line 2138 "nmp/ppc32.nmp"
	else 
#line 2138 "nmp/ppc32.nmp"
		TMP_M_RES_H1 = 0; 
#line 2138 "nmp/ppc32.nmp"
	endif; 
#line 2138 "nmp/ppc32.nmp"
	
#line 2138 "nmp/ppc32.nmp"
	if TMP_M_OP1*TMP_M_OP2 != TMP_M_RES then 
#line 2138 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2138 "nmp/ppc32.nmp"
    	XER <SO_XER..SO_XER> = 1; 
#line 2138 "nmp/ppc32.nmp"
	else 
#line 2138 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 0; 
#line 2138 "nmp/ppc32.nmp"
	endif; 
#line 2138 "nmp/ppc32.nmp"
;
#line 2138 "nmp/ppc32.nmp"
#line 2139 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2141 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2141 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2141 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2141 "nmp/ppc32.nmp"
;
#line 2141 "nmp/ppc32.nmp"
#line 2142 "nmp/ppc32.nmp"
        }


// Multiply Low Immediate

op mult_low_imm ( rd : index, ra : REG_IND, imm : IMM16 )
   syntax = format ( "mulli r%d,%s,%s", rd, ra.syntax, imm.syntax )
   image  = format ( "000111%5b%s%s", rd, ra.image, imm.image )
   action = {

   		GPR [ rd ] = ra * imm;

      	}

// Multiply High Word

op mult_high =   mult_hi
               | mult_hi_cr_update

op mult_hi ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "mulhw r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00010010110", rd, ra.image, rb.image )
   action = {

   		TMP_SDWORD = ra;
		TMP_SDWORD = TMP_SDWORD * rb;
        GPR [ rd ] = TMP_SDWORD < 63..32 >;

        }

op mult_hi_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "mulhw. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00010010111", rd, ra.image, rb.image )
   action = {

		TMP_SDWORD = ra;
		TMP_SDWORD = TMP_SDWORD * rb;
		GPR [ rd ] = TMP_SDWORD < 63..32 >;

			CR[7]<LT..LT> = ((TMP_SDWORD < 63..32 >)<0); 
#line 2181 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_SDWORD < 63..32 >)>0); 
#line 2181 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_SDWORD < 63..32 >)==0); 
#line 2181 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2181 "nmp/ppc32.nmp"
;
#line 2181 "nmp/ppc32.nmp"
#line 2182 "nmp/ppc32.nmp"
		}

// Multiply High word unsigned

op mult_high_unsig =   mult_hi_us
                     | mult_hi_us_cr_update

op mult_hi_us ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "mulhwu r%d,%s,%s", rd , ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010110", rd, ra.image, rb.image)
   action = {
		TMP_DWORD = coerce ( card ( 32 ) , ra );
		TMP_DWORD = TMP_DWORD * coerce ( card ( 32 ) , rb );
		GPR [ rd ] = TMP_DWORD < 63..32 >;

        }

op mult_hi_us_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "mulhwu. r%d,%s,%s", rd , ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010111", rd, ra.image, rb.image)
   action = {

        TMP_DWORD = coerce ( card ( 32 ) , ra );
	TMP_DWORD = TMP_DWORD * coerce ( card ( 32 ) , rb );
        GPR [ rd ] = TMP_DWORD < 63..32 >;

			CR[7]<LT..LT> = ((TMP_DWORD < 63..32 >)<0); 
#line 2208 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_DWORD < 63..32 >)>0); 
#line 2208 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_DWORD < 63..32 >)==0); 
#line 2208 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2208 "nmp/ppc32.nmp"
;
#line 2208 "nmp/ppc32.nmp"
#line 2209 "nmp/ppc32.nmp"
		}

// Integer Divide Instructions
op int_divide ( x : int_divide_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = MULDIV | IS_DIV

op int_divide_action =   div_word
                | div_word_unsig

op div_word =   divw
              | divw_cr_update
              | divw_overflow
              | divw_overflow_cr_upd

op divw ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "divw r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01111010110", rd, ra.image, rb.image )
   action = {

		if ( rb == 0 || ( ra == 0x80000000 & rb == -1 ) ) then
			GPR [ rd ] = 0;
		else
			GPR [ rd ] = ra / rb;
		endif;
        }

op divw_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "divw. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01111010111", rd, ra.image, rb.image )
   action = {

		if ( rb == 0 || ( ra == 0x80000000 & rb == -1 ) ) then
			GPR [ rd ] = 0;
		else
	         TMP_RES = ra / rb;
		 GPR [ rd ] = TMP_RES;
		 	CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2248 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2248 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2248 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2248 "nmp/ppc32.nmp"
;
#line 2248 "nmp/ppc32.nmp"
#line 2249 "nmp/ppc32.nmp"
		endif;

		}

op divw_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "divwo r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11111010110", rd, ra.image, rb.image )
   action = {

		if ( rb == 0 || ( ra == 0x80000000 & rb == -1 ) ) then
			TMP_RES = 0;

		else
	        TMP_RES = ra / rb;
		endif;

			if ((ra == 0x80000000 && rb == -1) || (rb == 0)) then 
#line 2265 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2265 "nmp/ppc32.nmp"
		XER <SO_XER..SO_XER> = 1; 
#line 2265 "nmp/ppc32.nmp"
	else 
#line 2265 "nmp/ppc32.nmp"
		XER<OV_XER..OV_XER> = 0; 
#line 2265 "nmp/ppc32.nmp"
	endif; 
#line 2265 "nmp/ppc32.nmp"
;
#line 2265 "nmp/ppc32.nmp"
#line 2266 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

		}

op divw_overflow_cr_upd ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "divwo. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11111010111", rd, ra.image, rb.image )
   action = {

		if ( rb == 0 || ( ra == 0x80000000 & rb == -1 ) ) then
			TMP_RES = 0;
				if ((ra == 0x80000000 && rb == -1) || (rb == 0)) then 
#line 2277 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2277 "nmp/ppc32.nmp"
		XER <SO_XER..SO_XER> = 1; 
#line 2277 "nmp/ppc32.nmp"
	else 
#line 2277 "nmp/ppc32.nmp"
		XER<OV_XER..OV_XER> = 0; 
#line 2277 "nmp/ppc32.nmp"
	endif; 
#line 2277 "nmp/ppc32.nmp"
;
#line 2277 "nmp/ppc32.nmp"
#line 2278 "nmp/ppc32.nmp"
			GPR[rd] = TMP_RES;
			CR[7]<SO..SO> = XER<SO_XER..SO_XER>;
		else
	        TMP_RES = ra / rb;
				if ((ra == 0x80000000 && rb == -1) || (rb == 0)) then 
#line 2282 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2282 "nmp/ppc32.nmp"
		XER <SO_XER..SO_XER> = 1; 
#line 2282 "nmp/ppc32.nmp"
	else 
#line 2282 "nmp/ppc32.nmp"
		XER<OV_XER..OV_XER> = 0; 
#line 2282 "nmp/ppc32.nmp"
	endif; 
#line 2282 "nmp/ppc32.nmp"
;
#line 2282 "nmp/ppc32.nmp"
#line 2283 "nmp/ppc32.nmp"
			GPR[rd] = TMP_RES;
				CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2284 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2284 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2284 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2284 "nmp/ppc32.nmp"
;
#line 2284 "nmp/ppc32.nmp"
#line 2285 "nmp/ppc32.nmp"
		endif;
		}

// Divide word unsigned

op div_word_unsig =   divwus
                    | divwus_cr_update
                    | divwus_overflow
                    | divwus_overflow_cr_upd


op divwus ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "divwu r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01110010110", rd, ra.image, rb.image )
   action = {

		if rb == 0 then
			GPR [ rd ] = 0;
		else
			GPR [ rd ] = coerce ( card ( 32 ) , ra ) / coerce ( card ( 32 ) , rb );
		endif;
		}

op divwus_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "divwu. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01110010111", rd, ra.image, rb.image )
   action = {

		if rb == 0 then
			GPR [ rd ] = 0;
		else
			TMP_RES = coerce ( card ( 32 ) , ra ) / coerce ( card ( 32 ) , rb );
			GPR [ rd ] = TMP_RES;
				CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2318 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2318 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2318 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2318 "nmp/ppc32.nmp"
;
#line 2318 "nmp/ppc32.nmp"
#line 2319 "nmp/ppc32.nmp"
		endif;

		}

op divwus_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "divwuo r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11110010110", rd, ra.image, rb.image )
   action = {

		if rb == 0 then
			TMP_RES = 0;
		else
			TMP_RES = coerce ( card ( 32 ) , ra ) / coerce ( card ( 32 ) , rb );
		endif;

			if ((coerce ( card ( 32 ) , ra ) == 0x80000000 && coerce ( card ( 32 ) , rb ) == -1) || (coerce ( card ( 32 ) , rb ) == 0)) then 
#line 2335 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2335 "nmp/ppc32.nmp"
		XER <SO_XER..SO_XER> = 1; 
#line 2335 "nmp/ppc32.nmp"
	else 
#line 2335 "nmp/ppc32.nmp"
		XER<OV_XER..OV_XER> = 0; 
#line 2335 "nmp/ppc32.nmp"
	endif; 
#line 2335 "nmp/ppc32.nmp"
;
#line 2335 "nmp/ppc32.nmp"
#line 2336 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

		}
 
op divwus_overflow_cr_upd ( rd : index, ra : REG_IND, rb : REG_IND )
   syntax = format ( "divwuo. r%d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11110010111", rd, ra.image, rb.image )
   action = {

		if rb == 0 then
			TMP_RES = 0;
				if ((coerce ( card ( 32 ) , ra ) == 0x80000000 && coerce ( card ( 32 ) , rb ) == -1) || (coerce ( card ( 32 ) , rb ) == 0)) then 
#line 2348 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2348 "nmp/ppc32.nmp"
		XER <SO_XER..SO_XER> = 1; 
#line 2348 "nmp/ppc32.nmp"
	else 
#line 2348 "nmp/ppc32.nmp"
		XER<OV_XER..OV_XER> = 0; 
#line 2348 "nmp/ppc32.nmp"
	endif; 
#line 2348 "nmp/ppc32.nmp"
;
#line 2348 "nmp/ppc32.nmp"
#line 2349 "nmp/ppc32.nmp"
			GPR[rd] = TMP_RES;
			CR[7]<SO..SO>=XER<SO_XER..SO_XER>;
		else
			TMP_RES = coerce ( card ( 32 ) , ra ) / coerce ( card ( 32 ) , rb );
				if ((coerce ( card ( 32 ) , ra ) == 0x80000000 && coerce ( card ( 32 ) , rb ) == -1) || (coerce ( card ( 32 ) , rb ) == 0)) then 
#line 2354 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2354 "nmp/ppc32.nmp"
		XER <SO_XER..SO_XER> = 1; 
#line 2354 "nmp/ppc32.nmp"
	else 
#line 2354 "nmp/ppc32.nmp"
		XER<OV_XER..OV_XER> = 0; 
#line 2354 "nmp/ppc32.nmp"
	endif; 
#line 2354 "nmp/ppc32.nmp"
;
#line 2354 "nmp/ppc32.nmp"
#line 2355 "nmp/ppc32.nmp"
			GPR[rd] = TMP_RES;
				CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2356 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2356 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2356 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2356 "nmp/ppc32.nmp"
;
#line 2356 "nmp/ppc32.nmp"
#line 2357 "nmp/ppc32.nmp"
		endif;
		}

// Integer Negate Instruction
op int_negate ( x : int_negate_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = ARITH

op int_negate_action =   neg
                | neg_cr_update
                | neg_overflow
                | neg_overflow_cr_upd

op neg ( rd : index, ra : REG_IND)
   syntax = format ( "neg r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000011010000", rd, ra.image )
   action = {

		GPR [ rd ] = ~ra + 1;

        }

op neg_cr_update ( rd : index, ra : REG_IND)
   syntax = format ( "neg. r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000011010001", rd, ra.image )
   action = {

		TMP_RES = ~ra + 1;
		GPR [ rd ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2388 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2388 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2388 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2388 "nmp/ppc32.nmp"
;
#line 2388 "nmp/ppc32.nmp"
#line 2389 "nmp/ppc32.nmp"
        }

op neg_overflow ( rd : index, ra : REG_IND)
   syntax = format ( "nego r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010011010000", rd, ra.image )
   action = {

		TMP_RES = ~ra + 1;
			if ra == 0x80000000 then 
#line 2397 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2397 "nmp/ppc32.nmp"
		XER <SO_XER..SO_XER> = 1; 
#line 2397 "nmp/ppc32.nmp"
	else 
#line 2397 "nmp/ppc32.nmp"
		XER<OV_XER..OV_XER> = 0; 
#line 2397 "nmp/ppc32.nmp"
	endif; 
#line 2397 "nmp/ppc32.nmp"
;
#line 2397 "nmp/ppc32.nmp"
#line 2398 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

        }

op neg_overflow_cr_upd ( rd : index, ra : REG_IND)
   syntax = format ( "nego. r%d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010011010001", rd, ra.image )
   action = {

		TMP_RES = ~ra + 1;
			if ra == 0x80000000 then 
#line 2408 "nmp/ppc32.nmp"
		XER <OV_XER..OV_XER> = 1; 
#line 2408 "nmp/ppc32.nmp"
		XER <SO_XER..SO_XER> = 1; 
#line 2408 "nmp/ppc32.nmp"
	else 
#line 2408 "nmp/ppc32.nmp"
		XER<OV_XER..OV_XER> = 0; 
#line 2408 "nmp/ppc32.nmp"
	endif; 
#line 2408 "nmp/ppc32.nmp"
;
#line 2408 "nmp/ppc32.nmp"
#line 2409 "nmp/ppc32.nmp"
		GPR[rd] = TMP_RES;

			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2411 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2411 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2411 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2411 "nmp/ppc32.nmp"
;
#line 2411 "nmp/ppc32.nmp"
#line 2412 "nmp/ppc32.nmp"
        }

// Integer Compare Instructions

op int_compare ( x : int_compare_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = INTCMP

op int_compare_action  =   cmp_imm
                         | cmp
                         | cmp_log_imm
                         | cmp_log

op cmp_imm ( crfd : card ( 3 ), l : bit, ra : REG_IND, imm : IMM16 )
   syntax = format ( "cmpi %d,%d,%s,%s", crfd, l, ra.syntax, imm.syntax )
   image  = format ( "001011%3b0%1b%s%s", crfd, l, ra.image, imm.image )
   action = {

		TMP_BYTE = 0;
		if ra < imm then
        	TMP_BYTE = 8;
        else
        	if ra > imm then
        		TMP_BYTE = 4;
        	else
        		TMP_BYTE = 2;
        	endif;
        endif;

        //TMP_BYTE = TMP_BYTE << 1;

        if XER <SO_XER..SO_XER> then
        	TMP_BYTE = TMP_BYTE | 0x01;
        endif;

        CR[(7-crfd)] < LT..SO > = TMP_BYTE & 0x0f;

        }

op cmp ( crfd : card ( 3 ), l : bit, ra : REG_IND, rb : REG_IND )
   syntax = format ( "cmp %d,%d,%s,%s", crfd, l, ra.syntax, rb.syntax )
   image  = format ( "011111%3b0%1b%s%s00000000000", crfd, l, ra.image, rb.image)
   action = {

        if ra < rb then
        	TMP_BYTE = 0b100;
        else
        	if ra > rb then
        		TMP_BYTE = 0b010;
        	else
        		TMP_BYTE = 0b001;
        	endif;
        endif;

        TMP_BYTE = TMP_BYTE << 1;

        if XER < SO_XER..SO_XER > then
        	TMP_BYTE = TMP_BYTE | 0x01;
        endif;

        CR[(7-crfd)] < LT..SO > = TMP_BYTE & 0x0f;

        }


op cmp_log_imm ( crfd : card ( 3 ), l : bit, ra : REG_IND, imm : UIMM16 )
   syntax = format ( "cmpli %d,%d,%s,%s", crfd, l, ra.syntax, imm.syntax )
   image  = format ( "001010%3b0%1b%s%s", crfd, l, ra.image, imm.image )
   action = {

       	TMP_WORD = imm;
    	if coerce ( card ( 32 ) , ra ) < ( TMP_WORD ) then
        	TMP_BYTE = 0b100;
        else
        	if coerce ( card ( 32 ) , ra ) > ( TMP_WORD ) then
        		TMP_BYTE = 0b010;
        	else
        		TMP_BYTE = 0b001;
        	endif;
        endif;

        TMP_BYTE = TMP_BYTE << 1;

        if XER < SO_XER..SO_XER > then
        	TMP_BYTE = TMP_BYTE | 0x01;
        endif;

        CR[(7-crfd)] < LT..SO > = TMP_BYTE & 0x0f;
        //CR < (31-(4*crfd)-3)..(31-(4*crfd)) > = TMP_BYTE & 0x0f;

        }

op cmp_log ( crfd : card ( 3 ), l : bit, ra : REG_IND, rb : REG_IND )
   syntax = format ( "cmpl %d,%d,%s,%s", crfd, l, ra.syntax, rb.syntax )
   image  = format ( "011111%3b0%1b%s%s00001000000", crfd, l, ra.image, rb.image)
   action = {

		if coerce ( card ( 32 ) , ra ) < coerce ( card ( 32 ) , rb ) then
			TMP_BYTE = 0b100;
		else
			if coerce ( card ( 32 ) , ra ) > coerce ( card ( 32 ) , rb ) then
				TMP_BYTE = 0b010;
			else
				TMP_BYTE = 0b001;
			endif;
		endif;

		TMP_BYTE = TMP_BYTE << 1;

		if XER < SO_XER..SO_XER > then
			TMP_BYTE = TMP_BYTE | 0x01;
		endif;

		//CR < (31-(4*crfd)-3)..(31-(4*crfd)) > = TMP_BYTE & 0x0f;
		CR[(7-crfd)] < LT..SO > = TMP_BYTE & 0x0f;

		}

// Integer Logical Instructions
op int_logical ( x : int_logical_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = LOGIC

op int_logical_action  =   or_instr
                 | and_instr
                 | xor_instr
                 | nor_instr
                 | nand_instr
                 | equivalent_instr
                 | extended_sign_instr
                 | count_lead_zeros_instr

// OR Instructions

op or_instr =   simple_or
              | or_imm
              | or_imm_shift
              | or_comp

op simple_or =  or
              | or_cr_update

op or ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "or r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01101111000", rs.image, ra, rb.image )
   action = {

		GPR [ ra ] = rs | rb;

		}

op or_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "or. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01101111001", rs.image, ra, rb.image )
   action = {

		TMP_RES = rs | rb;
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2574 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2574 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2574 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2574 "nmp/ppc32.nmp"
;
#line 2574 "nmp/ppc32.nmp"
#line 2575 "nmp/ppc32.nmp"
		}

op or_imm ( rs : REG_IND, ra : index, imm : UIMM16 )
   syntax = format ( "ori r%d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011000%s%5b%s", rs.image, ra, imm.image )
   action = {

		TMP_WORD_A1 = 0;
		TMP_WORD_A0 = imm;
		//TMP_WORD = imm & 0b00000000000000001111111111111111;
		GPR [ ra ] = rs | TMP_WORD;

		}

op or_imm_shift ( rs : REG_IND, ra : index, imm : UIMM16 )
   syntax = format ( "oris r%d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011001%s%5b%s", rs.image, ra, imm.image )
   action = {

		TMP_WORD_A1 = imm;
		TMP_WORD_A0 = 0;
		GPR [ ra ] = rs | TMP_WORD;

		}

op or_comp =   orc
             | orc_cr_update

op orc ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "orc r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01100111000", rs.image, ra, rb.image )
   action = {

		GPR [ ra ] = rs | ( ~rb );

        }

op orc_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "orc. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01100111001", rs.image, ra, rb.image )
   action = {

		TMP_RES = rs | ( ~rb );
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2619 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2619 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2619 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2619 "nmp/ppc32.nmp"
;
#line 2619 "nmp/ppc32.nmp"
#line 2620 "nmp/ppc32.nmp"
		}

// AND Instructions

op and_instr =   simple_and
               | and_imm
               | and_imm_shift
               | and_comp

op simple_and =   and
                | and_cr_update

op and ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "and r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00000111000", rs.image, ra, rb.image )
   action = {

		GPR [ ra ] = rs & rb;

		}

op and_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "and. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00000111001", rs.image, ra, rb.image )
   action = {

		TMP_RES = rs & rb;
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2648 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2648 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2648 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2648 "nmp/ppc32.nmp"
;
#line 2648 "nmp/ppc32.nmp"
#line 2649 "nmp/ppc32.nmp"

		}

op and_imm ( rs : REG_IND, ra : index, imm : UIMM16 )
   syntax = format ( "andi. r%d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011100%s%5b%s", rs.image, ra, imm.image )
   action = {

		TMP_WORD_A1 = 0;
		TMP_WORD_A0 = imm;
		GPR [ ra ] = rs & TMP_WORD;

			CR[7]<LT..LT> = ((rs & TMP_WORD)<0); 
#line 2661 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((rs & TMP_WORD)>0); 
#line 2661 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((rs & TMP_WORD)==0); 
#line 2661 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2661 "nmp/ppc32.nmp"
;
#line 2661 "nmp/ppc32.nmp"
#line 2662 "nmp/ppc32.nmp"
		}

op and_imm_shift ( rs : REG_IND, ra : index, imm : UIMM16 )
   syntax = format ( "andis. r%d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011101%s%5b%s", rs.image, ra, imm.image )
   action = {

		TMP_WORD_A1 = imm;
		TMP_WORD_A0 = 0;
		GPR [ ra ] = rs & TMP_WORD;

			CR[7]<LT..LT> = ((rs & TMP_WORD)<0); 
#line 2673 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((rs & TMP_WORD)>0); 
#line 2673 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((rs & TMP_WORD)==0); 
#line 2673 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2673 "nmp/ppc32.nmp"
;
#line 2673 "nmp/ppc32.nmp"
#line 2674 "nmp/ppc32.nmp"
		}

op and_comp =   andc
              | andc_cr_update

op andc ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "andc r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00001111000", rs.image, ra, rb.image )
   action = {

		GPR [ ra ] = rs & ( ~rb );

		}

op andc_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "andc. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00001111001", rs.image, ra, rb.image )
   action = {

		TMP_RES = rs & ( ~rb );
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2695 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2695 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2695 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2695 "nmp/ppc32.nmp"
;
#line 2695 "nmp/ppc32.nmp"
#line 2696 "nmp/ppc32.nmp"

		}

// XOR Instructions

op xor_instr =   simple_xor
               | xor_imm
               | xor_imm_shift

op simple_xor =   xor
                | xor_cr_update

op xor ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "xor r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01001111000", rs.image, ra, rb.image )
   action = {

		GPR [ ra ] = rs ^ rb;

		}

op xor_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "xor. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01001111001", rs.image, ra, rb.image )
   action = {

		TMP_RES = rs ^ rb;
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2724 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2724 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2724 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2724 "nmp/ppc32.nmp"
;
#line 2724 "nmp/ppc32.nmp"
#line 2725 "nmp/ppc32.nmp"

		}

op xor_imm ( rs : REG_IND, ra : index, imm : UIMM16 )
   syntax = format ( "xori r%d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011010%s%5b%s", rs.image, ra, imm.image )
   action = {

		TMP_WORD_A1 = 0;
		TMP_WORD_A0 = imm;

		GPR [ ra ] = rs ^ TMP_WORD;

		}

op xor_imm_shift ( rs : REG_IND, ra : index, imm : UIMM16 )
   syntax = format ( "xoris r%d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011011%s%5b%s", rs.image, ra, imm.image )
   action = {

		TMP_WORD_A1 = imm;
		TMP_WORD_A0 = 0;
		GPR [ ra ] = rs ^ TMP_WORD;

		}

// NOR Instructions

op nor_instr =   nor
               | nor_cr_update

op nor ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "nor r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00011111000", rs.image, ra, rb.image )
   action = {

		GPR [ ra ] = ~(  rs | rb );

		}

op nor_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "nor. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00011111001", rs.image, ra, rb.image )
   action = {

		TMP_RES = ~( rs | rb );
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2772 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2772 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2772 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2772 "nmp/ppc32.nmp"
;
#line 2772 "nmp/ppc32.nmp"
#line 2773 "nmp/ppc32.nmp"
		}

// NAND Instructions

op nand_instr =   nand
                | nand_cr_update

op nand ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "nand r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01110111000", rs.image, ra, rb.image )
   action = {

		GPR [ ra ] = ~( rs & rb );

		}

op nand_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "nand. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01110111001", rs.image, ra, rb.image )
   action = {

		TMP_RES = ~( rs & rb );
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2796 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2796 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2796 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2796 "nmp/ppc32.nmp"
;
#line 2796 "nmp/ppc32.nmp"
#line 2797 "nmp/ppc32.nmp"

		}

// Equivalent Instructions

op equivalent_instr =   eqv
                      | eqv_cr_update


op eqv ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "eqv r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01000111000", rs.image, ra, rb.image )
   action = {

		GPR [ ra ] = ~( rs ^ rb );

		}

op eqv_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "eqv. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01000111001", rs.image, ra, rb.image )
   action = {

		TMP_RES = ~( rs ^ rb );

		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2823 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2823 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2823 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2823 "nmp/ppc32.nmp"
;
#line 2823 "nmp/ppc32.nmp"
#line 2824 "nmp/ppc32.nmp"

		}

// Extended sign Instructions

op extended_sign_instr =   ext_sign_byte
                         | ext_sign_hword

op ext_sign_byte =   extsb
                   | extsb_cr_update

op extsb ( rs : index, ra : index )
   syntax = format ( "extsb r%d,r%d", ra, rs )
   image  = format ( "011111%5b%5b0000011101110100", rs, ra )
   action = {

		//TMP_SBYTE = GPR [ rs ] < 0..7 >;
		TMP_SBYTE = GPR [ rs ] < 7..0 >;
        GPR [ ra ] = TMP_SBYTE;   // sign extension

        }

op extsb_cr_update ( rs : index, ra : index )
   syntax = format ( "extsb. r%d,r%d", ra, rs )
   image  = format ( "011111%5b%5b0000011101110101", rs, ra )
   action = {

		//TMP_SBYTE = GPR [ rs ] < 0..7 >;
		TMP_SBYTE = GPR [ rs ] < 7..0 >;
		GPR [ ra ] = TMP_SBYTE;   // sign extension
			CR[7]<LT..LT> = ((TMP_SBYTE)<0); 
#line 2854 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_SBYTE)>0); 
#line 2854 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_SBYTE)==0); 
#line 2854 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2854 "nmp/ppc32.nmp"
;
#line 2854 "nmp/ppc32.nmp"
#line 2855 "nmp/ppc32.nmp"

		}

op ext_sign_hword =   extsh
                    | extsh_cr_update

op extsh ( rs : index, ra : index )
   syntax = format ( "extsh r%d,r%d", ra, rs )
   image  = format ( "011111%5b%5b0000011100110100", rs, ra )
   action = {

		//TMP_SHWORD = GPR [ rs ] < 0..15 >;
		TMP_SHWORD = GPR [ rs ] < 15..0 >;
		GPR [ ra ] = TMP_SHWORD; // sign extension

		}

op extsh_cr_update ( rs : index, ra : index )
   syntax = format ( "extsh. r%d,r%d", ra, rs )
   image  = format ( "011111%5b%5b0000011100110101", rs,ra )
   action = {

		//TMP_SHWORD = GPR [ rs ] < 0..15 >;
		TMP_SHWORD = GPR [ rs ] < 15..0 >;
		GPR [ ra ] = TMP_SHWORD; // sign extension

			CR[7]<LT..LT> = ((TMP_SHWORD)<0); 
#line 2881 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_SHWORD)>0); 
#line 2881 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_SHWORD)==0); 
#line 2881 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2881 "nmp/ppc32.nmp"
;
#line 2881 "nmp/ppc32.nmp"
#line 2882 "nmp/ppc32.nmp"

		}

// Count Leading zeros Instruction

op count_lead_zeros_instr =   cntlzw
                            | cntlzw_cr_update

op cntlzw ( rs : REG_IND, ra : index )
   syntax = format ( "cntlzw r%d, %s", ra, rs.syntax )
   image  = format ( "011111%s%5b0000000000110100", rs.image, ra )
   action = {
               TMP_SBYTE = 31;
               loop;
            }
   loop   = {
		if TMP_SBYTE >= 0 then
			if rs <TMP_SBYTE..TMP_SBYTE> == 0 then
				TMP_SBYTE = TMP_SBYTE - 1;
				loop;
			else
				GPR [ ra ] = 31 - TMP_SBYTE;
				TMP_SBYTE = -1;
			endif;
		else
			GPR [ ra ] = 32;
		endif;
		}

op cntlzw_cr_update ( rs : REG_IND, ra : index )
   syntax = format ( "cntlzw. r%d, %s", ra, rs.syntax )
   image  = format ( "011111%s%5b0000000000110101", rs.image, ra )
   action = {
		TMP_SBYTE = 31;
		loop;
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2918 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2918 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2918 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2918 "nmp/ppc32.nmp"
;
#line 2918 "nmp/ppc32.nmp"
#line 2919 "nmp/ppc32.nmp"
		CR[7] <LT..LT> = 0;
		}
   loop   = {
		if TMP_SBYTE >= 0 then
			if rs <TMP_SBYTE..TMP_SBYTE> == 0 then
				TMP_SBYTE = TMP_SBYTE - 1;
				loop;
			else
				TMP_RES = 31 - TMP_SBYTE;
				TMP_SBYTE = -1;
			endif;
		else
			TMP_RES = 32;
		endif;
		}


// Integer Rotate and shift Instructions
op  int_rotate_shift ( x : int_rotate_shift_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = SHIFTROT

op int_rotate_shift_action =   int_rotate
                      | int_shift

// Rotate Instructions


op int_rotate =   rot_lw_imm_and_mask
                | rot_lw_and_mask
                | rot_lw_imm_mask_ins

op rot_lw_imm_and_mask =   rlwinm
                         | rlwinm_cr_update

op rlwinm ( rs : REG_IND, ra : index, sh : index, mb : index, me : index )
   syntax = format ( "rlwinm r%d,%s,%d,%d,%d", ra, rs.syntax, sh, mb, me )
   image  = format ( "010101%s%5b%5b%5b%5b0", rs.image, ra, sh, mb, me )
   action = {

		if (mb<=me) then
			TMP_WORD = 0;
			TMP_WORD < (31-mb)..(31-me) > = ~TMP_WORD < (31-mb)..(31-me) >;
        else
			TMP_WORD = 0xffffffff;
			TMP_WORD < (31-me)-1..(31-mb)+1> = ~TMP_WORD < (31-me)-1..(31-mb)+1 >;
		endif;

		GPR [ ra ] = ( ( rs <<< sh ) & TMP_WORD );

        }

op rlwinm_cr_update ( rs : REG_IND, ra : index, sh : index, mb : index, me : index )
   syntax = format ( "rlwinm. r%d,%s,%d,%d,%d", ra, rs.syntax, sh, mb, me )
   image  = format ( "010101%s%5b%5b%5b%5b1", rs.image, ra, sh, mb, me )
   action = {

		if (mb<=me) then
			TMP_WORD = 0;
			TMP_WORD < (31-mb)..(31-me) > = ~TMP_WORD < (31-mb)..(31-me) >;
        else
			TMP_WORD = 0xffffffff;
			TMP_WORD < (31-me)-1..(31-mb)+1> = ~TMP_WORD < (31-me)-1..(31-mb)+1 >;
		endif;

		TMP_RES = ( ( rs <<< sh ) & TMP_WORD );
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 2988 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 2988 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 2988 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 2988 "nmp/ppc32.nmp"
;
#line 2988 "nmp/ppc32.nmp"
#line 2989 "nmp/ppc32.nmp"

        }

op rot_lw_and_mask =   rlwnm
                     | rlwnm_cr_update

op rlwnm ( rs : REG_IND, ra : index, rb : index, mb : index, me : index )
   syntax = format ( "rlwnm r%d,%s,r%d,%d,%d", ra, rs.syntax, rb, mb, me )
   image  = format ( "010111%s%5b%5b%5b%5b0", rs.image, ra, rb, mb, me )
   action = {

		if (mb<=me) then
			TMP_WORD = 0;
			TMP_WORD < (31-mb)..(31-me) > = ~TMP_WORD < (31-mb)..(31-me) >;
        else
			TMP_WORD = -1;
			TMP_WORD < (31-me)-1..(31-mb)+1> = ~TMP_WORD < (31-me)-1..(31-mb)+1 >;
		endif;

		GPR [ ra ] = ( ( rs <<< coerce ( card ( 5 ), GPR [ rb ] < 4..0 > ) ) & TMP_WORD );

		}

op rlwnm_cr_update ( rs : REG_IND, ra : index, rb : index, mb : index, me : index )
   syntax = format ( "rlwnm. r%d,%s,r%d,%d,%d", ra, rs.syntax, rb, mb, me )
   image  = format ( "010111%s%5b%5b%5b%5b1", rs.image, ra, rb, mb, me )
   action = {

		if (mb<=me) then
			TMP_WORD = 0;
			TMP_WORD < (31-mb)..(31-me) > = ~TMP_WORD < (31-mb)..(31-me) >;
        else
			TMP_WORD = -1;
			TMP_WORD < (31-me)-1..(31-mb)+1> = ~TMP_WORD < (31-me)-1..(31-mb)+1 >;
		endif;

		TMP_RES = ( ( rs <<< coerce ( card ( 5 ), GPR [ rb ] < 4..0 > ) ) & TMP_WORD );
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 3027 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 3027 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 3027 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 3027 "nmp/ppc32.nmp"
;
#line 3027 "nmp/ppc32.nmp"
#line 3028 "nmp/ppc32.nmp"

		}

op rot_lw_imm_mask_ins =   rlwimi
                         | rlwimi_cr_update

op rlwimi ( rs : REG_IND, ra : index, sh : index, mb : index, me : index )
   syntax = format ( "rlwimi r%d,%s,%d,%d,%d", ra, rs.syntax, sh, mb, me )
   image  = format ( "010100%s%5b%5b%5b%5b0", rs.image, ra, sh, mb, me )
   action = {

		if (mb<=me) then
			TMP_WORD = 0;
			TMP_WORD < (31-mb)..(31-me) > = ~TMP_WORD < (31-mb)..(31-me) >;
        else
			TMP_WORD = -1;
			TMP_WORD < (31-me)-1..(31-mb)+1> = ~TMP_WORD < (31-me)-1..(31-mb)+1 >;
		endif;

		GPR [ ra ] = ( ( rs <<< sh ) & TMP_WORD ) | ( GPR [ ra ] & ~TMP_WORD );

		}

op rlwimi_cr_update ( rs : REG_IND, ra : index, sh : index, mb : index, me : index )
   syntax = format ( "rlwimi. r%d,%s,%d,%d,%d", ra, rs.syntax, sh, mb, me )
   image  = format ( "010100%s%5b%5b%5b%5b1", rs.image, ra, sh, mb, me )
   action = {

		if (mb<=me) then
			TMP_WORD = 0;
			TMP_WORD < (31-mb)..(31-me) > = ~TMP_WORD < (31-mb)..(31-me) >;
        else
			TMP_WORD = -1;
			TMP_WORD < (31-me)-1..(31-mb)+1> = ~TMP_WORD < (31-me)-1..(31-mb)+1 >;
		endif;

		TMP_RES = ( ( rs <<< sh ) & TMP_WORD ) | ( GPR [ ra ] & ~TMP_WORD );
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 3066 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 3066 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 3066 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 3066 "nmp/ppc32.nmp"
;
#line 3066 "nmp/ppc32.nmp"
#line 3067 "nmp/ppc32.nmp"

		}

// Shift Instructions

op int_shift =   shift_left_word
               | shift_right_word
               | shift_right_alg_wimm
               | shift_right_alg_w

op shift_left_word =   slw
                     | slw_cr_update

op slw ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "slw r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00000110000", rs.image, ra, rb.image )
   action = {

		if rb < 5..5 > == 0 then
			GPR [ ra ] = ( rs << coerce ( card ( 5 ), rb < 4..0 > ) );
		else
			GPR [ ra ] = 0;
		endif;

		}

op slw_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "slw. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00000110001", rs.image, ra, rb.image )
   action = {

		if rb < 5..5 > == 0 then
			TMP_RES = ( rs << coerce ( card ( 5 ), rb < 4..0 > ) );
		else
			TMP_RES = 0;
		endif;

		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 3105 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 3105 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 3105 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 3105 "nmp/ppc32.nmp"
;
#line 3105 "nmp/ppc32.nmp"
#line 3106 "nmp/ppc32.nmp"

		}

op shift_right_word =   srw
                      | srw_cr_update

op srw ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "srw r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s10000110000", rs.image, ra, rb.image )
   action = {

		TMP_WORD = 0;
		TMP_WORD1 = 31 - rb <4..0>;
		TMP_WORD < TMP_WORD1..0 > = ~TMP_WORD <TMP_WORD1..0>;
 		if rb < 5..5 > == 0 then
			GPR [ ra ] = ( rs >> coerce ( card ( 5 ), rb < 4..0 > ) ) & TMP_WORD;
		else
			GPR [ ra ] = 0;
		endif;

		}

op srw_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "srw. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s10000110001", rs.image, ra, rb.image )
   action = {

		TMP_WORD = 0;
		TMP_WORD1 = 31 - rb <4..0>;
		TMP_WORD<TMP_WORD1..0 > = ~TMP_WORD<TMP_WORD1..0>;
		if rb < 5..5 > == 0 then
			TMP_RES = ( rs >> coerce ( card ( 5 ), rb < 4..0 > ) ) & TMP_WORD;
		else
			TMP_RES = 0;
		endif;
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 3142 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 3142 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 3142 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 3142 "nmp/ppc32.nmp"
;
#line 3142 "nmp/ppc32.nmp"
#line 3143 "nmp/ppc32.nmp"

		}

op shift_right_alg_wimm =   srawi
                          | srawi_cr_update

op srawi ( rs : REG_IND, ra : index, sh : index )
   syntax = format ( "srawi r%d,%s,%d", ra, rs.syntax, sh )
   image  = format ( "011111%s%5b%5b11001110000", rs.image, ra, sh )
   action = {

		if rs <31..31> == 0 then
			TMP_WORD = 0;
			TMP_WORD<31-sh..0>=~TMP_WORD<31-sh..0>;
			GPR [ ra ] = ( rs >> sh ) & TMP_WORD;
			XER<CA_XER..CA_XER>=0;
		else
			TMP_WORD = 0;
			TMP_WORD<31..31-sh>=~TMP_WORD<31..31-sh>;
			GPR [ ra ] = ( rs >> sh ) | TMP_WORD;
			TMP_WORD = 0;
			TMP_WORD<sh..0>=~TMP_WORD<sh..0>;
			TMP_WORD = TMP_WORD & rs;
			if TMP_WORD != 0 then
				XER<CA_XER..CA_XER>=1;
			else
				XER<CA_XER..CA_XER>=0;
			endif;
		endif;

		}

op srawi_cr_update ( rs : REG_IND, ra : index, sh : index )
   syntax = format ( "srawi. r%d,%s,%d", ra, rs.syntax, sh )
   image  = format ( "011111%s%5b%5b11001110001", rs.image, ra, sh )
   action = {

		if rs <31..31> == 0 then
			TMP_WORD = 0;
			TMP_WORD<31-sh..0>=~TMP_WORD<31-sh..0>;
			TMP_RES = ( rs >> sh ) & TMP_WORD;
			XER<CA_XER..CA_XER>=0;
		else
			TMP_WORD = 0;
			TMP_WORD<31..32-sh>=~TMP_WORD<31..32-sh>;
			TMP_RES = ( rs >> sh ) | TMP_WORD;
			TMP_WORD = 0;
			TMP_WORD<sh..0>=~TMP_WORD<sh..0>;
			TMP_WORD = TMP_WORD & rs;
			if TMP_WORD != 0 then
				XER<CA_XER..CA_XER>=1;
			else
				XER<CA_XER..CA_XER>=0;
			endif;
		endif;
		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 3199 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 3199 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 3199 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 3199 "nmp/ppc32.nmp"
;
#line 3199 "nmp/ppc32.nmp"
#line 3200 "nmp/ppc32.nmp"

		}

op shift_right_alg_w =   sraw
                       | sraw_cr_update

op sraw ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "sraw r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s11000110000", rs.image, ra, rb.image )
   action = {

		TMP_WORD = 0;
		TMP_WORD1 = rb<4..0>;
		if rb<5..5> == 0 then
			TMP_WORD <31-TMP_WORD1..0>=~TMP_WORD<31-TMP_WORD1..0>;
		endif;
		TMP_WORD1 = 0;
		if rs<31..31> == 1 then
			TMP_WORD1 = ~TMP_WORD1;
		endif;
		GPR [ ra ] = ( ( rs >> rb <4..0>) & TMP_WORD ) | ( TMP_WORD1 & ~TMP_WORD );
		if ( rs<31..31> == 1 & ( ( rs >> rb < 4..0 >) & ~ TMP_WORD ) != 0 ) then
			XER < CA_XER..CA_XER > = 1;
		else
			XER < CA_XER..CA_XER > = 0;
		endif;

		}

op sraw_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   syntax = format ( "sraw. r%d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s11000110001", rs.image, ra, rb.image )
   action = {

		TMP_WORD = 0;
		TMP_WORD1 = rb<4..0>;
		if rb<5..5> == 0 then
			TMP_WORD <31-TMP_WORD1..0>=~TMP_WORD<31-TMP_WORD1..0>;
		endif;
		TMP_WORD1 = 0;
		if rs<31..31> == 1 then
			TMP_WORD1 = ~TMP_WORD1;
		endif;
		TMP_RES = ( ( rs >> rb <4..0>) & TMP_WORD ) | ( TMP_WORD1 & ~TMP_WORD );
		if ( rs<31..31> == 1 & ( ( rs >> rb < 4..0 >) & ~ TMP_WORD ) != 0 ) then
			XER < CA_XER..CA_XER > = 1;
		else
			XER < CA_XER..CA_XER > = 0;
		endif;

		GPR [ ra ] = TMP_RES;
			CR[7]<LT..LT> = ((TMP_RES)<0); 
#line 3251 "nmp/ppc32.nmp"
    CR[7]<GT..GT> = ((TMP_RES)>0); 
#line 3251 "nmp/ppc32.nmp"
	CR[7]<EQ..EQ> = ((TMP_RES)==0); 
#line 3251 "nmp/ppc32.nmp"
	CR[7]<SO..SO> = XER <SO_XER..SO_XER>; 
#line 3251 "nmp/ppc32.nmp"
;
#line 3251 "nmp/ppc32.nmp"
#line 3252 "nmp/ppc32.nmp"

		}


// Flow control Instructions

op flow_control_instr ( x : cond_reg_log )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = CRLI

// Condition Register Logic Instructions

op cond_reg_log =   cr_and
                  | cr_or
                  | cr_xor
                  | cr_nand
                  | cr_nor
                  | cr_eqv
                  | cr_and_comp
                  | cr_or_comp
                  | mov_cr_field
                  | mov_to_cr_field
                  | mov_to_cr_xer
                  | isel

op isel(rD: index, rA: REG_IND_ZERO, rB: index, crb: card(5))
	syntax = format("isel r%d, %s, r%5b, %d", rD, rA, rB, crb)
	image = format("011111 %5b %s %5b %5b 011110", rD, rA, rB, crb)
	action = {
		if 	CR[(31-(crb))/4]<((31-(crb))-(((31-(crb))/4)*4))..((31-(crb))-(((31-(crb))/4)*4))> 
#line 3283 "nmp/ppc32.nmp"
 then rD = rA;
#line 3283 "nmp/ppc32.nmp"
#line 3284 "nmp/ppc32.nmp"
		else rD = rB; endif;
	}

op cr_and ( crbd : index, crba : index, crbb : index)
   syntax = format ( "crand crb%d,crb%d,crb%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b01000000010", crbd, crba, crbb )
   action = {

			CR[(31-(crbd))/4]<((31-(crbd))-(((31-(crbd))/4)*4))..((31-(crbd))-(((31-(crbd))/4)*4))> 
#line 3292 "nmp/ppc32.nmp"
 = 	CR[(31-(crba))/4]<((31-(crba))-(((31-(crba))/4)*4))..((31-(crba))-(((31-(crba))/4)*4))> 
#line 3292 "nmp/ppc32.nmp"
 & 	CR[(31-(crbb))/4]<((31-(crbb))-(((31-(crbb))/4)*4))..((31-(crbb))-(((31-(crbb))/4)*4))> 
#line 3292 "nmp/ppc32.nmp"
;
#line 3292 "nmp/ppc32.nmp"
#line 3293 "nmp/ppc32.nmp"

            }

op cr_or ( crbd : index, crba : index, crbb : index)
   syntax = format ( "cror crb%d,crb%d,crb%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b01110000010", crbd, crba, crbb )
   action = {

			CR[(31-(crbd))/4]<((31-(crbd))-(((31-(crbd))/4)*4))..((31-(crbd))-(((31-(crbd))/4)*4))> 
#line 3301 "nmp/ppc32.nmp"
 = 	CR[(31-(crba))/4]<((31-(crba))-(((31-(crba))/4)*4))..((31-(crba))-(((31-(crba))/4)*4))> 
#line 3301 "nmp/ppc32.nmp"
 | 	CR[(31-(crbb))/4]<((31-(crbb))-(((31-(crbb))/4)*4))..((31-(crbb))-(((31-(crbb))/4)*4))> 
#line 3301 "nmp/ppc32.nmp"
;
#line 3301 "nmp/ppc32.nmp"
#line 3302 "nmp/ppc32.nmp"

            }

op cr_xor ( crbd : index, crba : index, crbb : index)
   syntax = format ( "crxor crb%d,crb%d,crb%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b00110000010", crbd, crba, crbb )
   action = {
			CR[(31-(crbd))/4]<((31-(crbd))-(((31-(crbd))/4)*4))..((31-(crbd))-(((31-(crbd))/4)*4))> 
#line 3309 "nmp/ppc32.nmp"
 = 	CR[(31-(crba))/4]<((31-(crba))-(((31-(crba))/4)*4))..((31-(crba))-(((31-(crba))/4)*4))> 
#line 3309 "nmp/ppc32.nmp"
 ^ 	CR[(31-(crbb))/4]<((31-(crbb))-(((31-(crbb))/4)*4))..((31-(crbb))-(((31-(crbb))/4)*4))> 
#line 3309 "nmp/ppc32.nmp"
;
#line 3309 "nmp/ppc32.nmp"
#line 3310 "nmp/ppc32.nmp"

            }

op cr_nand ( crbd : index, crba : index, crbb : index)
   syntax = format ( "crnand crb%d,crb%d,crb%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b00111000010", crbd, crba, crbb )
   action = {
			CR[(31-(crbd))/4]<((31-(crbd))-(((31-(crbd))/4)*4))..((31-(crbd))-(((31-(crbd))/4)*4))> 
#line 3317 "nmp/ppc32.nmp"
 = ~(	CR[(31-(crba))/4]<((31-(crba))-(((31-(crba))/4)*4))..((31-(crba))-(((31-(crba))/4)*4))> 
#line 3317 "nmp/ppc32.nmp"
 & 	CR[(31-(crbb))/4]<((31-(crbb))-(((31-(crbb))/4)*4))..((31-(crbb))-(((31-(crbb))/4)*4))> 
#line 3317 "nmp/ppc32.nmp"
);
#line 3317 "nmp/ppc32.nmp"
#line 3318 "nmp/ppc32.nmp"
            }

op cr_nor ( crbd : index, crba : index, crbb : index)
   syntax = format ( "crnor crb%d,crb%d,crb%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b00001000010", crbd, crba, crbb )
   action = {
			CR[(31-(crbd))/4]<((31-(crbd))-(((31-(crbd))/4)*4))..((31-(crbd))-(((31-(crbd))/4)*4))> 
#line 3324 "nmp/ppc32.nmp"
 = ~(	CR[(31-(crba))/4]<((31-(crba))-(((31-(crba))/4)*4))..((31-(crba))-(((31-(crba))/4)*4))> 
#line 3324 "nmp/ppc32.nmp"
 | 	CR[(31-(crbb))/4]<((31-(crbb))-(((31-(crbb))/4)*4))..((31-(crbb))-(((31-(crbb))/4)*4))> 
#line 3324 "nmp/ppc32.nmp"
);
#line 3324 "nmp/ppc32.nmp"
#line 3325 "nmp/ppc32.nmp"
             }

op cr_eqv ( crbd : index, crba : index, crbb : index)
   syntax = format ( "creqv crb%d,crb%d,crb%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b01001000010", crbd, crba, crbb )
   action = {
			CR[(31-(crbd))/4]<((31-(crbd))-(((31-(crbd))/4)*4))..((31-(crbd))-(((31-(crbd))/4)*4))> 
#line 3331 "nmp/ppc32.nmp"
 = 	CR[(31-(crba))/4]<((31-(crba))-(((31-(crba))/4)*4))..((31-(crba))-(((31-(crba))/4)*4))> 
#line 3331 "nmp/ppc32.nmp"
 ^ ~	CR[(31-(crbb))/4]<((31-(crbb))-(((31-(crbb))/4)*4))..((31-(crbb))-(((31-(crbb))/4)*4))> 
#line 3331 "nmp/ppc32.nmp"
;
#line 3331 "nmp/ppc32.nmp"
#line 3332 "nmp/ppc32.nmp"
            }

op cr_and_comp ( crbd : index, crba : index, crbb : index)
   syntax = format ( "crandc crb%d,crb%d,crb%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b00100000010", crbd, crba, crbb )
   action = {
			CR[(31-(crbd))/4]<((31-(crbd))-(((31-(crbd))/4)*4))..((31-(crbd))-(((31-(crbd))/4)*4))> 
#line 3338 "nmp/ppc32.nmp"
 = 	CR[(31-(crba))/4]<((31-(crba))-(((31-(crba))/4)*4))..((31-(crba))-(((31-(crba))/4)*4))> 
#line 3338 "nmp/ppc32.nmp"
 & ~	CR[(31-(crbb))/4]<((31-(crbb))-(((31-(crbb))/4)*4))..((31-(crbb))-(((31-(crbb))/4)*4))> 
#line 3338 "nmp/ppc32.nmp"
;
#line 3338 "nmp/ppc32.nmp"
#line 3339 "nmp/ppc32.nmp"
            }

op cr_or_comp ( crbd : index, crba : index, crbb : index)
   syntax = format ( "crorc crb%d,crb%d,crb%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b01101000010", crbd, crba, crbb )
   action = {
			CR[(31-(crbd))/4]<((31-(crbd))-(((31-(crbd))/4)*4))..((31-(crbd))-(((31-(crbd))/4)*4))> 
#line 3345 "nmp/ppc32.nmp"
 = 	CR[(31-(crba))/4]<((31-(crba))-(((31-(crba))/4)*4))..((31-(crba))-(((31-(crba))/4)*4))> 
#line 3345 "nmp/ppc32.nmp"
 | ~	CR[(31-(crbb))/4]<((31-(crbb))-(((31-(crbb))/4)*4))..((31-(crbb))-(((31-(crbb))/4)*4))> 
#line 3345 "nmp/ppc32.nmp"
;
#line 3345 "nmp/ppc32.nmp"
#line 3346 "nmp/ppc32.nmp"
            }

op mov_cr_field ( crfd : card ( 3 ), crfs : card ( 3 ) )
   syntax = format ( "mcrf crf%d,crf%d", crfd, crfs )
   image  = format ( "010011%3b00%3b000000000000000000", crfd, crfs )
   action = {

               //CR < (31-(4*crfd)-3)..(31-(4*crfd)) > =
               //          CR < (31-(4*crfs)-3)..(31-(4*crfs)) >;
               CR[7-crfd]=CR[7-crfs];
            }

op mov_to_cr_field ( rs : REG_IND, crm : card ( 8 ) )
   syntax = format ( "mtcrf %d,%s", crm, rs.syntax )
   image  = format ( "011111%s0%8b000100100000", rs.image, crm )
   action = {
               TMP_WORD = 0;
               TMP_BYTE = 0x00ff;

               if crm <7..7> then
                  //TMP_WORD = TMP_WORD | TMP_BYTE;
                  //TMP_WORD = TMP_WORD << 4;
                  CR[7]=rs<4*7+3..4*7>;
               endif;
               if crm <6..6> then
                  //TMP_WORD = TMP_WORD | TMP_BYTE;
                  //TMP_WORD = TMP_WORD << 4;
                  CR[6]=rs<4*6+3..4*6>;
               endif;
               if crm <5..5> then
                  //TMP_WORD = TMP_WORD | TMP_BYTE;
                  //TMP_WORD = TMP_WORD << 4;
                  CR[5]=rs<4*5+3..4*5>;
               endif;
               if crm <4..4> then
                  //TMP_WORD = TMP_WORD | TMP_BYTE;
                  //TMP_WORD = TMP_WORD << 4;
                  CR[4]=rs<4*4+3..4*4>;
               endif;
               if crm <3..3> then
                  //TMP_WORD = TMP_WORD | TMP_BYTE;
                  //TMP_WORD = TMP_WORD << 4;
                  CR[3]=rs<4*3+3..4*3>;
               endif;
               if crm <2..2> then
                  //TMP_WORD = TMP_WORD | TMP_BYTE;
                  //TMP_WORD = TMP_WORD << 4;
                  CR[2]=rs<4*2+3..4*2>;
               endif;
               if crm <1..1> then
                  //TMP_WORD = TMP_WORD | TMP_BYTE;
                  //TMP_WORD = TMP_WORD << 4;
                  CR[1]=rs<4*1+3..4*1>;
               endif;
               if crm <0..0> then
                  //TMP_WORD = TMP_WORD | TMP_BYTE;
                  CR[0]=rs<3..0>;
               endif;

               //CR = rs & TMP_WORD;

             }

op mov_to_cr_xer ( crfd : card ( 3 ) )
   syntax = format ( "mcrxr crf%d", crfd )
   image  = format ( "011111%3b00000000000010000000000", crfd )
   action = {
               //CR <(31-(4*crfd+3))..(31-(4*crfd))> = XER <28..31>;
               CR[7-crfd]=XER <31..28>;
               XER <31..28> = 0;
            }

// 2.2.4 Processor Control Instructions

op proce_control_instr ( x : proce_con_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = CONTROL

op proce_con_instr_action =   mov_from_cr
                            | mov_to_spr
                            | mov_from_spr

op mov_from_cr ( rd : index )
   syntax = format ( "mfcr r%d", rd )
   image  = format ( "011111%5b000000000000000100110", rd )
   action = {
              //GPR [ rd ] = CR;
              GPR[rd]<4*0+3..4*0>=CR[0];
              GPR[rd]<4*1+3..4*1>=CR[1];
              GPR[rd]<4*2+3..4*2>=CR[2];
              GPR[rd]<4*3+3..4*3>=CR[3];
              GPR[rd]<4*4+3..4*4>=CR[4];
              GPR[rd]<4*5+3..4*5>=CR[5];
              GPR[rd]<4*6+3..4*6>=CR[6];
              GPR[rd]<4*7+3..4*7>=CR[7];
            }

// useful macros for SPR
#line 3447 "nmp/ppc32.nmp"
#line 3454 "nmp/ppc32.nmp"

op mov_to_spr ( rs : index, spr : card ( 9 ) )
   syntax = format("mtspr %s,r%d", 	switch((spr<4..0>::spr<8..5>)) { 
#line 3456 "nmp/ppc32.nmp"
   	case 1: "xer" 
#line 3456 "nmp/ppc32.nmp"
	case 8: "lr" 
#line 3456 "nmp/ppc32.nmp"
	case 9: "ctr" 
#line 3456 "nmp/ppc32.nmp"
	default: format("%d", (spr<4..0>::spr<8..5>)) 
#line 3456 "nmp/ppc32.nmp"
	}, rs)
#line 3456 "nmp/ppc32.nmp"
#line 3457 "nmp/ppc32.nmp"
   image  = format ( "011111%5b0%9b01110100110", rs, spr )
   action = {

              	TMP_HWORD = spr;
	      	TMP_WORD = 0;
              	TMP_WORD = TMP_HWORD < 4..0 >;
              	TMP_WORD = TMP_WORD << 5;
	      	TMP_WORD1 = 0;
	      	TMP_WORD1 = TMP_HWORD<8..5>;
              	TMP_WORD = TMP_WORD | ( TMP_WORD1 & 0x0000000f);

              	if TMP_WORD > 9 then
                	"print" ( "mtspr is only user level instruction set implementation." );
		endif;
            	switch ( TMP_WORD ) {
  			case 1 : XER = GPR [ rs ];
			case 8 : LR = GPR [ rs ];
			case 9 : CTR = GPR [ rs ];
			default : "print" ( "mtspr: rs error." );
		};
             }

op mov_from_spr ( rd : index, spr : card ( 9 ) )
   syntax = format("mfspr r%d,%s", rd, 	switch((spr<4..0>::spr<8..5>)) { 
#line 3480 "nmp/ppc32.nmp"
   	case 1: "xer" 
#line 3480 "nmp/ppc32.nmp"
	case 8: "lr" 
#line 3480 "nmp/ppc32.nmp"
	case 9: "ctr" 
#line 3480 "nmp/ppc32.nmp"
	default: format("%d", (spr<4..0>::spr<8..5>)) 
#line 3480 "nmp/ppc32.nmp"
	})
#line 3480 "nmp/ppc32.nmp"
#line 3481 "nmp/ppc32.nmp"
   image  = format ( "011111%5b0%9b01010100110", rd, spr )
   action = {

              	TMP_HWORD = spr;
		TMP_WORD = 0;
              	TMP_WORD = TMP_HWORD < 4..0 >;
              	TMP_WORD = TMP_WORD << 5;
              	TMP_WORD = TMP_WORD | ( TMP_HWORD < 8..5 > & 0x0000000f);

              	if TMP_WORD > 9 then
                   "print" ( "mfspr is only user level instruction set implementation." );
		endif;
		switch ( TMP_WORD ) {
			case 1 : GPR[rd]=XER;
			case 8 : GPR[rd]=LR;
			case 9 : GPR[rd]=CTR;
			default : "print" ( "mfspr: rd error." );
		};
	}



// 2.2.5 Memory Synchronization Instructions
// LWARX, STWCX., SYNC

op mem_sync_instr ( x : mem_sync_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = MEMSYNC

op mem_sync_instr_action =  lwarx | stwcx | sync

op lwarx ( rd: index, ra: REG_IND_ZERO, rb: REG_IND )
	syntax = format ( "lwarx r%d,%s,%s", rd, ra.syntax, rb.syntax)
	image  = format ( "011111%5b%s%s00000101000", rd, ra.image, rb.image )
	action = {

		TMP_EA = ra + rb;
		TMP_RESERVE = 1;
		TMP_RESERVE_ADDR = TMP_EA;
// ToDo: TMP_EA must be a multiple of four. Otherwise aljgnment exception or results boundedly undefined
		GPR [ rd ] = M32 [ TMP_EA ];

		}

op stwcx ( rs: REG_IND, ra: REG_IND_ZERO, rb: REG_IND )
	syntax = format ( "stwcx. %s,%s,%s", rs.syntax, ra.syntax, rb.syntax )
	image  = format ( "011111%s%s%s00100101101", rs.image, ra.image, rb.image )
	action = {
		TMP_EA = ra + rb;
		if TMP_RESERVE == 1 then
			M32 [ TMP_EA ] = rs;
			CR[7] = 2;
			CR[7]<SO..SO> = XER<SO_XER..SO_XER>;
			TMP_RESERVE = 0;
		else
			CR[7] = 0;
			CR[7]<SO..SO> = XER<SO_XER..SO_XER>;
		endif;
		}

op sync ( )
	syntax = "sync"
	image  = "01111100000000000000010010101100"
	action = {
		}

// 2.2.6 Trap Instructions
// TW, TWI

op trap_instr ( x : trap_instr_action )
	syntax = x.syntax
	image = x.image
	action = { x.action; }
        otawa_kind = TRAP

op trap_instr_action = tw | twi

op tw ( to: card(5), ra: REG_IND, rb: REG_IND )
	syntax = format ( "tw %d,%s,%s", to, ra.syntax, rb.syntax )
	image  = format ( "011111%5b%s%s00000001000", to, ra.image, rb.image )
	action = {
		if ( to == 1 & ra < rb ) then
			// TRAP how do we make a trap???
		endif;
		if ( to == 2 & ra > rb ) then
			// TRAP how do we make a trap???
		endif;
		if ( to == 4 & ra == rb ) then
			// TRAP how do we make a trap???
		endif;
		if ( to == 8 & ( ( ra > 0 & rb < 0 ) |
						 ( ra > 0 & rb > 0 & ra < rb ) |
						 ( ra < 0 & rb < 0 & ra > rb ) ) ) then
			// TRAP how do we make a trap???
		endif;
		if ( to == 16 & ( ( ra < 0 & rb > 0 ) |
						  ( ra > 0 & rb > 0 & ra > rb ) |
						  ( ra < 0 & rb < 0 & ra < rb ) ) ) then
			// TRAP how do we make a trap???
		endif;
		}

op twi ( to: card(5), ra: REG_IND, b: SIMM16 )
	syntax = format ( "twi %d,%s,%s", to, ra.syntax, b.syntax )
	image  = format ( "000011%5b%s%s", to, ra.image, b.image )
	action = {
		TMP_WORD = b;
		if ( to == 1 & ra < TMP_WORD ) then
			// TRAP how do we make a trap???
		endif;
		if ( to == 2 & ra > TMP_WORD ) then
			// TRAP how do we make a trap???
		endif;
		if ( to == 4 & ra == TMP_WORD ) then
			// TRAP how do we make a trap???
		endif;
		if ( to == 8 & ( ( ra > 0 & TMP_WORD < 0 ) |
						 ( ra > 0 & TMP_WORD > 0 & ra < TMP_WORD ) |
						 ( ra < 0 & TMP_WORD < 0 & ra > TMP_WORD ) ) ) then
			// TRAP how do we make a trap???
		endif;
		if ( to == 16 & ( ( ra < 0 & TMP_WORD > 0 ) |
						  ( ra > 0 & TMP_WORD > 0 & ra > TMP_WORD ) |
						  ( ra < 0 & TMP_WORD < 0 & ra < TMP_WORD ) ) ) then
			// TRAP how do we make a trap???
		endif;
		}

// End PowerPc755 Description
#line 1 "nmp/oea_instr.nmp"
///**************************************************************************** 
//                                oea_instr.nmp                                 
//                              ------------------                              
//    date            : May 2003                                               
//    copyright       : Institut de Recherche en Informatique de Toulouse       
//    author          : Daniel Gracia-Perez                                              
//    email           : sainrat@irit.fr                        
// ****************************************************************************/
//                                                                              
///**************************************************************************** 
// *                                                                          * 
// *   This program is free software; you can redistribute it and/or modify   * 
// *   it under the terms of the GNU General Public License as published by   * 
// *   the Free Software Foundation; either version 2 of the License, or      * 
// *   (at your option) any later version.                                    * 
// *                                                                          * 
// ****************************************************************************/


// This file contains the nMP description of the OEA 
// instructions of the PowerPC 

// ========================================================================= //
// 1. Definitions                                                            //
// ========================================================================= //
// 
// 1.1.6 otawa_kind of instructions (old ones)
// Might be used to know in which functional unit the instruction is executed
let SEG = IS_INTERN //"15"   // Segment Register Manipulation Instructions
let TLB = IS_INTERN //"16"           // Lookaside Buffer Management Instructions


// ========================================================================= //
//  2. Instructions                                                          //
// ========================================================================= //

// checking if the processor is in superuser mode, if not exception
op oea_instr ( x: oea_instr_action)
	syntax = x.syntax
	image  = x.image
	action = {
		if MSR<MSR_PR..MSR_PR> then
			"launch_exception"("instr",PROGRAM);
		else
			x.action;
		endif;
		}
	otawa_kind = x.otawa_kind
	

op oea_instr_action = //oea_cache_man_instr       // cache management instructions
                 
                      oea_proc_control_instr    // processor control instructions
                    | oea_seg_reg_man_instr     // segment register manipulation instructions
                    | oea_sys_link_instr        // system linkage instructions (without sc)
                    | oea_tlb_man_instr         // lookaside buffer management instructions
                    | mfapidi


op mfapidi(rd: REG_IND, ra: REG_IND)
	syntax = format("mfapidi %s, %s", rd, ra)
	image = format("011111 %s %s XXXXX 0100010011 X", rd, ra)
	action = {
		// micro-architecture dependent action
		// code below ensure only register access
		TMP_EA = ra;
		rd = TMP_WORD;
	}
	otawa_kind = CONTROL


// ------------------------------------------------------------------------- //
// 2.1 cache management instructions
// ------------------------------------------------------------------------- //
//op  oea_cache_man_instr( x : oea_cache_man_instr_action )
//   syntax = x.syntax
//   image  = x.image
//   action = { x.action; }
//   otawa_kind = CACHE

//op oea_cache_man_instr_action = oea_dcbf | oea_dcbi

//op oea_dcbf(ra: REG_IND_ZERO, rb: REG_IND)
//	syntax = format("dcbf %s, %s", ra, rb)
//	image = format("0111 11XX XXX %s %s 000 1010 110X", ra, rb)
//	action = {
//		TMP_EA = ra + rb;
//		"FlushDataCacheBlock"(TMP_EA);
//	}
	
//op oea_dcbi ( ra: REG_IND_ZERO, rb: REG_IND )
//	syntax = format("dcbi %s, %s", ra, rb)
//	image  = format("0111 11XX XXX %s %s 011 1010 110X", ra, rb)
//	action = {
//		TMP_EA = ra + rb;
//		"InvalidateDataCacheBlock"(TMP_EA);
//	}
//   otawa_used_regs = "USED_REGS"(gpr_read(ra.value), gpr_read(rb.value), END_REG)


// ------------------------------------------------------------------------- //
// 2.2 processor control instructions
// ------------------------------------------------------------------------- //

op  oea_proc_control_instr ( x :oea_proc_control_instr_action  )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = CONTROL

op oea_proc_control_instr_action =   oea_mfmsr
                            | oea_mfspr
                            | oea_mtmsr
                            | oea_mtspr

op oea_mfmsr ( rd : REG_IND)
	syntax = format ( "mfmsr %s", rd.syntax )
	image  = format ( "011111%s000000000000010100110", rd.image )
	action = {
			rd = MSR;
		}
		
op oea_mfspr ( rd : REG_IND, spr : card ( 9 ) )
   syntax = format ( "mfspr %s,%d", rd.syntax , spr )
   image  = format ( "011111%s1%9b01010100110", rd.image, spr )
   action = {
              	TMP_HWORD = spr;
		TMP_WORD = 0; 
              	TMP_WORD = TMP_HWORD < 4..0 >;
              	TMP_WORD = TMP_WORD << 5;
              	TMP_WORD = (TMP_WORD | ( TMP_HWORD < 8..5 > & 0x0000000f))|0x00000010;
		switch(TMP_WORD) {
			case 1:    GPR[rd] = XER      ;
			case 8:    GPR[rd] = LR       ;
			case 9:    GPR[rd] = CTR      ;
			case 18:   GPR[rd] = DSISR    ;
			case 19:   GPR[rd] = DAR      ;
                        case 22:   GPR[rd] = DEC      ;
			case 25:   GPR[rd] = SDR1     ;
                        case 26:   GPR[rd] = SRR[0]   ;
                        case 27:   GPR[rd] = SRR[1]   ;
                        case 268:  GPR[rd] = TBL      ;
                        case 269:  GPR[rd] = TBU      ;
                        case 272:  GPR[rd] = SPRG[0]  ;
                        case 273:  GPR[rd] = SPRG[1]  ;
			case 274:  GPR[rd] = SPRG[2]  ;
                        case 275:  GPR[rd] = SPRG[3]  ;
                        case 276:  GPR[rd] = SPRG[4]  ; // mpc755 ONLY
                        case 277:  GPR[rd] = SPRG[5]  ; // mpc755 ONLY
                        case 278:  GPR[rd] = SPRG[6]  ; // mpc755 ONLY
                        case 279:  GPR[rd] = SPRG[7]  ; // mpc755 ONLY
                        case 282:  GPR[rd] = EAR      ;
                        case 287:  GPR[rd] = PVR      ;
                        case 528:  GPR[rd] = IBAT[0]  ;
                        case 529:  GPR[rd] = IBAT[1]  ;
                        case 530:  GPR[rd] = IBAT[2]  ;
                        case 531:  GPR[rd] = IBAT[3]  ;
                        case 532:  GPR[rd] = IBAT[4]  ;
                        case 533:  GPR[rd] = IBAT[5]  ;
                        case 534:  GPR[rd] = IBAT[6]  ;
                        case 535:  GPR[rd] = IBAT[7]  ;
                        case 536:  GPR[rd] = DBAT[0]  ;
                        case 537:  GPR[rd] = DBAT[1]  ;
                        case 538:  GPR[rd] = DBAT[2]  ;
                        case 539:  GPR[rd] = DBAT[3]  ;
                        case 540:  GPR[rd] = DBAT[4]  ;
                        case 541:  GPR[rd] = DBAT[5]  ;
                        case 542:  GPR[rd] = DBAT[6]  ;
                        case 543:  GPR[rd] = DBAT[7]  ;
                        case 560:  GPR[rd] = IBAT[8]  ; // mpc755 ONLY
                        case 561:  GPR[rd] = IBAT[9]  ; // mpc755 ONLY
                        case 562:  GPR[rd] = IBAT[10] ; // mpc755 ONLY
                        case 563:  GPR[rd] = IBAT[11] ; // mpc755 ONLY
                        case 564:  GPR[rd] = IBAT[12] ; // mpc755 ONLY
                        case 565:  GPR[rd] = IBAT[13] ; // mpc755 ONLY
                        case 566:  GPR[rd] = IBAT[14] ; // mpc755 ONLY
                        case 567:  GPR[rd] = IBAT[15] ; // mpc755 ONLY
                        case 568:  GPR[rd] = DBAT[8]  ; // mpc755 ONLY
                        case 569:  GPR[rd] = DBAT[9]  ; // mpc755 ONLY
                        case 570:  GPR[rd] = DBAT[10] ; // mpc755 ONLY
                        case 571:  GPR[rd] = DBAT[11] ; // mpc755 ONLY
                        case 572:  GPR[rd] = DBAT[12] ; // mpc755 ONLY
                        case 573:  GPR[rd] = DBAT[13] ; // mpc755 ONLY
                        case 574:  GPR[rd] = DBAT[14] ; // mpc755 ONLY
                        case 575:  GPR[rd] = DBAT[15] ; // mpc755 ONLY
                        case 936:  GPR[rd] = UMMCR[0] ; // mpc750 & mpc755 ONLY
                        case 937:  GPR[rd] = UPMC[0]  ; // mpc750 & mpc755 ONLY
                        case 938:  GPR[rd] = UPMC[1]  ; // mpc750 & mpc755 ONLY
                        case 939:  GPR[rd] = USIA     ; // mpc750 & mpc755 ONLY
                        case 940:  GPR[rd] = UMMCR[1] ; // mpc750 & mpc755 ONLY
                        case 941:  GPR[rd] = UPMC[2]  ; // mpc750 & mpc755 ONLY
                        case 942:  GPR[rd] = UPMC[3]  ; // mpc750 & mpc755 ONLY
                       	case 952:  GPR[rd] = MMCR[0]  ; // mpc750 & mpc755 ONLY
                        case 953:  GPR[rd] = PMC[0]   ; // mpc750 & mpc755 ONLY
                        case 954:  GPR[rd] = PMC[1]   ; // mpc750 & mpc755 ONLY
                        case 955:  GPR[rd] = SIA      ; // mpc750 & mpc755 ONLY
                        case 956:  GPR[rd] = MMCR[1]  ; // mpc750 & mpc755 ONLY
                        case 957:  GPR[rd] = PMC[2]   ; // mpc750 & mpc755 ONLY
                        case 958:  GPR[rd] = PMC[3]   ; // mpc750 & mpc755 ONLY
                        case 976:  GPR[rd] = DMISS    ; // mpc755 ONLY
                        case 977:  GPR[rd] = DCMP     ; // mpc755 ONLY
                        case 978:  GPR[rd] = HASH[1]  ; // mpc755 ONLY
                        case 979:  GPR[rd] = HASH[2]  ; // mpc755 ONLY
                        case 980:  GPR[rd] = IMISS    ; // mpc755 ONLY
                        case 981:  GPR[rd] = ICMP     ; // mpc755 ONLY
                        case 982:  GPR[rd] = RPA      ; // mpc755 ONLY
                        case 1008: GPR[rd] = HID[0]   ; // mpc750 & mpc755 ONLY
                        case 1009: GPR[rd] = HID[1]   ; // mpc750 & mpc755 ONLY
                  	case 1010: GPR[rd] = IABR     ; // mpc750 & mpc755 ONLY
                        case 1011: GPR[rd] = HID[2]   ; // mpc755 ONLY
                  	case 1013: GPR[rd] = DABR     ; // mpc750 & mpc755 ONLY
                        case 1016: GPR[rd] = L2PM     ; // mpc755 ONLY
                  	case 1017: GPR[rd] = L2CR     ; // mpc750 & mpc755 ONLY
                  	case 1019: GPR[rd] = ICTC     ; // mpc750 & mpc755 ONLY
                  	case 1020: GPR[rd] = THRM[0]  ; // mpc750 & mpc755 ONLY
                  	case 1021: GPR[rd] = THRM[1]  ; // mpc750 & mpc755 ONLY
                  	case 1022: GPR[rd] = THRM[2]  ; // mpc750 & mpc755 ONLY
};
		}
							
op oea_mtmsr ( rs : REG_IND )
	syntax = format ( "mtmsr %s", rs.syntax )
	image  = format ( "011111%s000000000000100100100", rs.image )
	action = {
			MSR = rs;
		}

op oea_mtspr ( spr : card( 9 ) , rs : index )
	syntax = format ( "mtspr %d,r%d", spr, rs )
	image  = format ( "011111%5b1%9b01110100110", rs, spr )
	action = {
		TMP_HWORD = spr;
		TMP_WORD = 0;
		TMP_WORD = TMP_HWORD < 4..0 >;
		TMP_WORD = TMP_WORD << 5;
		TMP_WORD = (TMP_WORD | ( TMP_HWORD < 8..5 > & 0x0000000f))|0x00000010;

		switch(TMP_WORD) {
		  case 1:    XER      = GPR[rs] ;
		  case 8:    LR       = GPR[rs] ;
		  case 9:    CTR      = GPR[rs] ;
		  case 18:   DSISR    = GPR[rs] ;
		  case 19:   DAR      = GPR[rs] ;
                  case 22:   DEC      = GPR[rs] ;
		  case 25:   SDR1     = GPR[rs] ;
                  case 26:   SRR[0]   = GPR[rs] ;
                  case 27:   SRR[1]   = GPR[rs] ;
                  case 272:  SPRG[0]  = GPR[rs] ;
                  case 273:  SPRG[1]  = GPR[rs] ;
		  case 274:  SPRG[2]  = GPR[rs] ;
                  case 275:  SPRG[3]  = GPR[rs] ;
                  case 276:  SPRG[4]  = GPR[rs] ; // mpc755 ONLY
                  case 277:  SPRG[5]  = GPR[rs] ; // mpc755 ONLY
                  case 278:  SPRG[6]  = GPR[rs] ; // mpc755 ONLY
                  case 279:  SPRG[7]  = GPR[rs] ; // mpc755 ONLY
                  case 282:  EAR      = GPR[rs] ;
                  case 284:  TBL      = GPR[rs] ;
                  case 285:  TBU      = GPR[rs] ;
                  case 287:  PVR      = GPR[rs] ;
                  case 528:  IBAT[0]  = GPR[rs] ;
                  case 529:  IBAT[1]  = GPR[rs] ;
                  case 530:  IBAT[2]  = GPR[rs] ;
                  case 531:  IBAT[3]  = GPR[rs] ;
                  case 532:  IBAT[4]  = GPR[rs] ;
                  case 533:  IBAT[5]  = GPR[rs] ;
                  case 534:  IBAT[6]  = GPR[rs] ;
                  case 535:  IBAT[7]  = GPR[rs] ;
                  case 536:  DBAT[0]  = GPR[rs] ;
                  case 537:  DBAT[1]  = GPR[rs] ;
                  case 538:  DBAT[2]  = GPR[rs] ;
                  case 539:  DBAT[3]  = GPR[rs] ;
                  case 540:  DBAT[4]  = GPR[rs] ;
                  case 541:  DBAT[5]  = GPR[rs] ;
                  case 542:  DBAT[6]  = GPR[rs] ;
                  case 543:  DBAT[7]  = GPR[rs] ;
                  case 560:  IBAT[8]  = GPR[rs] ; // mpc755 ONLY
                  case 561:  IBAT[9]  = GPR[rs] ; // mpc755 ONLY
                  case 562:  IBAT[10] = GPR[rs] ; // mpc755 ONLY
                  case 563:  IBAT[11] = GPR[rs] ; // mpc755 ONLY
                  case 564:  IBAT[12] = GPR[rs] ; // mpc755 ONLY
                  case 565:  IBAT[13] = GPR[rs] ; // mpc755 ONLY
      		  case 566:  IBAT[14] = GPR[rs] ; // mpc755 ONLY
      		  case 567:  IBAT[15] = GPR[rs] ; // mpc755 ONLY
      		  case 568:  DBAT[8]  = GPR[rs] ; // mpc755 ONLY
      		  case 569:  DBAT[9]  = GPR[rs] ; // mpc755 ONLY
      		  case 570:  DBAT[10] = GPR[rs] ; // mpc755 ONLY
      		  case 571:  DBAT[11] = GPR[rs] ; // mpc755 ONLY
      		  case 572:  DBAT[12] = GPR[rs] ; // mpc755 ONLY
      		  case 573:  DBAT[13] = GPR[rs] ; // mpc755 ONLY
      		  case 574:  DBAT[14] = GPR[rs] ; // mpc755 ONLY
      		  case 575:  DBAT[15] = GPR[rs] ; // mpc755 ONLY
          	  case 936:  UMMCR[0] = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 937:  UPMC[0]  = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 938:  UPMC[1]  = GPR[rs] ; // mpc750 & mpc755 ONLY
          	  case 939:  USIA     = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 940:  UMMCR[1] = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 941:  UPMC[2]  = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 942:  UPMC[3]  = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 952:  MMCR[0]  = GPR[rs] ; // mpc750 & mpc755 ONLY
            	  case 953:  PMC[0]   = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 954:  PMC[1]   = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 955:  SIA      = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 956:  MMCR[1]  = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 957:  PMC[2]   = GPR[rs] ; // mpc750 & mpc755 ONLY
           	  case 958:  PMC[3]   = GPR[rs] ; // mpc750 & mpc755 ONLY
      		  case 976:  DMISS    = GPR[rs] ; // mpc755 ONLY
      		  case 977:  DCMP     = GPR[rs] ; // mpc755 ONLY
      		  case 978:  HASH[1]  = GPR[rs] ; // mpc755 ONLY
      		  case 979:  HASH[2]  = GPR[rs] ; // mpc755 ONLY
      		  case 980:  IMISS    = GPR[rs] ; // mpc755 ONLY
      		  case 981:  ICMP     = GPR[rs] ; // mpc755 ONLY
      		  case 982:  RPA      = GPR[rs] ; // mpc755 ONLY
      		  case 1008: HID[0]   = GPR[rs] ; // mpc755 ONLY
      		  case 1009: HID[1]   = GPR[rs] ; // mpc755 ONLY
                  case 1010: IABR     = GPR[rs] ; // mpc750 & mpc755 ONLY
      		  case 1011: HID[2]   = GPR[rs] ; // mpc755 ONLY
                  case 1013: DABR     = GPR[rs] ; // mpc750 & mpc755 ONLY
                  case 1016: L2PM     = GPR[rs] ; // mpc755 ONLY
                  case 1017: L2CR     = GPR[rs] ; // mpc750 & mpc755 ONLY
                  case 1019: ICTC     = GPR[rs] ; // mpc750 & mpc755 ONLY
                  case 1020: THRM[0]  = GPR[rs] ; // mpc750 & mpc755 ONLY
                  case 1021: THRM[1]  = GPR[rs] ; // mpc750 & mpc755 ONLY
                  case 1022: THRM[2]  = GPR[rs] ; // mpc750 & mpc755 ONLY
			};
		}

// ------------------------------------------------------------------------- //
// 2.3 segment register manipulation instructions
// ------------------------------------------------------------------------- //

op  oea_seg_reg_man_instr ( x : oea_seg_reg_man_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = SEG

op oea_seg_reg_man_instr_action  =   oea_mfsr
                                   | oea_mfsrin
                                   | oea_mtsr
                                   | oea_mtsrin

op oea_mfsr ( rd : REG_IND , sr : card(4) )
	syntax = format ( "mfsr %s,%d", rd.syntax, sr )
	image  = format ( "011111%s0%4b0000010010100110", rd.image, sr )
	action = {
			rd = SR[sr];
		}

op oea_mfsrin ( rd : REG_IND , rb : REG_IND )
	syntax = format ( "mfsrin %s,%s", rd.syntax, rb.syntax )
	image  = format ( "011111%s00000%s10100100110", rd.image, rb.image )
	action = {
			rd = SR [ rb <31..28> ];
		}

op oea_mtsr ( sr : card(4) , rd : REG_IND )
	syntax = format ( "mtsr %d,%s", sr, rd.syntax )
	image  = format ( "011111%s0%4b0000000110100100", rd.image, sr )
	action = {
			SR[sr] = rd;
		}

op oea_mtsrin ( rs : REG_IND , rb : REG_IND )
	syntax = format ( "mtsrin %s,%s", rs.syntax, rb.syntax )
	image  = format ( "011111%s00000%s00111100100", rs.image, rb.image )
	action = {
			SR[ rb < 31..28 > ] = rs;
		}
	
// ------------------------------------------------------------------------- //
// 2.4 system linkage instructions (without sc)
// ------------------------------------------------------------------------- //
op  oea_sys_link_instr ( x : oea_sys_link_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = SYSTEM

op oea_sys_link_instr_action =   oea_rfi

op oea_rfi ( )
	syntax = "rfi" 
	image  = "01001100000000000000000001100100"
	action = {
// Hmmm. rfi should be executed only in program order.
// ToDo : This should be replaced by an external function which is executed only at complete.
			MSR < 31..31 > = SRR [1] < 31..31 >;
			MSR < 26..22 > = SRR [1] < 26..22 >;
			MSR < 15..8 >  = SRR [1] < 15..8 >;
			MSR < 6..4 >   = SRR [1] < 6..4 >;
			MSR < 1..0 >   = SRR [1] < 1..0 >;
			MSR < 18..18 > = SRR [1] < 18..18 >;
			NIA = SRR [0] & 0xfffffffc;
		}
        otawa_kind = SYSTEM
// ------------------------------------------------------------------------- //
// 2.5 translation lookaside buffer (TLB) management instructions
// ------------------------------------------------------------------------- //

op  oea_tlb_man_instr ( x : oea_tlb_man_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = TLB

op oea_tlb_man_instr_action  =   oea_tlbia
                        | oea_tlbie
                        | oea_tlbsync

op oea_tlbia ()
	syntax = "tlbia"
	image  = "01111100000000000000001011100100"
	action = {
			// TLB management is hardware-dependent
			// Nothing to do in the iss
		}

op oea_tlbie ( rb : REG_IND )
	syntax = format ( "tlbie %s", rb.syntax )
	image  = format ( "0111110000000000%s01001100100", rb.image )
	action = {
			// TLB management is hardware-dependent
			// Nothing to do in the iss
		}

op oea_tlbsync ()
	syntax = "tlbsync"
	image  = "01111100000000000000010001101100"
	action = {
			// TLB management is hardware-dependent
			// Nothing to do in the iss
		}
#line 1 "nmp/vea_instr.nmp"
///**************************************************************************** 
//                                vea_instr.nmp                                 
//                              ------------------                              
//    date            : May 2003                                               
//    copyright       : Institut de Recherche en Informatique de Toulouse       
//    author          : Daniel Gracia-Perez                                             
//    email           : sainrat@irit.fr                        
// ****************************************************************************/
//                                                                             
///**************************************************************************** 
// *                                                                          * 
// *   This program is free software; you can redistribute it and/or modify   * 
// *   it under the terms of the GNU General Public License as published by   * 
// *   the Free Software Foundation; either version 2 of the License, or      * 
// *   (at your option) any later version.                                    * 
// *                                                                          * 
// ****************************************************************************/


// This file contains the nMP description of the VEA 
// instructions of the PowerPC 

// ========================================================================= //
// 1. Definitions                                                            //
// ========================================================================= //
// nada

// ========================================================================= //
//  2. Instructions                                                          //
// ========================================================================= //


op vea_instr =    vea_cache_man_instr       // cache management instructions
                | vea_ext_control_instr     // external control instructions
                | vea_mem_sync_instr        // memory synchronization instructions
                | vea_proc_control_instr    // processor control instructions
			   
// ------------------------------------------------------------------------- //
// 2.1 cache management instructions
// ------------------------------------------------------------------------- //

op  vea_cache_man_instr( x : vea_cache_man_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = CACHE

op vea_cache_man_instr_action =
	  vea_dcba | vea_dcbf | vea_dcbi | vea_dcbst | vea_dcbt | vea_dcbtst | vea_dcbz
	| vea_icbi

op vea_dcba ( ra: REG_IND_ZERO, rb: REG_IND )

	syntax = format ( "dcba %s,%s", ra.syntax, rb.syntax )
	image  = format ( "0111 1100 000 %s %s 001 0101 1000", ra.image, rb.image )
	action = {
		TMP_EA = ra + rb;
		}

op vea_dcbf(ra: REG_IND_ZERO, rb: REG_IND)
	syntax = format("dcbf %s, %s", ra, rb)
	image = format("0111 11XX XXX %s %s 000 1010 110X", ra, rb)
	action = {
		TMP_EA = ra + rb;
		"FlushDataCacheBlock"(TMP_EA);
	}
	
op vea_dcbi ( ra: REG_IND_ZERO, rb: REG_IND )
	syntax = format("dcbi %s, %s", ra, rb)
	image  = format("0111 11XX XXX %s %s 011 1010 110X", ra, rb)
	action = {
		TMP_EA = ra + rb;
		"InvalidateDataCacheBlock"(TMP_EA);
	}

op vea_dcbst ( ra: REG_IND_ZERO, rb: REG_IND )
	syntax = format ( "dcbst %s,%s", ra.syntax, rb.syntax )
	image  = format ( "01111100000%s%s00001101100", ra.image, rb.image )
	action = {
		TMP_EA = ra + rb;
		}

op vea_dcbt ( ra: REG_IND_ZERO, rb: REG_IND )
	syntax = format ( "dcbt %s,%s", ra.syntax, rb.syntax )
	image  = format ( "01111100000%s%s01000101100", ra.image, rb.image )
	action = {
		TMP_EA = ra + rb;
		}

op vea_dcbtst ( ra: REG_IND_ZERO, rb: REG_IND )
	syntax = format ( "dcbtst %s,%s", ra.syntax, rb.syntax )
	image  = format ( "01111100000%s%s00111101100", ra.image, rb.image )
	action = {
		TMP_EA = ra + rb;
		}

op vea_dcbz ( ra: REG_IND_ZERO, rb: REG_IND )
	syntax = format ( "dcbz %s,%s", ra.syntax, rb.syntax )
	image  = format ( "01111100000%s%s11111101100", ra.image, rb.image )
	action = {
		TMP_EA = ra + rb;
		TMP_WORD=TMP_EA-(TMP_EA%32);
		TMP_SWORD=0;
		recurs;
		}
	recurs = {
		if TMP_SWORD<32 then
			M[TMP_WORD+TMP_SWORD]=0;
			TMP_SWORD=TMP_SWORD+1;
			recurs;
		endif;
		}

op vea_icbi ( ra: REG_IND_ZERO, rb: REG_IND )
	syntax = format ( "icbi %s,%s", ra.syntax, rb.syntax )
	image  = format ( "01111100000%s%s11110101100", ra.image, rb.image )
	action = {
		TMP_EA = ra + rb;
		}


// ------------------------------------------------------------------------- //
// 2.2 external control instructions
// ------------------------------------------------------------------------- //

op  vea_ext_control_instr( x : vea_ext_control_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = EXT

op vea_ext_control_instr_action  =   vea_eciwx
                            | vea_ecowx


op vea_eciwx ( rd: REG_IND, ra: REG_IND_ZERO, rb: REG_IND )
	syntax = format ( "eciwx %s,%s,%s",rd.syntax,ra.syntax,rb.syntax )
	image  = format ( "011111%s%s%s01001101100", rd.image, ra.image, rb.image )
	action = {
		}
	user0 = "2"

op vea_ecowx ( rs: REG_IND, ra: REG_IND_ZERO, rb: REG_IND )
	syntax = format ( "ecowx %s,%s,%s",rs.syntax,ra.syntax,rb.syntax )
	image  = format ( "011111%s%s%s01101101100", rs.image, ra.image, rb.image )
	action = {
		}


// ------------------------------------------------------------------------- //
// 2.3 memory synchronization instructions
// ------------------------------------------------------------------------- //

op  vea_mem_sync_instr( x : vea_mem_sync_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = MEMSYNC

op vea_mem_sync_instr_action =   vea_eieio
                        | vea_isync

op vea_eieio ()
	syntax = "eieio" 
   	image  = "01111100000000000000011010101100"
  	action = {
		}

op vea_isync ()
	syntax = "isync"
	image  = "01001100000000000000000100101100"
	action = {
		}

// ------------------------------------------------------------------------- //
// 2.4 processor control instructions
// ------------------------------------------------------------------------- //

op  vea_proc_control_instr( x : vea_proc_control_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = CONTROL

op vea_proc_control_instr_action = vea_mftb

op vea_mftb ( rd : index, tbr : card ( 10 ) )
	syntax = format ( "mftb r%d,%d", rd, tbr )
	image  = format ( "011111%5b%10b01011100110", rd, tbr )
	action = {
		TMP_HWORD = tbr;
		TMP_WORD = 0;
		TMP_WORD = TMP_HWORD < 4..0 >;
		TMP_WORD = TMP_WORD << 5;
		TMP_WORD = TMP_WORD | ( TMP_HWORD < 9..5 > & 0x0000001f);

		if TMP_WORD == 268 then
			GPR[rd] = TBL;
		else
			if TMP_WORD == 269 then
				GPR[rd] =TBU;
			endif;
		endif;
		}
		
#line 1 "nmp/essp_fp_instr.nmp"
// embedded scalar single-precision floating-pont instructions

// canonicals
canon flots "truncf"(flots)

// SPE state
reg SPEFSCR [ 1 , long ]

// SPE Status and Control Register 

let FP_FRMC_TONEAREST = 0
let FP_FRMC_TOWARDZERO =1
let FP_FRMC_UPWARD =2
let FP_FRMC_DOWNWARD =3
let FP_SOVH  = 31
let FP_OVH   = 30
let FP_FGH   = 29
reg SPEFSCR_FGH [1, card(1)] alias = SPEFSCR<FP_FGH..FP_FGH>
let FP_FXH   = 28
reg SPEFSCR_FXH [1, card(1)] alias = SPEFSCR<FP_FXH..FP_FXH>
let FP_FINVH = 27
let FP_FDBZH = 26
let FP_FUNFH = 25
let FP_FOVFH = 24
let FP_FINXS = 21
reg SPEFSCR_FINXS [1, card(1)] alias = SPEFSCR<FP_FINXS..FP_FINXS>
let FP_FINVS = 20
let FP_FDBZS = 19
let FP_FUNFS = 18
let FP_FOVFS = 17
let FP_MODE  = 16
let FP_SOV   = 15
let FP_OV    = 14
let FP_FG    = 13
reg SPEFSCR_FG [1, card(1)] alias = SPEFSCR<FP_FG..FP_FG>
let FP_FX    = 12
reg SPEFSCR_FX [1, card(1)] alias = SPEFSCR<FP_FX..FP_FX>
let FP_FINV  = 11
let FP_FDBZ  = 10
let FP_FUNF  = 9
let FP_FOVF  = 8
let FP_FINXE = 6
reg SPEFSCR_FINXE [1, card(1)] alias = SPEFSCR<FP_FINXE..FP_FINXE>
let FP_FINVE = 5
let FP_FDBZE = 4
let FP_FUNFE = 3
let FP_FOVFE = 2
reg SPEFSCR_FRMC [1, card(2)] alias = SPEFSCR<1..0>


let EFPARITH = IS_ALU | IS_FLOAT    // Floating-Point Arithmetic Instructions
let EFPMUL = IS_ALU | IS_MUL | IS_FLOAT 
let EFPDIV = IS_ALU | IS_DIV | IS_FLOAT 
let EFPRC = IS_ALU | IS_FLOAT | IS_INT // FP rounding and convert
let EFPCMP = IS_ALU | IS_FLOAT  // FP compare


var TMP_FLOT32    [ 1 , flots ]
var TMP_FLOAT32_A [ 1 , flots ]
var TMP_FLOAT32_B [ 1 , flots ]
var TMP_FLOAT32_D [ 1 , flots ]
var efs_result		[1, card(32)]
var efs_maxexp		[1, card(32)]
var efs_ml1			[1, card(32)]
var efs_pow			[1, card(32)]
var efs_sc			[1, card(32)]
var efs_guard		[1, bool]
var efs_sticky		[1, bool]
var efs_v			[1, card(32)]
var efs_bits		[1, card(32)]
var efs_shift		[1, card(32)]
var efs_al			[1, flots]
var efs_bl			[1, flots]
var efs_cl			[1, card(1)]
		

let EFS_SIGN = 0
let EFS_UNSIGN = 1
let EFS_UPPER = 0
let EFS_LOWER = 1
let EFS_F = 0
let EFS_I = 1
let EFS_ROUND= 0
let EFS_TRUNC = 1


//SPE values

let FP_PMAX = 0x7f7fffff
let FP_PMIN = 0x00800000
let FP_MMAX = 0x00ffffff

let S32_MIN = -0x80000000
let S32_MAX =  0x7fffffff



// macros

#line 101 "nmp/essp_fp_instr.nmp"
#line 102 "nmp/essp_fp_instr.nmp"
#line 103 "nmp/essp_fp_instr.nmp"

#line 125 "nmp/essp_fp_instr.nmp"

#line 138 "nmp/essp_fp_instr.nmp"

#line 186 "nmp/essp_fp_instr.nmp"

#line 306 "nmp/essp_fp_instr.nmp"

#line 308 "nmp/essp_fp_instr.nmp"
#line 309 "nmp/essp_fp_instr.nmp"
#line 310 "nmp/essp_fp_instr.nmp"
#line 311 "nmp/essp_fp_instr.nmp"
#line 312 "nmp/essp_fp_instr.nmp"
#line 313 "nmp/essp_fp_instr.nmp"
#line 314 "nmp/essp_fp_instr.nmp"
#line 315 "nmp/essp_fp_instr.nmp"
#line 316 "nmp/essp_fp_instr.nmp"
#line 317 "nmp/essp_fp_instr.nmp"
#line 318 "nmp/essp_fp_instr.nmp"
#line 319 "nmp/essp_fp_instr.nmp"
#line 320 "nmp/essp_fp_instr.nmp"
#line 321 "nmp/essp_fp_instr.nmp"

#line 323 "nmp/essp_fp_instr.nmp"
#line 324 "nmp/essp_fp_instr.nmp"
#line 325 "nmp/essp_fp_instr.nmp"
#line 326 "nmp/essp_fp_instr.nmp"

//rounding mode
#line 329 "nmp/essp_fp_instr.nmp"
#line 330 "nmp/essp_fp_instr.nmp"
#line 331 "nmp/essp_fp_instr.nmp"

#line 343 "nmp/essp_fp_instr.nmp"
	
#line 363 "nmp/essp_fp_instr.nmp"
	
#line 368 "nmp/essp_fp_instr.nmp"
	
#line 382 "nmp/essp_fp_instr.nmp"

#line 384 "nmp/essp_fp_instr.nmp"


// ========================================================================= //
//  2. Instructions                                                          //
// ========================================================================= //

op essp_fp_instr ( x: essp_fp_instr_action )
	syntax = x.syntax
	image  = x.image
	action = {
		if MSR<MSR_FP..MSR_FP> then
			x.action;
		else
			"launch_exception"("instr",FP_UNAVAIL); //launch_exception extern function
		endif;
		}
	otawa_kind = x.otawa_kind
	
op essp_fp_instr_action =
	  efsabs
	| efsadd
	| efscfsf
	| efscfsi
	| efscfuf
	| efscfui
	| efscmpeq
	| efscmpgt
	| efscmplt
	| efsctsf
	| efsctsi
	| efsctsiz
	| efsctuf
	| efsctui
	| efsctuiz
	| efsdiv
	| efsmul
	| efsnabs
	| efsneg
	| efssub
	| efststeq
	| efststgt
	| efststlt
                    
op efsabs(rD: index, rA: index)
	syntax = format("efsabs r%d, r%d", rD, rA)
	image = format("000100 %5b %5b 00000 010 1100 0100", rD, rA)
	action = {
		GPR[rD] = (~GPR[rA]<31..31>) :: GPR[rA]<30..0>;
	}
                


op efsadd (rD: index, rA: index, rB: index)
   syntax = format("efsadd r%d, r%d, r%d", rD, rA, rB)
   image  = format("000100 %5b %5b %5b 010 1100 0000", rD, rA, rB)
   action = {
		TMP_FLOAT32_A<31..0> = GPR[rA];
        TMP_FLOAT32_B<31..0> = GPR[rB];

		if (TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> != 0)
#line 443 "nmp/essp_fp_instr.nmp"
#line 444 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 0 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0)
#line 444 "nmp/essp_fp_instr.nmp"
#line 445 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 1 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0) then 
#line 445 "nmp/essp_fp_instr.nmp"
#line 446 "nmp/essp_fp_instr.nmp"
		    if TMP_FLOAT32_A<31..31> == 0 then
#line 446 "nmp/essp_fp_instr.nmp"
#line 447 "nmp/essp_fp_instr.nmp"
				TMP_FLOT32<31..0> = FP_PMAX;
			else
				TMP_FLOT32<31..0> = FP_PMAX;
				TMP_FLOT32<31..31> = 1;
#line 450 "nmp/essp_fp_instr.nmp"
#line 451 "nmp/essp_fp_instr.nmp"
			endif;
		else 
			if (TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> != 0)
#line 453 "nmp/essp_fp_instr.nmp"
#line 454 "nmp/essp_fp_instr.nmp"
			|| (TMP_FLOAT32_B<31..31> == 0 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0)
#line 454 "nmp/essp_fp_instr.nmp"
#line 455 "nmp/essp_fp_instr.nmp"
			|| (TMP_FLOAT32_B<31..31> == 1 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0) then
#line 455 "nmp/essp_fp_instr.nmp"
#line 456 "nmp/essp_fp_instr.nmp"
				if TMP_FLOAT32_B<31..31> == 0 then
#line 456 "nmp/essp_fp_instr.nmp"
#line 457 "nmp/essp_fp_instr.nmp"
					TMP_FLOT32<31..0> = FP_PMAX;
				else
					TMP_FLOT32<31..0> = FP_PMAX;
					TMP_FLOT32<31..31> = 1;
#line 460 "nmp/essp_fp_instr.nmp"
#line 461 "nmp/essp_fp_instr.nmp"
				endif;
			else
				TMP_FLOAT32_D = TMP_FLOAT32_B + TMP_FLOAT32_B;
			endif;
		endif;
			
				if "fpi_testexcept"("FPI_INEXACT") then 
#line 467 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 467 "nmp/essp_fp_instr.nmp"
	endif; 
#line 467 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 467 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 467 "nmp/essp_fp_instr.nmp"
	endif; 
#line 467 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_INVALID") then 
#line 467 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 467 "nmp/essp_fp_instr.nmp"
	endif; 
#line 467 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 467 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FUNF..FP_FUNF> = 1; 
#line 467 "nmp/essp_fp_instr.nmp"
	endif; 
#line 467 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_INVALID") then 
#line 467 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 467 "nmp/essp_fp_instr.nmp"
	endif; 
#line 467 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 467 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FOVF..FP_FOVF> = 1; 
#line 467 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 467 "nmp/essp_fp_instr.nmp"
	if !(	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 467 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 467 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 467 "nmp/essp_fp_instr.nmp"
		GPR[rD] = TMP_FLOAT32_D<31..0>; 
#line 467 "nmp/essp_fp_instr.nmp"
	else 
#line 467 "nmp/essp_fp_instr.nmp"
		if((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) then 
#line 467 "nmp/essp_fp_instr.nmp"
			GPR[rD] = FP_PMAX; 
#line 467 "nmp/essp_fp_instr.nmp"
		else 
#line 467 "nmp/essp_fp_instr.nmp"
			if((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) then 
#line 467 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0; 
#line 467 "nmp/essp_fp_instr.nmp"
			endif; 
#line 467 "nmp/essp_fp_instr.nmp"
		endif; 
#line 467 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 467 "nmp/essp_fp_instr.nmp"
#line 468 "nmp/essp_fp_instr.nmp"
		 
		if 	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 469 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 469 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  then
#line 469 "nmp/essp_fp_instr.nmp"
#line 470 "nmp/essp_fp_instr.nmp"
			"launch_exception"("instr",PROGRAM);
		endif;
	}




op efscfsf(rD: index, rB: index)
	syntax = format("efscfsf r%d, r%d", rD, rB)
	image = format("000100 %5b 00000 %5b 010 1101 0011", rD, rB)
	action = {
			efs_v =  GPR[rB]; 
#line 481 "nmp/essp_fp_instr.nmp"
	efs_result<31..31> = 0; 
#line 481 "nmp/essp_fp_instr.nmp"
	if efs_v == 0 then 
#line 481 "nmp/essp_fp_instr.nmp"
		efs_result = 0; 
#line 481 "nmp/essp_fp_instr.nmp"
		if  EFS_LOWER == EFS_UPPER then 
#line 481 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FGH = 0; 
#line 481 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FXH = 0; 
#line 481 "nmp/essp_fp_instr.nmp"
		else 
#line 481 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FG = 0; 
#line 481 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FX = 0;	
#line 481 "nmp/essp_fp_instr.nmp"
		endif; 
#line 481 "nmp/essp_fp_instr.nmp"
	else 
#line 481 "nmp/essp_fp_instr.nmp"
		if  EFS_SIGN == EFS_SIGN then 
#line 481 "nmp/essp_fp_instr.nmp"
			if efs_v<31..31> == 1 then 
#line 481 "nmp/essp_fp_instr.nmp"
				efs_v = ~efs_v + 1; 
#line 481 "nmp/essp_fp_instr.nmp"
				efs_result<31..31> = 1; 
#line 481 "nmp/essp_fp_instr.nmp"
			endif; 
#line 481 "nmp/essp_fp_instr.nmp"
		endif; 
#line 481 "nmp/essp_fp_instr.nmp"
		if EFS_F == EFS_F then 
#line 481 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 127; 
#line 481 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_UNSIGN then 
#line 481 "nmp/essp_fp_instr.nmp"
				efs_maxexp = efs_maxexp - 1; 
#line 481 "nmp/essp_fp_instr.nmp"
			endif; 
#line 481 "nmp/essp_fp_instr.nmp"
		else 
#line 481 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 158; 
#line 481 "nmp/essp_fp_instr.nmp"
		endif; 
#line 481 "nmp/essp_fp_instr.nmp"
			efs_ml1 = 1<<16; 
#line 481 "nmp/essp_fp_instr.nmp"
	efs_pow = 8; 
#line 481 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 481 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 481 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 481 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1;  
#line 481 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 481 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 481 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 481 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 481 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif;; 
#line 481 "nmp/essp_fp_instr.nmp"
		efs_sc = 31 - efs_ml1; 
#line 481 "nmp/essp_fp_instr.nmp"
		efs_v = efs_v << efs_sc; 
#line 481 "nmp/essp_fp_instr.nmp"
		efs_result<30..23> = efs_maxexp - efs_sc; 
#line 481 "nmp/essp_fp_instr.nmp"
		efs_guard =  GPR[rB]<7..7>; 
#line 481 "nmp/essp_fp_instr.nmp"
		efs_sticky =  GPR[rB]<6..0> != 0; 
#line 481 "nmp/essp_fp_instr.nmp"
		if  EFS_LOWER == EFS_UPPER then 
#line 481 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FGH = efs_guard; 
#line 481 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FXH = efs_sticky; 
#line 481 "nmp/essp_fp_instr.nmp"
		else 
#line 481 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FG = efs_guard; 
#line 481 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FX = efs_sticky; 
#line 481 "nmp/essp_fp_instr.nmp"
		endif; 
#line 481 "nmp/essp_fp_instr.nmp"
		if efs_guard || efs_sticky then 
#line 481 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FINXS = 1; 
#line 481 "nmp/essp_fp_instr.nmp"
		endif; 
#line 481 "nmp/essp_fp_instr.nmp"
		efs_result<22..0> = efs_v<30..8>; 
#line 481 "nmp/essp_fp_instr.nmp"
			if SPEFSCR_FINXE == 0 then 
#line 481 "nmp/essp_fp_instr.nmp"
		if SPEFSCR_FRMC == 0b00 then 
#line 481 "nmp/essp_fp_instr.nmp"
			if  efs_guard then 
#line 481 "nmp/essp_fp_instr.nmp"
				if efs_sticky || efs_result<9..9> then 
#line 481 "nmp/essp_fp_instr.nmp"
					 efs_v<31..8> = efs_result<22..0> + 1; 
#line 481 "nmp/essp_fp_instr.nmp"
					if  efs_v<31..31> then 
#line 481 "nmp/essp_fp_instr.nmp"
						if efs_result<30..23> >= 254 then 
#line 481 "nmp/essp_fp_instr.nmp"
							efs_result = efs_result<31..31> :: 0b1111111011111111111111111111111; 
#line 481 "nmp/essp_fp_instr.nmp"
						else 
#line 481 "nmp/essp_fp_instr.nmp"
							efs_result<30..23> = efs_result<30..23> + 1; 
#line 481 "nmp/essp_fp_instr.nmp"
							efs_result<22..0> =  efs_v<30..8>; 
#line 481 "nmp/essp_fp_instr.nmp"
						endif; 
#line 481 "nmp/essp_fp_instr.nmp"
					else 
#line 481 "nmp/essp_fp_instr.nmp"
						efs_result<22..0> =  efs_v<30..8>;	
#line 481 "nmp/essp_fp_instr.nmp"
					endif; 
#line 481 "nmp/essp_fp_instr.nmp"
				endif; 
#line 481 "nmp/essp_fp_instr.nmp"
			endif; 
#line 481 "nmp/essp_fp_instr.nmp"
		else if (SPEFSCR_FRMC & 0b10) == 0b10 then 
#line 481 "nmp/essp_fp_instr.nmp"
		endif; endif; 
#line 481 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 481 "nmp/essp_fp_instr.nmp"
		GPR[rD] = efs_result; 
#line 481 "nmp/essp_fp_instr.nmp"
	endif;
#line 481 "nmp/essp_fp_instr.nmp"
#line 482 "nmp/essp_fp_instr.nmp"
	}


op efscfsi(rD: index, rB: index)
	syntax = format("efscfsi r%d, r%d", rD, rB)
	image = format("000100 %5b 00000 %5b 010 1101 0001", rD, rB)
	action = {
			efs_v =  GPR[rB]; 
#line 489 "nmp/essp_fp_instr.nmp"
	efs_result<31..31> = 0; 
#line 489 "nmp/essp_fp_instr.nmp"
	if efs_v == 0 then 
#line 489 "nmp/essp_fp_instr.nmp"
		efs_result = 0; 
#line 489 "nmp/essp_fp_instr.nmp"
		if  EFS_LOWER == EFS_UPPER then 
#line 489 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FGH = 0; 
#line 489 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FXH = 0; 
#line 489 "nmp/essp_fp_instr.nmp"
		else 
#line 489 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FG = 0; 
#line 489 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FX = 0;	
#line 489 "nmp/essp_fp_instr.nmp"
		endif; 
#line 489 "nmp/essp_fp_instr.nmp"
	else 
#line 489 "nmp/essp_fp_instr.nmp"
		if  EFS_SIGN == EFS_SIGN then 
#line 489 "nmp/essp_fp_instr.nmp"
			if efs_v<31..31> == 1 then 
#line 489 "nmp/essp_fp_instr.nmp"
				efs_v = ~efs_v + 1; 
#line 489 "nmp/essp_fp_instr.nmp"
				efs_result<31..31> = 1; 
#line 489 "nmp/essp_fp_instr.nmp"
			endif; 
#line 489 "nmp/essp_fp_instr.nmp"
		endif; 
#line 489 "nmp/essp_fp_instr.nmp"
		if EFS_I == EFS_F then 
#line 489 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 127; 
#line 489 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_UNSIGN then 
#line 489 "nmp/essp_fp_instr.nmp"
				efs_maxexp = efs_maxexp - 1; 
#line 489 "nmp/essp_fp_instr.nmp"
			endif; 
#line 489 "nmp/essp_fp_instr.nmp"
		else 
#line 489 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 158; 
#line 489 "nmp/essp_fp_instr.nmp"
		endif; 
#line 489 "nmp/essp_fp_instr.nmp"
			efs_ml1 = 1<<16; 
#line 489 "nmp/essp_fp_instr.nmp"
	efs_pow = 8; 
#line 489 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 489 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 489 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 489 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1;  
#line 489 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 489 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 489 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 489 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 489 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif;; 
#line 489 "nmp/essp_fp_instr.nmp"
		efs_sc = 31 - efs_ml1; 
#line 489 "nmp/essp_fp_instr.nmp"
		efs_v = efs_v << efs_sc; 
#line 489 "nmp/essp_fp_instr.nmp"
		efs_result<30..23> = efs_maxexp - efs_sc; 
#line 489 "nmp/essp_fp_instr.nmp"
		efs_guard =  GPR[rB]<7..7>; 
#line 489 "nmp/essp_fp_instr.nmp"
		efs_sticky =  GPR[rB]<6..0> != 0; 
#line 489 "nmp/essp_fp_instr.nmp"
		if  EFS_LOWER == EFS_UPPER then 
#line 489 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FGH = efs_guard; 
#line 489 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FXH = efs_sticky; 
#line 489 "nmp/essp_fp_instr.nmp"
		else 
#line 489 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FG = efs_guard; 
#line 489 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FX = efs_sticky; 
#line 489 "nmp/essp_fp_instr.nmp"
		endif; 
#line 489 "nmp/essp_fp_instr.nmp"
		if efs_guard || efs_sticky then 
#line 489 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FINXS = 1; 
#line 489 "nmp/essp_fp_instr.nmp"
		endif; 
#line 489 "nmp/essp_fp_instr.nmp"
		efs_result<22..0> = efs_v<30..8>; 
#line 489 "nmp/essp_fp_instr.nmp"
			if SPEFSCR_FINXE == 0 then 
#line 489 "nmp/essp_fp_instr.nmp"
		if SPEFSCR_FRMC == 0b00 then 
#line 489 "nmp/essp_fp_instr.nmp"
			if  efs_guard then 
#line 489 "nmp/essp_fp_instr.nmp"
				if efs_sticky || efs_result<9..9> then 
#line 489 "nmp/essp_fp_instr.nmp"
					 efs_v<31..8> = efs_result<22..0> + 1; 
#line 489 "nmp/essp_fp_instr.nmp"
					if  efs_v<31..31> then 
#line 489 "nmp/essp_fp_instr.nmp"
						if efs_result<30..23> >= 254 then 
#line 489 "nmp/essp_fp_instr.nmp"
							efs_result = efs_result<31..31> :: 0b1111111011111111111111111111111; 
#line 489 "nmp/essp_fp_instr.nmp"
						else 
#line 489 "nmp/essp_fp_instr.nmp"
							efs_result<30..23> = efs_result<30..23> + 1; 
#line 489 "nmp/essp_fp_instr.nmp"
							efs_result<22..0> =  efs_v<30..8>; 
#line 489 "nmp/essp_fp_instr.nmp"
						endif; 
#line 489 "nmp/essp_fp_instr.nmp"
					else 
#line 489 "nmp/essp_fp_instr.nmp"
						efs_result<22..0> =  efs_v<30..8>;	
#line 489 "nmp/essp_fp_instr.nmp"
					endif; 
#line 489 "nmp/essp_fp_instr.nmp"
				endif; 
#line 489 "nmp/essp_fp_instr.nmp"
			endif; 
#line 489 "nmp/essp_fp_instr.nmp"
		else if (SPEFSCR_FRMC & 0b10) == 0b10 then 
#line 489 "nmp/essp_fp_instr.nmp"
		endif; endif; 
#line 489 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 489 "nmp/essp_fp_instr.nmp"
		GPR[rD] = efs_result; 
#line 489 "nmp/essp_fp_instr.nmp"
	endif;
#line 489 "nmp/essp_fp_instr.nmp"
#line 490 "nmp/essp_fp_instr.nmp"
	}


op efscfuf(rD: index, rB: index)
	syntax = format("efscfuf r%d, r%d", rD, rB)
	image  = format("000100 %5b 00000 %5b 010 1101 0010", rD, rB)
	action = {
			efs_v =  GPR[rB]; 
#line 497 "nmp/essp_fp_instr.nmp"
	efs_result<31..31> = 0; 
#line 497 "nmp/essp_fp_instr.nmp"
	if efs_v == 0 then 
#line 497 "nmp/essp_fp_instr.nmp"
		efs_result = 0; 
#line 497 "nmp/essp_fp_instr.nmp"
		if  EFS_LOWER == EFS_UPPER then 
#line 497 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FGH = 0; 
#line 497 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FXH = 0; 
#line 497 "nmp/essp_fp_instr.nmp"
		else 
#line 497 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FG = 0; 
#line 497 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FX = 0;	
#line 497 "nmp/essp_fp_instr.nmp"
		endif; 
#line 497 "nmp/essp_fp_instr.nmp"
	else 
#line 497 "nmp/essp_fp_instr.nmp"
		if  EFS_UNSIGN == EFS_SIGN then 
#line 497 "nmp/essp_fp_instr.nmp"
			if efs_v<31..31> == 1 then 
#line 497 "nmp/essp_fp_instr.nmp"
				efs_v = ~efs_v + 1; 
#line 497 "nmp/essp_fp_instr.nmp"
				efs_result<31..31> = 1; 
#line 497 "nmp/essp_fp_instr.nmp"
			endif; 
#line 497 "nmp/essp_fp_instr.nmp"
		endif; 
#line 497 "nmp/essp_fp_instr.nmp"
		if EFS_F == EFS_F then 
#line 497 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 127; 
#line 497 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_UNSIGN then 
#line 497 "nmp/essp_fp_instr.nmp"
				efs_maxexp = efs_maxexp - 1; 
#line 497 "nmp/essp_fp_instr.nmp"
			endif; 
#line 497 "nmp/essp_fp_instr.nmp"
		else 
#line 497 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 158; 
#line 497 "nmp/essp_fp_instr.nmp"
		endif; 
#line 497 "nmp/essp_fp_instr.nmp"
			efs_ml1 = 1<<16; 
#line 497 "nmp/essp_fp_instr.nmp"
	efs_pow = 8; 
#line 497 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 497 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 497 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 497 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1;  
#line 497 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 497 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 497 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 497 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 497 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif;; 
#line 497 "nmp/essp_fp_instr.nmp"
		efs_sc = 31 - efs_ml1; 
#line 497 "nmp/essp_fp_instr.nmp"
		efs_v = efs_v << efs_sc; 
#line 497 "nmp/essp_fp_instr.nmp"
		efs_result<30..23> = efs_maxexp - efs_sc; 
#line 497 "nmp/essp_fp_instr.nmp"
		efs_guard =  GPR[rB]<7..7>; 
#line 497 "nmp/essp_fp_instr.nmp"
		efs_sticky =  GPR[rB]<6..0> != 0; 
#line 497 "nmp/essp_fp_instr.nmp"
		if  EFS_LOWER == EFS_UPPER then 
#line 497 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FGH = efs_guard; 
#line 497 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FXH = efs_sticky; 
#line 497 "nmp/essp_fp_instr.nmp"
		else 
#line 497 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FG = efs_guard; 
#line 497 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FX = efs_sticky; 
#line 497 "nmp/essp_fp_instr.nmp"
		endif; 
#line 497 "nmp/essp_fp_instr.nmp"
		if efs_guard || efs_sticky then 
#line 497 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FINXS = 1; 
#line 497 "nmp/essp_fp_instr.nmp"
		endif; 
#line 497 "nmp/essp_fp_instr.nmp"
		efs_result<22..0> = efs_v<30..8>; 
#line 497 "nmp/essp_fp_instr.nmp"
			if SPEFSCR_FINXE == 0 then 
#line 497 "nmp/essp_fp_instr.nmp"
		if SPEFSCR_FRMC == 0b00 then 
#line 497 "nmp/essp_fp_instr.nmp"
			if  efs_guard then 
#line 497 "nmp/essp_fp_instr.nmp"
				if efs_sticky || efs_result<9..9> then 
#line 497 "nmp/essp_fp_instr.nmp"
					 efs_v<31..8> = efs_result<22..0> + 1; 
#line 497 "nmp/essp_fp_instr.nmp"
					if  efs_v<31..31> then 
#line 497 "nmp/essp_fp_instr.nmp"
						if efs_result<30..23> >= 254 then 
#line 497 "nmp/essp_fp_instr.nmp"
							efs_result = efs_result<31..31> :: 0b1111111011111111111111111111111; 
#line 497 "nmp/essp_fp_instr.nmp"
						else 
#line 497 "nmp/essp_fp_instr.nmp"
							efs_result<30..23> = efs_result<30..23> + 1; 
#line 497 "nmp/essp_fp_instr.nmp"
							efs_result<22..0> =  efs_v<30..8>; 
#line 497 "nmp/essp_fp_instr.nmp"
						endif; 
#line 497 "nmp/essp_fp_instr.nmp"
					else 
#line 497 "nmp/essp_fp_instr.nmp"
						efs_result<22..0> =  efs_v<30..8>;	
#line 497 "nmp/essp_fp_instr.nmp"
					endif; 
#line 497 "nmp/essp_fp_instr.nmp"
				endif; 
#line 497 "nmp/essp_fp_instr.nmp"
			endif; 
#line 497 "nmp/essp_fp_instr.nmp"
		else if (SPEFSCR_FRMC & 0b10) == 0b10 then 
#line 497 "nmp/essp_fp_instr.nmp"
		endif; endif; 
#line 497 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 497 "nmp/essp_fp_instr.nmp"
		GPR[rD] = efs_result; 
#line 497 "nmp/essp_fp_instr.nmp"
	endif;
#line 497 "nmp/essp_fp_instr.nmp"
#line 498 "nmp/essp_fp_instr.nmp"
	}

op efscfui (rD: index, rB: index )
   syntax = format("efscfui r%d,r%d", rD, rB)
   image  = format("000100 %5b 00000 %5b 0101 1010 000", rD, rB)
   action = {
			efs_v =  GPR[rB]; 
#line 504 "nmp/essp_fp_instr.nmp"
	efs_result<31..31> = 0; 
#line 504 "nmp/essp_fp_instr.nmp"
	if efs_v == 0 then 
#line 504 "nmp/essp_fp_instr.nmp"
		efs_result = 0; 
#line 504 "nmp/essp_fp_instr.nmp"
		if  EFS_LOWER == EFS_UPPER then 
#line 504 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FGH = 0; 
#line 504 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FXH = 0; 
#line 504 "nmp/essp_fp_instr.nmp"
		else 
#line 504 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FG = 0; 
#line 504 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FX = 0;	
#line 504 "nmp/essp_fp_instr.nmp"
		endif; 
#line 504 "nmp/essp_fp_instr.nmp"
	else 
#line 504 "nmp/essp_fp_instr.nmp"
		if  EFS_UNSIGN == EFS_SIGN then 
#line 504 "nmp/essp_fp_instr.nmp"
			if efs_v<31..31> == 1 then 
#line 504 "nmp/essp_fp_instr.nmp"
				efs_v = ~efs_v + 1; 
#line 504 "nmp/essp_fp_instr.nmp"
				efs_result<31..31> = 1; 
#line 504 "nmp/essp_fp_instr.nmp"
			endif; 
#line 504 "nmp/essp_fp_instr.nmp"
		endif; 
#line 504 "nmp/essp_fp_instr.nmp"
		if EFS_I == EFS_F then 
#line 504 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 127; 
#line 504 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_UNSIGN then 
#line 504 "nmp/essp_fp_instr.nmp"
				efs_maxexp = efs_maxexp - 1; 
#line 504 "nmp/essp_fp_instr.nmp"
			endif; 
#line 504 "nmp/essp_fp_instr.nmp"
		else 
#line 504 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 158; 
#line 504 "nmp/essp_fp_instr.nmp"
		endif; 
#line 504 "nmp/essp_fp_instr.nmp"
			efs_ml1 = 1<<16; 
#line 504 "nmp/essp_fp_instr.nmp"
	efs_pow = 8; 
#line 504 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 504 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 504 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 504 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1;  
#line 504 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 504 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 504 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif; 
#line 504 "nmp/essp_fp_instr.nmp"
	efs_pow = efs_pow >> 1; 
#line 504 "nmp/essp_fp_instr.nmp"
	if efs_ml1 > GPR[efs_v] then efs_ml1 = efs_ml1 >> efs_pow; else efs_ml1 = efs_ml1 << efs_pow; endif;; 
#line 504 "nmp/essp_fp_instr.nmp"
		efs_sc = 31 - efs_ml1; 
#line 504 "nmp/essp_fp_instr.nmp"
		efs_v = efs_v << efs_sc; 
#line 504 "nmp/essp_fp_instr.nmp"
		efs_result<30..23> = efs_maxexp - efs_sc; 
#line 504 "nmp/essp_fp_instr.nmp"
		efs_guard =  GPR[rB]<7..7>; 
#line 504 "nmp/essp_fp_instr.nmp"
		efs_sticky =  GPR[rB]<6..0> != 0; 
#line 504 "nmp/essp_fp_instr.nmp"
		if  EFS_LOWER == EFS_UPPER then 
#line 504 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FGH = efs_guard; 
#line 504 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FXH = efs_sticky; 
#line 504 "nmp/essp_fp_instr.nmp"
		else 
#line 504 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FG = efs_guard; 
#line 504 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FX = efs_sticky; 
#line 504 "nmp/essp_fp_instr.nmp"
		endif; 
#line 504 "nmp/essp_fp_instr.nmp"
		if efs_guard || efs_sticky then 
#line 504 "nmp/essp_fp_instr.nmp"
			SPEFSCR_FINXS = 1; 
#line 504 "nmp/essp_fp_instr.nmp"
		endif; 
#line 504 "nmp/essp_fp_instr.nmp"
		efs_result<22..0> = efs_v<30..8>; 
#line 504 "nmp/essp_fp_instr.nmp"
			if SPEFSCR_FINXE == 0 then 
#line 504 "nmp/essp_fp_instr.nmp"
		if SPEFSCR_FRMC == 0b00 then 
#line 504 "nmp/essp_fp_instr.nmp"
			if  efs_guard then 
#line 504 "nmp/essp_fp_instr.nmp"
				if efs_sticky || efs_result<9..9> then 
#line 504 "nmp/essp_fp_instr.nmp"
					 efs_v<31..8> = efs_result<22..0> + 1; 
#line 504 "nmp/essp_fp_instr.nmp"
					if  efs_v<31..31> then 
#line 504 "nmp/essp_fp_instr.nmp"
						if efs_result<30..23> >= 254 then 
#line 504 "nmp/essp_fp_instr.nmp"
							efs_result = efs_result<31..31> :: 0b1111111011111111111111111111111; 
#line 504 "nmp/essp_fp_instr.nmp"
						else 
#line 504 "nmp/essp_fp_instr.nmp"
							efs_result<30..23> = efs_result<30..23> + 1; 
#line 504 "nmp/essp_fp_instr.nmp"
							efs_result<22..0> =  efs_v<30..8>; 
#line 504 "nmp/essp_fp_instr.nmp"
						endif; 
#line 504 "nmp/essp_fp_instr.nmp"
					else 
#line 504 "nmp/essp_fp_instr.nmp"
						efs_result<22..0> =  efs_v<30..8>;	
#line 504 "nmp/essp_fp_instr.nmp"
					endif; 
#line 504 "nmp/essp_fp_instr.nmp"
				endif; 
#line 504 "nmp/essp_fp_instr.nmp"
			endif; 
#line 504 "nmp/essp_fp_instr.nmp"
		else if (SPEFSCR_FRMC & 0b10) == 0b10 then 
#line 504 "nmp/essp_fp_instr.nmp"
		endif; endif; 
#line 504 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 504 "nmp/essp_fp_instr.nmp"
		GPR[rD] = efs_result; 
#line 504 "nmp/essp_fp_instr.nmp"
	endif;
#line 504 "nmp/essp_fp_instr.nmp"
#line 505 "nmp/essp_fp_instr.nmp"
   }
   
   
op efscmpeq(crD: card(3), rA: index, rB: index)
   syntax = format ("efscmpeq cr%d, r%d, r%d", crD, rA, rB)
   image  = format ("000100 %3b 00 %5b %5b 010 1100 1110", crD, rA, rB)
   action = {
		TMP_FLOAT32_A<31..0> = GPR[rA];
        TMP_FLOAT32_B<31..0> = GPR[rB];
        if TMP_FLOAT32_A == TMP_FLOAT32_B then
			TMP_BYTE = 0b0100;
		else
			TMP_BYTE = 0b0000;
        endif;
        CR[7 - crD] = TMP_BYTE<3..0>;
		if (TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> != 0)
#line 520 "nmp/essp_fp_instr.nmp"
#line 521 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 0 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0)
#line 521 "nmp/essp_fp_instr.nmp"
#line 522 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 1 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0)
#line 522 "nmp/essp_fp_instr.nmp"
#line 523 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 1 && TMP_FLOAT32_A<30..23> == 0 && TMP_FLOAT32_A<22..0> != 0)
#line 523 "nmp/essp_fp_instr.nmp"
#line 524 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 0 && TMP_FLOAT32_A<30..23> == 0 && TMP_FLOAT32_A<22..0> != 0)
#line 524 "nmp/essp_fp_instr.nmp"
#line 525 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> != 0)
#line 525 "nmp/essp_fp_instr.nmp"
#line 526 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 0 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0)
#line 526 "nmp/essp_fp_instr.nmp"
#line 527 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 1 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0)
#line 527 "nmp/essp_fp_instr.nmp"
#line 528 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 1 && TMP_FLOAT32_B<30..23> == 0 && TMP_FLOAT32_B<22..0> != 0)
#line 528 "nmp/essp_fp_instr.nmp"
#line 529 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 0 && TMP_FLOAT32_B<30..23> == 0 && TMP_FLOAT32_B<22..0> != 0) then
#line 529 "nmp/essp_fp_instr.nmp"
#line 530 "nmp/essp_fp_instr.nmp"
			SPEFSCR <FP_FINV..FP_FINV> = 1;
#line 530 "nmp/essp_fp_instr.nmp"
#line 531 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FGH..FP_FGH> = 0;
#line 531 "nmp/essp_fp_instr.nmp"
#line 532 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FXH..FP_FXH> = 0;
#line 532 "nmp/essp_fp_instr.nmp"
#line 533 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FG..FP_FG> = 0;
#line 533 "nmp/essp_fp_instr.nmp"
#line 534 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FX..FP_FX> = 0;
#line 534 "nmp/essp_fp_instr.nmp"
#line 535 "nmp/essp_fp_instr.nmp"
		endif;
		if 	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 536 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 536 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  then
#line 536 "nmp/essp_fp_instr.nmp"
#line 537 "nmp/essp_fp_instr.nmp"
			"launch_exception"("instr",PROGRAM);
		endif;
	}
		
op efscmpgt(crD: card(3), rA: index, rB: index)
   syntax = format("efscmpgt cr%d, r%d, r%d", crD, rA, rB)
   image  = format("000100 %3b 00 %5b %5b 010 1100 1100", crD, rA, rB)
   action = {
		TMP_FLOAT32_A<31..0> = GPR[rA];
        TMP_FLOAT32_B<31..0> = GPR[rB];
        if TMP_FLOAT32_A > TMP_FLOAT32_B then
			TMP_BYTE = 0b0100;
		else
			TMP_BYTE = 0b0000;
        endif;
        CR[7 - crD] = TMP_BYTE <3..0>;
		//FP_UPDATE_FLAGS; 
		if (TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> != 0)
#line 554 "nmp/essp_fp_instr.nmp"
#line 555 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 0 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0)
#line 555 "nmp/essp_fp_instr.nmp"
#line 556 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 1 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0)
#line 556 "nmp/essp_fp_instr.nmp"
#line 557 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 1 && TMP_FLOAT32_A<30..23> == 0 && TMP_FLOAT32_A<22..0> != 0)
#line 557 "nmp/essp_fp_instr.nmp"
#line 558 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 0 && TMP_FLOAT32_A<30..23> == 0 && TMP_FLOAT32_A<22..0> != 0)
#line 558 "nmp/essp_fp_instr.nmp"
#line 559 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> != 0)
#line 559 "nmp/essp_fp_instr.nmp"
#line 560 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 0 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0)
#line 560 "nmp/essp_fp_instr.nmp"
#line 561 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 1 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0)
#line 561 "nmp/essp_fp_instr.nmp"
#line 562 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 1 && TMP_FLOAT32_B<30..23> == 0 && TMP_FLOAT32_B<22..0> != 0)
#line 562 "nmp/essp_fp_instr.nmp"
#line 563 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 0 && TMP_FLOAT32_B<30..23> == 0 && TMP_FLOAT32_B<22..0> != 0) then
#line 563 "nmp/essp_fp_instr.nmp"
#line 564 "nmp/essp_fp_instr.nmp"
			SPEFSCR <FP_FINV..FP_FINV> = 1;
#line 564 "nmp/essp_fp_instr.nmp"
#line 565 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FGH..FP_FGH> = 0;
#line 565 "nmp/essp_fp_instr.nmp"
#line 566 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FXH..FP_FXH> = 0;
#line 566 "nmp/essp_fp_instr.nmp"
#line 567 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FG..FP_FG> = 0;
#line 567 "nmp/essp_fp_instr.nmp"
#line 568 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FX..FP_FX> = 0;
#line 568 "nmp/essp_fp_instr.nmp"
#line 569 "nmp/essp_fp_instr.nmp"
		endif;
		if 	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 570 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 570 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  then
#line 570 "nmp/essp_fp_instr.nmp"
#line 571 "nmp/essp_fp_instr.nmp"
			"launch_exception"("instr",PROGRAM);
		endif;
	}


op efscmplt(crD: card(3), rA: index, rB: index )
   syntax = format("efscmplt cr%d, r%d, r%d", crD, rA, rB )
   image  = format("000100 %3b 00 %5b %5b 010 1100 1101", crD, rA, rB)
   action = {
		TMP_FLOAT32_A<31..0> = GPR[rA];
        TMP_FLOAT32_B<31..0> = GPR[rB];
        if TMP_FLOAT32_A < TMP_FLOAT32_B then
			TMP_BYTE = 0b0100;
		else
			TMP_BYTE = 0b0000;
        endif;
        CR[7 - crD] = TMP_BYTE <3..0>;
		if (TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> != 0)
#line 588 "nmp/essp_fp_instr.nmp"
#line 589 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 0 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0)
#line 589 "nmp/essp_fp_instr.nmp"
#line 590 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 1 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0)
#line 590 "nmp/essp_fp_instr.nmp"
#line 591 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 1 && TMP_FLOAT32_A<30..23> == 0 && TMP_FLOAT32_A<22..0> != 0)
#line 591 "nmp/essp_fp_instr.nmp"
#line 592 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_A<31..31> == 0 && TMP_FLOAT32_A<30..23> == 0 && TMP_FLOAT32_A<22..0> != 0)
#line 592 "nmp/essp_fp_instr.nmp"
#line 593 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> != 0)
#line 593 "nmp/essp_fp_instr.nmp"
#line 594 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 0 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0)
#line 594 "nmp/essp_fp_instr.nmp"
#line 595 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 1 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0)
#line 595 "nmp/essp_fp_instr.nmp"
#line 596 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 1 && TMP_FLOAT32_B<30..23> == 0 && TMP_FLOAT32_B<22..0> != 0)
#line 596 "nmp/essp_fp_instr.nmp"
#line 597 "nmp/essp_fp_instr.nmp"
		|| (TMP_FLOAT32_B<31..31> == 0 && TMP_FLOAT32_B<30..23> == 0 && TMP_FLOAT32_B<22..0> != 0) then
#line 597 "nmp/essp_fp_instr.nmp"
#line 598 "nmp/essp_fp_instr.nmp"
			SPEFSCR <FP_FINV..FP_FINV> = 1;
#line 598 "nmp/essp_fp_instr.nmp"
#line 599 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FGH..FP_FGH> = 0;
#line 599 "nmp/essp_fp_instr.nmp"
#line 600 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FXH..FP_FXH> = 0;
#line 600 "nmp/essp_fp_instr.nmp"
#line 601 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FG..FP_FG> = 0;
#line 601 "nmp/essp_fp_instr.nmp"
#line 602 "nmp/essp_fp_instr.nmp"
			SPEFSCR<FP_FX..FP_FX> = 0;
#line 602 "nmp/essp_fp_instr.nmp"
#line 603 "nmp/essp_fp_instr.nmp"
		endif;
		if 	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 604 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 604 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  then
#line 604 "nmp/essp_fp_instr.nmp"
#line 605 "nmp/essp_fp_instr.nmp"
			"launch_exception"("instr",PROGRAM);
		endif;
	}


op efsctsf(rD: index, rB: index)
	syntax = format("efsctsf r%d, r%d", rD, rB)
	image  = format("000100 %5b 00000 %5b 010 1101 0111", rD, rB)
	action = {
			if (GPR[rB]<30..23> == 255) then 
#line 614 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 614 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 614 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 614 "nmp/essp_fp_instr.nmp"
	endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 614 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 614 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 614 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 614 "nmp/essp_fp_instr.nmp"
	endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 614 "nmp/essp_fp_instr.nmp"
		if (GPR[rB]<30..23> == 255 && GPR[rB]<22..0> != 0) then 
#line 614 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0x00000000; 
#line 614 "nmp/essp_fp_instr.nmp"
		else if  EFS_SIGN == EFS_SIGN then 
#line 614 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 614 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x80000000; 
#line 614 "nmp/essp_fp_instr.nmp"
			else 
#line 614 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
		else 
#line 614 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 614 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x00000000; 
#line 614 "nmp/essp_fp_instr.nmp"
			else 
#line 614 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0xffffffff; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
		endif; endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	else if (GPR[rB]<30..23> == 0 && GPR[rB]<22..0> != 0)  then 
#line 614 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 614 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 614 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 614 "nmp/essp_fp_instr.nmp"
	endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 614 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 614 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 614 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 614 "nmp/essp_fp_instr.nmp"
	endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 614 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 614 "nmp/essp_fp_instr.nmp"
	else if  EFS_SIGN == EFS_UNSIGN && GPR[rB]<31..31> == 1 then 
#line 614 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FOVF; 
#line 614 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 614 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 614 "nmp/essp_fp_instr.nmp"
	endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 614 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 614 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 614 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 614 "nmp/essp_fp_instr.nmp"
	endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 614 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 614 "nmp/essp_fp_instr.nmp"
	else if GPR[rB]<30..23> == 0 && GPR[rB]<22..0> == 0 then 
#line 614 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 614 "nmp/essp_fp_instr.nmp"
	else 
#line 614 "nmp/essp_fp_instr.nmp"
	
#line 614 "nmp/essp_fp_instr.nmp"
		if EFS_F == EFS_I then 
#line 614 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 158; 
#line 614 "nmp/essp_fp_instr.nmp"
			efs_shift = 158 - GPR[rB]<30..23>; 
#line 614 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 614 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<30..23> != 158 
#line 614 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<22..0> != 0 
#line 614 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<31..31> != 1 then 
#line 614 "nmp/essp_fp_instr.nmp"
					efs_maxexp = efs_maxexp - 1; 
#line 614 "nmp/essp_fp_instr.nmp"
				endif; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
		else 
#line 614 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 126; 
#line 614 "nmp/essp_fp_instr.nmp"
			efs_shift = efs_maxexp - GPR[rB]<30..23>; 
#line 614 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 1; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
		endif; 
#line 614 "nmp/essp_fp_instr.nmp"
		
#line 614 "nmp/essp_fp_instr.nmp"
		if GPR[rB]<30..23> > efs_maxexp then 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_bits = FP_FOVF; 
#line 614 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 614 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 614 "nmp/essp_fp_instr.nmp"
	endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 614 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 614 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 614 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 614 "nmp/essp_fp_instr.nmp"
	endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 614 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 614 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then 
#line 614 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x80000000; 
#line 614 "nmp/essp_fp_instr.nmp"
				else 
#line 614 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x7fffffff; 
#line 614 "nmp/essp_fp_instr.nmp"
				endif; 
#line 614 "nmp/essp_fp_instr.nmp"
			else 
#line 614 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
		else 
#line 614 "nmp/essp_fp_instr.nmp"
		
#line 614 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0b1 :: GPR[rB]<22..0> :: 0b00000000; 
#line 614 "nmp/essp_fp_instr.nmp"
			efs_guard = 0; 
#line 614 "nmp/essp_fp_instr.nmp"
			efs_sticky = 0; 
#line 614 "nmp/essp_fp_instr.nmp"
		
#line 614 "nmp/essp_fp_instr.nmp"
			efs_guard = GPR[rD]<efs_shift -1 .. efs_shift -1>; 
#line 614 "nmp/essp_fp_instr.nmp"
			if efs_shift > 16 then 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<15..0> != 0); 
#line 614 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 16; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
			if efs_shift > 8 then 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<7..0> != 0); 
#line 614 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 8; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
			if efs_shift > 4 then 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<3..0> != 0); 
#line 614 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 4; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
			if efs_shift > 2 then 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<1..0> != 0); 
#line 614 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 2; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
			if efs_shift > 1 then 
#line 614 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<0..0> != 0); 
#line 614 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	
#line 614 "nmp/essp_fp_instr.nmp"
			if  EFS_LOWER == EFS_UPPER then 
#line 614 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FGH = efs_guard; 
#line 614 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FXH = efs_sticky; 
#line 614 "nmp/essp_fp_instr.nmp"
			else 
#line 614 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FG = efs_guard; 
#line 614 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FX = efs_sticky; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
			if efs_guard || efs_sticky then 
#line 614 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FINXS = 1; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	
#line 614 "nmp/essp_fp_instr.nmp"
			if  EFS_ROUND == EFS_ROUND && SPEFSCR_FINXE == 0 then 
#line 614 "nmp/essp_fp_instr.nmp"
				if SPEFSCR_FRMC == 0b00 then 
#line 614 "nmp/essp_fp_instr.nmp"
					if efs_guard then 
#line 614 "nmp/essp_fp_instr.nmp"
						if efs_sticky | (GPR[rD] & 0x00000001) then 
#line 614 "nmp/essp_fp_instr.nmp"
							GPR[rD] = GPR[rD] + 1; 
#line 614 "nmp/essp_fp_instr.nmp"
						endif; 
#line 614 "nmp/essp_fp_instr.nmp"
					endif; 
#line 614 "nmp/essp_fp_instr.nmp"
				else if (SPEFSCR_FRMC & 0b10) == 0b10 then 
#line 614 "nmp/essp_fp_instr.nmp"
				endif; endif; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	
#line 614 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 614 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then  
#line 614 "nmp/essp_fp_instr.nmp"
					GPR[rD] = ~GPR[rD] + 1; 
#line 614 "nmp/essp_fp_instr.nmp"
				endif; 
#line 614 "nmp/essp_fp_instr.nmp"
			endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	
#line 614 "nmp/essp_fp_instr.nmp"
		endif; 
#line 614 "nmp/essp_fp_instr.nmp"
	endif; endif; endif; endif;;
#line 614 "nmp/essp_fp_instr.nmp"
#line 615 "nmp/essp_fp_instr.nmp"
	}


op efsctsi(rD: index, rB: index)
	syntax = format("efsctsi r%d, r%d", rD, rB)
	image  = format("000100 %5b 00000 %5b 010 1101 0101", rD, rB)
	action = {
			if (GPR[rB]<30..23> == 255) then 
#line 622 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 622 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 622 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 622 "nmp/essp_fp_instr.nmp"
	endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 622 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 622 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 622 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 622 "nmp/essp_fp_instr.nmp"
	endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 622 "nmp/essp_fp_instr.nmp"
		if (GPR[rB]<30..23> == 255 && GPR[rB]<22..0> != 0) then 
#line 622 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0x00000000; 
#line 622 "nmp/essp_fp_instr.nmp"
		else if  EFS_SIGN == EFS_SIGN then 
#line 622 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 622 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x80000000; 
#line 622 "nmp/essp_fp_instr.nmp"
			else 
#line 622 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
		else 
#line 622 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 622 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x00000000; 
#line 622 "nmp/essp_fp_instr.nmp"
			else 
#line 622 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0xffffffff; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
		endif; endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	else if (GPR[rB]<30..23> == 0 && GPR[rB]<22..0> != 0)  then 
#line 622 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 622 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 622 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 622 "nmp/essp_fp_instr.nmp"
	endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 622 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 622 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 622 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 622 "nmp/essp_fp_instr.nmp"
	endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 622 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 622 "nmp/essp_fp_instr.nmp"
	else if  EFS_SIGN == EFS_UNSIGN && GPR[rB]<31..31> == 1 then 
#line 622 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FOVF; 
#line 622 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 622 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 622 "nmp/essp_fp_instr.nmp"
	endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 622 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 622 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 622 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 622 "nmp/essp_fp_instr.nmp"
	endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 622 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 622 "nmp/essp_fp_instr.nmp"
	else if GPR[rB]<30..23> == 0 && GPR[rB]<22..0> == 0 then 
#line 622 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 622 "nmp/essp_fp_instr.nmp"
	else 
#line 622 "nmp/essp_fp_instr.nmp"
	
#line 622 "nmp/essp_fp_instr.nmp"
		if EFS_I == EFS_I then 
#line 622 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 158; 
#line 622 "nmp/essp_fp_instr.nmp"
			efs_shift = 158 - GPR[rB]<30..23>; 
#line 622 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 622 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<30..23> != 158 
#line 622 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<22..0> != 0 
#line 622 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<31..31> != 1 then 
#line 622 "nmp/essp_fp_instr.nmp"
					efs_maxexp = efs_maxexp - 1; 
#line 622 "nmp/essp_fp_instr.nmp"
				endif; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
		else 
#line 622 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 126; 
#line 622 "nmp/essp_fp_instr.nmp"
			efs_shift = efs_maxexp - GPR[rB]<30..23>; 
#line 622 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 1; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
		endif; 
#line 622 "nmp/essp_fp_instr.nmp"
		
#line 622 "nmp/essp_fp_instr.nmp"
		if GPR[rB]<30..23> > efs_maxexp then 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_bits = FP_FOVF; 
#line 622 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 622 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 622 "nmp/essp_fp_instr.nmp"
	endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 622 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 622 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 622 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 622 "nmp/essp_fp_instr.nmp"
	endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 622 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 622 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then 
#line 622 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x80000000; 
#line 622 "nmp/essp_fp_instr.nmp"
				else 
#line 622 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x7fffffff; 
#line 622 "nmp/essp_fp_instr.nmp"
				endif; 
#line 622 "nmp/essp_fp_instr.nmp"
			else 
#line 622 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
		else 
#line 622 "nmp/essp_fp_instr.nmp"
		
#line 622 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0b1 :: GPR[rB]<22..0> :: 0b00000000; 
#line 622 "nmp/essp_fp_instr.nmp"
			efs_guard = 0; 
#line 622 "nmp/essp_fp_instr.nmp"
			efs_sticky = 0; 
#line 622 "nmp/essp_fp_instr.nmp"
		
#line 622 "nmp/essp_fp_instr.nmp"
			efs_guard = GPR[rD]<efs_shift -1 .. efs_shift -1>; 
#line 622 "nmp/essp_fp_instr.nmp"
			if efs_shift > 16 then 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<15..0> != 0); 
#line 622 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 16; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
			if efs_shift > 8 then 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<7..0> != 0); 
#line 622 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 8; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
			if efs_shift > 4 then 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<3..0> != 0); 
#line 622 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 4; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
			if efs_shift > 2 then 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<1..0> != 0); 
#line 622 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 2; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
			if efs_shift > 1 then 
#line 622 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<0..0> != 0); 
#line 622 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	
#line 622 "nmp/essp_fp_instr.nmp"
			if  EFS_LOWER == EFS_UPPER then 
#line 622 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FGH = efs_guard; 
#line 622 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FXH = efs_sticky; 
#line 622 "nmp/essp_fp_instr.nmp"
			else 
#line 622 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FG = efs_guard; 
#line 622 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FX = efs_sticky; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
			if efs_guard || efs_sticky then 
#line 622 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FINXS = 1; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	
#line 622 "nmp/essp_fp_instr.nmp"
			if  EFS_ROUND == EFS_ROUND && SPEFSCR_FINXE == 0 then 
#line 622 "nmp/essp_fp_instr.nmp"
				if SPEFSCR_FRMC == 0b00 then 
#line 622 "nmp/essp_fp_instr.nmp"
					if efs_guard then 
#line 622 "nmp/essp_fp_instr.nmp"
						if efs_sticky | (GPR[rD] & 0x00000001) then 
#line 622 "nmp/essp_fp_instr.nmp"
							GPR[rD] = GPR[rD] + 1; 
#line 622 "nmp/essp_fp_instr.nmp"
						endif; 
#line 622 "nmp/essp_fp_instr.nmp"
					endif; 
#line 622 "nmp/essp_fp_instr.nmp"
				else if (SPEFSCR_FRMC & 0b10) == 0b10 then 
#line 622 "nmp/essp_fp_instr.nmp"
				endif; endif; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	
#line 622 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 622 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then  
#line 622 "nmp/essp_fp_instr.nmp"
					GPR[rD] = ~GPR[rD] + 1; 
#line 622 "nmp/essp_fp_instr.nmp"
				endif; 
#line 622 "nmp/essp_fp_instr.nmp"
			endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	
#line 622 "nmp/essp_fp_instr.nmp"
		endif; 
#line 622 "nmp/essp_fp_instr.nmp"
	endif; endif; endif; endif;;
#line 622 "nmp/essp_fp_instr.nmp"
#line 623 "nmp/essp_fp_instr.nmp"
	}


op efsctsiz(rD: index, rB: index)
	syntax = format("efsctsiz r%d, r%d", rD, rB)
	image  = format("000100 %5b 00000 %5b 010 1101 1010", rD, rB)
	action = {
			if (GPR[rB]<30..23> == 255) then 
#line 630 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 630 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 630 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 630 "nmp/essp_fp_instr.nmp"
	endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 630 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 630 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 630 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 630 "nmp/essp_fp_instr.nmp"
	endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 630 "nmp/essp_fp_instr.nmp"
		if (GPR[rB]<30..23> == 255 && GPR[rB]<22..0> != 0) then 
#line 630 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0x00000000; 
#line 630 "nmp/essp_fp_instr.nmp"
		else if  EFS_SIGN == EFS_SIGN then 
#line 630 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 630 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x80000000; 
#line 630 "nmp/essp_fp_instr.nmp"
			else 
#line 630 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
		else 
#line 630 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 630 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x00000000; 
#line 630 "nmp/essp_fp_instr.nmp"
			else 
#line 630 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0xffffffff; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
		endif; endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	else if (GPR[rB]<30..23> == 0 && GPR[rB]<22..0> != 0)  then 
#line 630 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 630 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 630 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 630 "nmp/essp_fp_instr.nmp"
	endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 630 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 630 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 630 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 630 "nmp/essp_fp_instr.nmp"
	endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 630 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 630 "nmp/essp_fp_instr.nmp"
	else if  EFS_SIGN == EFS_UNSIGN && GPR[rB]<31..31> == 1 then 
#line 630 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FOVF; 
#line 630 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 630 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 630 "nmp/essp_fp_instr.nmp"
	endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 630 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 630 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 630 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 630 "nmp/essp_fp_instr.nmp"
	endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 630 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 630 "nmp/essp_fp_instr.nmp"
	else if GPR[rB]<30..23> == 0 && GPR[rB]<22..0> == 0 then 
#line 630 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 630 "nmp/essp_fp_instr.nmp"
	else 
#line 630 "nmp/essp_fp_instr.nmp"
	
#line 630 "nmp/essp_fp_instr.nmp"
		if EFS_I == EFS_I then 
#line 630 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 158; 
#line 630 "nmp/essp_fp_instr.nmp"
			efs_shift = 158 - GPR[rB]<30..23>; 
#line 630 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 630 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<30..23> != 158 
#line 630 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<22..0> != 0 
#line 630 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<31..31> != 1 then 
#line 630 "nmp/essp_fp_instr.nmp"
					efs_maxexp = efs_maxexp - 1; 
#line 630 "nmp/essp_fp_instr.nmp"
				endif; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
		else 
#line 630 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 126; 
#line 630 "nmp/essp_fp_instr.nmp"
			efs_shift = efs_maxexp - GPR[rB]<30..23>; 
#line 630 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 1; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
		endif; 
#line 630 "nmp/essp_fp_instr.nmp"
		
#line 630 "nmp/essp_fp_instr.nmp"
		if GPR[rB]<30..23> > efs_maxexp then 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_bits = FP_FOVF; 
#line 630 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 630 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 630 "nmp/essp_fp_instr.nmp"
	endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 630 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 630 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 630 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 630 "nmp/essp_fp_instr.nmp"
	endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 630 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 630 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then 
#line 630 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x80000000; 
#line 630 "nmp/essp_fp_instr.nmp"
				else 
#line 630 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x7fffffff; 
#line 630 "nmp/essp_fp_instr.nmp"
				endif; 
#line 630 "nmp/essp_fp_instr.nmp"
			else 
#line 630 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
		else 
#line 630 "nmp/essp_fp_instr.nmp"
		
#line 630 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0b1 :: GPR[rB]<22..0> :: 0b00000000; 
#line 630 "nmp/essp_fp_instr.nmp"
			efs_guard = 0; 
#line 630 "nmp/essp_fp_instr.nmp"
			efs_sticky = 0; 
#line 630 "nmp/essp_fp_instr.nmp"
		
#line 630 "nmp/essp_fp_instr.nmp"
			efs_guard = GPR[rD]<efs_shift -1 .. efs_shift -1>; 
#line 630 "nmp/essp_fp_instr.nmp"
			if efs_shift > 16 then 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<15..0> != 0); 
#line 630 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 16; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
			if efs_shift > 8 then 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<7..0> != 0); 
#line 630 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 8; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
			if efs_shift > 4 then 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<3..0> != 0); 
#line 630 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 4; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
			if efs_shift > 2 then 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<1..0> != 0); 
#line 630 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 2; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
			if efs_shift > 1 then 
#line 630 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<0..0> != 0); 
#line 630 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	
#line 630 "nmp/essp_fp_instr.nmp"
			if  EFS_LOWER == EFS_UPPER then 
#line 630 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FGH = efs_guard; 
#line 630 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FXH = efs_sticky; 
#line 630 "nmp/essp_fp_instr.nmp"
			else 
#line 630 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FG = efs_guard; 
#line 630 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FX = efs_sticky; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
			if efs_guard || efs_sticky then 
#line 630 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FINXS = 1; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	
#line 630 "nmp/essp_fp_instr.nmp"
			if  EFS_TRUNC == EFS_ROUND && SPEFSCR_FINXE == 0 then 
#line 630 "nmp/essp_fp_instr.nmp"
				if SPEFSCR_FRMC == 0b00 then 
#line 630 "nmp/essp_fp_instr.nmp"
					if efs_guard then 
#line 630 "nmp/essp_fp_instr.nmp"
						if efs_sticky | (GPR[rD] & 0x00000001) then 
#line 630 "nmp/essp_fp_instr.nmp"
							GPR[rD] = GPR[rD] + 1; 
#line 630 "nmp/essp_fp_instr.nmp"
						endif; 
#line 630 "nmp/essp_fp_instr.nmp"
					endif; 
#line 630 "nmp/essp_fp_instr.nmp"
				else if (SPEFSCR_FRMC & 0b10) == 0b10 then 
#line 630 "nmp/essp_fp_instr.nmp"
				endif; endif; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	
#line 630 "nmp/essp_fp_instr.nmp"
			if  EFS_SIGN == EFS_SIGN then 
#line 630 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then  
#line 630 "nmp/essp_fp_instr.nmp"
					GPR[rD] = ~GPR[rD] + 1; 
#line 630 "nmp/essp_fp_instr.nmp"
				endif; 
#line 630 "nmp/essp_fp_instr.nmp"
			endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	
#line 630 "nmp/essp_fp_instr.nmp"
		endif; 
#line 630 "nmp/essp_fp_instr.nmp"
	endif; endif; endif; endif;;
#line 630 "nmp/essp_fp_instr.nmp"
#line 631 "nmp/essp_fp_instr.nmp"
	}


op efsctuf(rD: index, rB: index)
	syntax = format("efsctuf r%d, r%d", rD, rB)
	image  = format("000100 %5b 00000 %5b 010 1101 0110", rD, rB)
	action = {
			if (GPR[rB]<30..23> == 255) then 
#line 638 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 638 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 638 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 638 "nmp/essp_fp_instr.nmp"
	endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 638 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 638 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 638 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 638 "nmp/essp_fp_instr.nmp"
	endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 638 "nmp/essp_fp_instr.nmp"
		if (GPR[rB]<30..23> == 255 && GPR[rB]<22..0> != 0) then 
#line 638 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0x00000000; 
#line 638 "nmp/essp_fp_instr.nmp"
		else if  EFS_UNSIGN == EFS_SIGN then 
#line 638 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 638 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x80000000; 
#line 638 "nmp/essp_fp_instr.nmp"
			else 
#line 638 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
		else 
#line 638 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 638 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x00000000; 
#line 638 "nmp/essp_fp_instr.nmp"
			else 
#line 638 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0xffffffff; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
		endif; endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	else if (GPR[rB]<30..23> == 0 && GPR[rB]<22..0> != 0)  then 
#line 638 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 638 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 638 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 638 "nmp/essp_fp_instr.nmp"
	endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 638 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 638 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 638 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 638 "nmp/essp_fp_instr.nmp"
	endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 638 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 638 "nmp/essp_fp_instr.nmp"
	else if  EFS_UNSIGN == EFS_UNSIGN && GPR[rB]<31..31> == 1 then 
#line 638 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FOVF; 
#line 638 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 638 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 638 "nmp/essp_fp_instr.nmp"
	endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 638 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 638 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 638 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 638 "nmp/essp_fp_instr.nmp"
	endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 638 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 638 "nmp/essp_fp_instr.nmp"
	else if GPR[rB]<30..23> == 0 && GPR[rB]<22..0> == 0 then 
#line 638 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 638 "nmp/essp_fp_instr.nmp"
	else 
#line 638 "nmp/essp_fp_instr.nmp"
	
#line 638 "nmp/essp_fp_instr.nmp"
		if EFS_F == EFS_I then 
#line 638 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 158; 
#line 638 "nmp/essp_fp_instr.nmp"
			efs_shift = 158 - GPR[rB]<30..23>; 
#line 638 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 638 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<30..23> != 158 
#line 638 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<22..0> != 0 
#line 638 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<31..31> != 1 then 
#line 638 "nmp/essp_fp_instr.nmp"
					efs_maxexp = efs_maxexp - 1; 
#line 638 "nmp/essp_fp_instr.nmp"
				endif; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
		else 
#line 638 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 126; 
#line 638 "nmp/essp_fp_instr.nmp"
			efs_shift = efs_maxexp - GPR[rB]<30..23>; 
#line 638 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 1; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
		endif; 
#line 638 "nmp/essp_fp_instr.nmp"
		
#line 638 "nmp/essp_fp_instr.nmp"
		if GPR[rB]<30..23> > efs_maxexp then 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_bits = FP_FOVF; 
#line 638 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 638 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 638 "nmp/essp_fp_instr.nmp"
	endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 638 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 638 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 638 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 638 "nmp/essp_fp_instr.nmp"
	endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 638 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 638 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then 
#line 638 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x80000000; 
#line 638 "nmp/essp_fp_instr.nmp"
				else 
#line 638 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x7fffffff; 
#line 638 "nmp/essp_fp_instr.nmp"
				endif; 
#line 638 "nmp/essp_fp_instr.nmp"
			else 
#line 638 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
		else 
#line 638 "nmp/essp_fp_instr.nmp"
		
#line 638 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0b1 :: GPR[rB]<22..0> :: 0b00000000; 
#line 638 "nmp/essp_fp_instr.nmp"
			efs_guard = 0; 
#line 638 "nmp/essp_fp_instr.nmp"
			efs_sticky = 0; 
#line 638 "nmp/essp_fp_instr.nmp"
		
#line 638 "nmp/essp_fp_instr.nmp"
			efs_guard = GPR[rD]<efs_shift -1 .. efs_shift -1>; 
#line 638 "nmp/essp_fp_instr.nmp"
			if efs_shift > 16 then 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<15..0> != 0); 
#line 638 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 16; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
			if efs_shift > 8 then 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<7..0> != 0); 
#line 638 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 8; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
			if efs_shift > 4 then 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<3..0> != 0); 
#line 638 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 4; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
			if efs_shift > 2 then 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<1..0> != 0); 
#line 638 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 2; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
			if efs_shift > 1 then 
#line 638 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<0..0> != 0); 
#line 638 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	
#line 638 "nmp/essp_fp_instr.nmp"
			if  EFS_LOWER == EFS_UPPER then 
#line 638 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FGH = efs_guard; 
#line 638 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FXH = efs_sticky; 
#line 638 "nmp/essp_fp_instr.nmp"
			else 
#line 638 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FG = efs_guard; 
#line 638 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FX = efs_sticky; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
			if efs_guard || efs_sticky then 
#line 638 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FINXS = 1; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	
#line 638 "nmp/essp_fp_instr.nmp"
			if  EFS_ROUND == EFS_ROUND && SPEFSCR_FINXE == 0 then 
#line 638 "nmp/essp_fp_instr.nmp"
				if SPEFSCR_FRMC == 0b00 then 
#line 638 "nmp/essp_fp_instr.nmp"
					if efs_guard then 
#line 638 "nmp/essp_fp_instr.nmp"
						if efs_sticky | (GPR[rD] & 0x00000001) then 
#line 638 "nmp/essp_fp_instr.nmp"
							GPR[rD] = GPR[rD] + 1; 
#line 638 "nmp/essp_fp_instr.nmp"
						endif; 
#line 638 "nmp/essp_fp_instr.nmp"
					endif; 
#line 638 "nmp/essp_fp_instr.nmp"
				else if (SPEFSCR_FRMC & 0b10) == 0b10 then 
#line 638 "nmp/essp_fp_instr.nmp"
				endif; endif; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	
#line 638 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 638 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then  
#line 638 "nmp/essp_fp_instr.nmp"
					GPR[rD] = ~GPR[rD] + 1; 
#line 638 "nmp/essp_fp_instr.nmp"
				endif; 
#line 638 "nmp/essp_fp_instr.nmp"
			endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	
#line 638 "nmp/essp_fp_instr.nmp"
		endif; 
#line 638 "nmp/essp_fp_instr.nmp"
	endif; endif; endif; endif;;
#line 638 "nmp/essp_fp_instr.nmp"
#line 639 "nmp/essp_fp_instr.nmp"
	}


op efsctui(rD: index, rB: index)
	syntax = format("efsctui r%d, r%d", rD, rB)
	image  = format("000100 %5b 00000 %5b 010 1101 0000", rD, rB)
	action = {
			if (GPR[rB]<30..23> == 255) then 
#line 646 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 646 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 646 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 646 "nmp/essp_fp_instr.nmp"
	endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 646 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 646 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 646 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 646 "nmp/essp_fp_instr.nmp"
	endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 646 "nmp/essp_fp_instr.nmp"
		if (GPR[rB]<30..23> == 255 && GPR[rB]<22..0> != 0) then 
#line 646 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0x00000000; 
#line 646 "nmp/essp_fp_instr.nmp"
		else if  EFS_UNSIGN == EFS_SIGN then 
#line 646 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 646 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x80000000; 
#line 646 "nmp/essp_fp_instr.nmp"
			else 
#line 646 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
		else 
#line 646 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 646 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x00000000; 
#line 646 "nmp/essp_fp_instr.nmp"
			else 
#line 646 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0xffffffff; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
		endif; endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	else if (GPR[rB]<30..23> == 0 && GPR[rB]<22..0> != 0)  then 
#line 646 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 646 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 646 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 646 "nmp/essp_fp_instr.nmp"
	endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 646 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 646 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 646 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 646 "nmp/essp_fp_instr.nmp"
	endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 646 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 646 "nmp/essp_fp_instr.nmp"
	else if  EFS_UNSIGN == EFS_UNSIGN && GPR[rB]<31..31> == 1 then 
#line 646 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FOVF; 
#line 646 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 646 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 646 "nmp/essp_fp_instr.nmp"
	endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 646 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 646 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 646 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 646 "nmp/essp_fp_instr.nmp"
	endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 646 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 646 "nmp/essp_fp_instr.nmp"
	else if GPR[rB]<30..23> == 0 && GPR[rB]<22..0> == 0 then 
#line 646 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 646 "nmp/essp_fp_instr.nmp"
	else 
#line 646 "nmp/essp_fp_instr.nmp"
	
#line 646 "nmp/essp_fp_instr.nmp"
		if EFS_I == EFS_I then 
#line 646 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 158; 
#line 646 "nmp/essp_fp_instr.nmp"
			efs_shift = 158 - GPR[rB]<30..23>; 
#line 646 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 646 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<30..23> != 158 
#line 646 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<22..0> != 0 
#line 646 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<31..31> != 1 then 
#line 646 "nmp/essp_fp_instr.nmp"
					efs_maxexp = efs_maxexp - 1; 
#line 646 "nmp/essp_fp_instr.nmp"
				endif; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
		else 
#line 646 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 126; 
#line 646 "nmp/essp_fp_instr.nmp"
			efs_shift = efs_maxexp - GPR[rB]<30..23>; 
#line 646 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 1; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
		endif; 
#line 646 "nmp/essp_fp_instr.nmp"
		
#line 646 "nmp/essp_fp_instr.nmp"
		if GPR[rB]<30..23> > efs_maxexp then 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_bits = FP_FOVF; 
#line 646 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 646 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 646 "nmp/essp_fp_instr.nmp"
	endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 646 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 646 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 646 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 646 "nmp/essp_fp_instr.nmp"
	endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 646 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 646 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then 
#line 646 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x80000000; 
#line 646 "nmp/essp_fp_instr.nmp"
				else 
#line 646 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x7fffffff; 
#line 646 "nmp/essp_fp_instr.nmp"
				endif; 
#line 646 "nmp/essp_fp_instr.nmp"
			else 
#line 646 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
		else 
#line 646 "nmp/essp_fp_instr.nmp"
		
#line 646 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0b1 :: GPR[rB]<22..0> :: 0b00000000; 
#line 646 "nmp/essp_fp_instr.nmp"
			efs_guard = 0; 
#line 646 "nmp/essp_fp_instr.nmp"
			efs_sticky = 0; 
#line 646 "nmp/essp_fp_instr.nmp"
		
#line 646 "nmp/essp_fp_instr.nmp"
			efs_guard = GPR[rD]<efs_shift -1 .. efs_shift -1>; 
#line 646 "nmp/essp_fp_instr.nmp"
			if efs_shift > 16 then 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<15..0> != 0); 
#line 646 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 16; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
			if efs_shift > 8 then 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<7..0> != 0); 
#line 646 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 8; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
			if efs_shift > 4 then 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<3..0> != 0); 
#line 646 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 4; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
			if efs_shift > 2 then 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<1..0> != 0); 
#line 646 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 2; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
			if efs_shift > 1 then 
#line 646 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<0..0> != 0); 
#line 646 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	
#line 646 "nmp/essp_fp_instr.nmp"
			if  EFS_LOWER == EFS_UPPER then 
#line 646 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FGH = efs_guard; 
#line 646 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FXH = efs_sticky; 
#line 646 "nmp/essp_fp_instr.nmp"
			else 
#line 646 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FG = efs_guard; 
#line 646 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FX = efs_sticky; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
			if efs_guard || efs_sticky then 
#line 646 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FINXS = 1; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	
#line 646 "nmp/essp_fp_instr.nmp"
			if  EFS_ROUND == EFS_ROUND && SPEFSCR_FINXE == 0 then 
#line 646 "nmp/essp_fp_instr.nmp"
				if SPEFSCR_FRMC == 0b00 then 
#line 646 "nmp/essp_fp_instr.nmp"
					if efs_guard then 
#line 646 "nmp/essp_fp_instr.nmp"
						if efs_sticky | (GPR[rD] & 0x00000001) then 
#line 646 "nmp/essp_fp_instr.nmp"
							GPR[rD] = GPR[rD] + 1; 
#line 646 "nmp/essp_fp_instr.nmp"
						endif; 
#line 646 "nmp/essp_fp_instr.nmp"
					endif; 
#line 646 "nmp/essp_fp_instr.nmp"
				else if (SPEFSCR_FRMC & 0b10) == 0b10 then 
#line 646 "nmp/essp_fp_instr.nmp"
				endif; endif; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	
#line 646 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 646 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then  
#line 646 "nmp/essp_fp_instr.nmp"
					GPR[rD] = ~GPR[rD] + 1; 
#line 646 "nmp/essp_fp_instr.nmp"
				endif; 
#line 646 "nmp/essp_fp_instr.nmp"
			endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	
#line 646 "nmp/essp_fp_instr.nmp"
		endif; 
#line 646 "nmp/essp_fp_instr.nmp"
	endif; endif; endif; endif;;
#line 646 "nmp/essp_fp_instr.nmp"
#line 647 "nmp/essp_fp_instr.nmp"
	}


op efsctuiz(rD: index, rB: index)
	syntax = format("efsctuiz r%d, r%d", rD, rB)
	image  = format("000100 %5b 00000 %5b 010 1101 1000", rD, rB)
	action = {
			if (GPR[rB]<30..23> == 255) then 
#line 654 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 654 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 654 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 654 "nmp/essp_fp_instr.nmp"
	endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 654 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 654 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 654 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 654 "nmp/essp_fp_instr.nmp"
	endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 654 "nmp/essp_fp_instr.nmp"
		if (GPR[rB]<30..23> == 255 && GPR[rB]<22..0> != 0) then 
#line 654 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0x00000000; 
#line 654 "nmp/essp_fp_instr.nmp"
		else if  EFS_UNSIGN == EFS_SIGN then 
#line 654 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 654 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x80000000; 
#line 654 "nmp/essp_fp_instr.nmp"
			else 
#line 654 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
		else 
#line 654 "nmp/essp_fp_instr.nmp"
			if GPR[rB]<31..31> == 1 then 
#line 654 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x00000000; 
#line 654 "nmp/essp_fp_instr.nmp"
			else 
#line 654 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0xffffffff; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
		endif; endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	else if (GPR[rB]<30..23> == 0 && GPR[rB]<22..0> != 0)  then 
#line 654 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FINV; 
#line 654 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 654 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 654 "nmp/essp_fp_instr.nmp"
	endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 654 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 654 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 654 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 654 "nmp/essp_fp_instr.nmp"
	endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 654 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 654 "nmp/essp_fp_instr.nmp"
	else if  EFS_UNSIGN == EFS_UNSIGN && GPR[rB]<31..31> == 1 then 
#line 654 "nmp/essp_fp_instr.nmp"
			efs_bits = FP_FOVF; 
#line 654 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 654 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 654 "nmp/essp_fp_instr.nmp"
	endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 654 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 654 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 654 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 654 "nmp/essp_fp_instr.nmp"
	endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 654 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 654 "nmp/essp_fp_instr.nmp"
	else if GPR[rB]<30..23> == 0 && GPR[rB]<22..0> == 0 then 
#line 654 "nmp/essp_fp_instr.nmp"
		GPR[rD] = 0x00000000; 
#line 654 "nmp/essp_fp_instr.nmp"
	else 
#line 654 "nmp/essp_fp_instr.nmp"
	
#line 654 "nmp/essp_fp_instr.nmp"
		if EFS_I == EFS_I then 
#line 654 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 158; 
#line 654 "nmp/essp_fp_instr.nmp"
			efs_shift = 158 - GPR[rB]<30..23>; 
#line 654 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 654 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<30..23> != 158 
#line 654 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<22..0> != 0 
#line 654 "nmp/essp_fp_instr.nmp"
				|| GPR[rB]<31..31> != 1 then 
#line 654 "nmp/essp_fp_instr.nmp"
					efs_maxexp = efs_maxexp - 1; 
#line 654 "nmp/essp_fp_instr.nmp"
				endif; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
		else 
#line 654 "nmp/essp_fp_instr.nmp"
			efs_maxexp = 126; 
#line 654 "nmp/essp_fp_instr.nmp"
			efs_shift = efs_maxexp - GPR[rB]<30..23>; 
#line 654 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 1; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
		endif; 
#line 654 "nmp/essp_fp_instr.nmp"
		
#line 654 "nmp/essp_fp_instr.nmp"
		if GPR[rB]<30..23> > efs_maxexp then 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_bits = FP_FOVF; 
#line 654 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 654 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 654 "nmp/essp_fp_instr.nmp"
	endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR | efs_bits; 
#line 654 "nmp/essp_fp_instr.nmp"
	efs_bits = (1 << FP_FG) | (1 << FP_FX); 
#line 654 "nmp/essp_fp_instr.nmp"
	if  EFS_LOWER == EFS_UPPER then 
#line 654 "nmp/essp_fp_instr.nmp"
		efs_bits = efs_bits << 15; 
#line 654 "nmp/essp_fp_instr.nmp"
	endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	SPEFSCR = SPEFSCR & ~efs_bits;; 
#line 654 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 654 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then 
#line 654 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x80000000; 
#line 654 "nmp/essp_fp_instr.nmp"
				else 
#line 654 "nmp/essp_fp_instr.nmp"
					GPR[rD] = 0x7fffffff; 
#line 654 "nmp/essp_fp_instr.nmp"
				endif; 
#line 654 "nmp/essp_fp_instr.nmp"
			else 
#line 654 "nmp/essp_fp_instr.nmp"
				GPR[rD] = 0x7fffffff; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
		else 
#line 654 "nmp/essp_fp_instr.nmp"
		
#line 654 "nmp/essp_fp_instr.nmp"
			GPR[rD] = 0b1 :: GPR[rB]<22..0> :: 0b00000000; 
#line 654 "nmp/essp_fp_instr.nmp"
			efs_guard = 0; 
#line 654 "nmp/essp_fp_instr.nmp"
			efs_sticky = 0; 
#line 654 "nmp/essp_fp_instr.nmp"
		
#line 654 "nmp/essp_fp_instr.nmp"
			efs_guard = GPR[rD]<efs_shift -1 .. efs_shift -1>; 
#line 654 "nmp/essp_fp_instr.nmp"
			if efs_shift > 16 then 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<15..0> != 0); 
#line 654 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 16; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
			if efs_shift > 8 then 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<7..0> != 0); 
#line 654 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 8; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
			if efs_shift > 4 then 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<3..0> != 0); 
#line 654 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 4; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
			if efs_shift > 2 then 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<1..0> != 0); 
#line 654 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_shift = efs_shift - 2; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
			if efs_shift > 1 then 
#line 654 "nmp/essp_fp_instr.nmp"
				efs_sticky = efs_sticky | (GPR[rD]<0..0> != 0); 
#line 654 "nmp/essp_fp_instr.nmp"
				GPR[rD] = GPR[rD] >> efs_shift; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	
#line 654 "nmp/essp_fp_instr.nmp"
			if  EFS_LOWER == EFS_UPPER then 
#line 654 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FGH = efs_guard; 
#line 654 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FXH = efs_sticky; 
#line 654 "nmp/essp_fp_instr.nmp"
			else 
#line 654 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FG = efs_guard; 
#line 654 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FX = efs_sticky; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
			if efs_guard || efs_sticky then 
#line 654 "nmp/essp_fp_instr.nmp"
				SPEFSCR_FINXS = 1; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	
#line 654 "nmp/essp_fp_instr.nmp"
			if  EFS_TRUNC == EFS_ROUND && SPEFSCR_FINXE == 0 then 
#line 654 "nmp/essp_fp_instr.nmp"
				if SPEFSCR_FRMC == 0b00 then 
#line 654 "nmp/essp_fp_instr.nmp"
					if efs_guard then 
#line 654 "nmp/essp_fp_instr.nmp"
						if efs_sticky | (GPR[rD] & 0x00000001) then 
#line 654 "nmp/essp_fp_instr.nmp"
							GPR[rD] = GPR[rD] + 1; 
#line 654 "nmp/essp_fp_instr.nmp"
						endif; 
#line 654 "nmp/essp_fp_instr.nmp"
					endif; 
#line 654 "nmp/essp_fp_instr.nmp"
				else if (SPEFSCR_FRMC & 0b10) == 0b10 then 
#line 654 "nmp/essp_fp_instr.nmp"
				endif; endif; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	
#line 654 "nmp/essp_fp_instr.nmp"
			if  EFS_UNSIGN == EFS_SIGN then 
#line 654 "nmp/essp_fp_instr.nmp"
				if GPR[rB]<31..31> == 1 then  
#line 654 "nmp/essp_fp_instr.nmp"
					GPR[rD] = ~GPR[rD] + 1; 
#line 654 "nmp/essp_fp_instr.nmp"
				endif; 
#line 654 "nmp/essp_fp_instr.nmp"
			endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	
#line 654 "nmp/essp_fp_instr.nmp"
		endif; 
#line 654 "nmp/essp_fp_instr.nmp"
	endif; endif; endif; endif;;
#line 654 "nmp/essp_fp_instr.nmp"
#line 655 "nmp/essp_fp_instr.nmp"
	}


op efsdiv ( frd : index, fra : index, frb : index )
   syntax = format ( "efsdiv r%d, r%d, r%d", frd, fra, frb )
   image  = format ( "000100%5b%5b%5b01011001001", frd, fra, frb )
   action = {
		// indique le mode arrondi ........................
		// ras les flags ..................................

		TMP_FLOAT32_A<31..0> = GPR [ fra ];
        TMP_FLOAT32_B<31..0> = GPR [ frb ];

		if (TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> != 0)||(TMP_FLOAT32_A<31..31> == 0 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0)||(TMP_FLOAT32_A<31..31> == 1 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0) then // if RA is NaN or infinity
#line 668 "nmp/essp_fp_instr.nmp"
#line 669 "nmp/essp_fp_instr.nmp"
		    if (TMP_FLOAT32_A<31..31>==0) then
#line 669 "nmp/essp_fp_instr.nmp"
#line 670 "nmp/essp_fp_instr.nmp"
				TMP_FLOT32<31..0> = FP_PMAX;
			else
				TMP_FLOT32<31..0> = FP_PMAX;
				TMP_FLOT32<31..31>=1;
#line 673 "nmp/essp_fp_instr.nmp"
#line 674 "nmp/essp_fp_instr.nmp"
			endif;
		else
			if (TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> != 0)||(TMP_FLOAT32_B<31..31> == 0 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0)||(TMP_FLOAT32_B<31..31> == 1 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0) then // if RB is NaN or infinity
#line 676 "nmp/essp_fp_instr.nmp"
#line 677 "nmp/essp_fp_instr.nmp"
				if (TMP_FLOAT32_B<31..31>==0) then
#line 677 "nmp/essp_fp_instr.nmp"
#line 678 "nmp/essp_fp_instr.nmp"
					TMP_FLOT32<31..0> = FP_PMAX;
				else
					TMP_FLOT32<31..0> = FP_PMAX;
					TMP_FLOT32<31..31>=1;
#line 681 "nmp/essp_fp_instr.nmp"
#line 682 "nmp/essp_fp_instr.nmp"
				endif;
			else
				TMP_FLOT32 = TMP_FLOAT32_B / TMP_FLOAT32_B;
			endif;
		endif;
				if "fpi_testexcept"("FPI_INEXACT") then 
#line 687 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 687 "nmp/essp_fp_instr.nmp"
	endif; 
#line 687 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 687 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 687 "nmp/essp_fp_instr.nmp"
	endif; 
#line 687 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_INVALID") then 
#line 687 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 687 "nmp/essp_fp_instr.nmp"
	endif; 
#line 687 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 687 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FUNF..FP_FUNF> = 1; 
#line 687 "nmp/essp_fp_instr.nmp"
	endif; 
#line 687 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_INVALID") then 
#line 687 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 687 "nmp/essp_fp_instr.nmp"
	endif; 
#line 687 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 687 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FOVF..FP_FOVF> = 1; 
#line 687 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 687 "nmp/essp_fp_instr.nmp"
	if !(	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 687 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 687 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 687 "nmp/essp_fp_instr.nmp"
		GPR[frd] = TMP_FLOT32<31..0>; 
#line 687 "nmp/essp_fp_instr.nmp"
	else 
#line 687 "nmp/essp_fp_instr.nmp"
		if((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) then 
#line 687 "nmp/essp_fp_instr.nmp"
			GPR[frd] = FP_PMAX; 
#line 687 "nmp/essp_fp_instr.nmp"
		else 
#line 687 "nmp/essp_fp_instr.nmp"
			if((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) then 
#line 687 "nmp/essp_fp_instr.nmp"
				GPR[frd] = 0; 
#line 687 "nmp/essp_fp_instr.nmp"
			endif; 
#line 687 "nmp/essp_fp_instr.nmp"
		endif; 
#line 687 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 687 "nmp/essp_fp_instr.nmp"
#line 688 "nmp/essp_fp_instr.nmp"
		 
		if 	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 689 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 689 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  then
#line 689 "nmp/essp_fp_instr.nmp"
#line 690 "nmp/essp_fp_instr.nmp"
			"launch_exception"("instr",PROGRAM);
		endif;
		}


op efsmul ( frd : index, fra : index, frb : index )
   syntax = format ( "efsmul r%d, r%d, r%d", frd, fra, frb )
   image  = format ( "000100%5b%5b%5b01011001000", frd, fra, frb )
   action = {
		// indique le mode arrondi ........................
		// ras les flags ..................................
		
		TMP_FLOAT32_A<31..0> = GPR [ fra ];
        TMP_FLOAT32_B<31..0> = GPR [ frb ];

		if (TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> != 0)||(TMP_FLOAT32_A<31..31> == 0 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0)||(TMP_FLOAT32_A<31..31> == 1 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0) then // if RA is NaN or infinity
#line 705 "nmp/essp_fp_instr.nmp"
#line 706 "nmp/essp_fp_instr.nmp"
		    if (TMP_FLOAT32_A<31..31>==0) then
#line 706 "nmp/essp_fp_instr.nmp"
#line 707 "nmp/essp_fp_instr.nmp"
				TMP_FLOT32<31..0> = FP_PMAX;
			else
				TMP_FLOT32<31..0> = FP_PMAX;
				TMP_FLOT32<31..31>=1;
#line 710 "nmp/essp_fp_instr.nmp"
#line 711 "nmp/essp_fp_instr.nmp"
			endif;
		else 
			if (TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> != 0)||(TMP_FLOAT32_B<31..31> == 0 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0)||(TMP_FLOAT32_B<31..31> == 1 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0) then // if RB is NaN or infinity
#line 713 "nmp/essp_fp_instr.nmp"
#line 714 "nmp/essp_fp_instr.nmp"
				if (TMP_FLOAT32_B<31..31>==0) then
#line 714 "nmp/essp_fp_instr.nmp"
#line 715 "nmp/essp_fp_instr.nmp"
					TMP_FLOT32<31..0> = FP_PMAX;
				else
					TMP_FLOT32<31..0> = FP_PMAX;
					TMP_FLOT32<31..31>=1;
#line 718 "nmp/essp_fp_instr.nmp"
#line 719 "nmp/essp_fp_instr.nmp"
				endif;
			else
				TMP_FLOT32 = TMP_FLOAT32_B * TMP_FLOAT32_B;
			endif;
		endif;
			
				if "fpi_testexcept"("FPI_INEXACT") then 
#line 725 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 725 "nmp/essp_fp_instr.nmp"
	endif; 
#line 725 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 725 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 725 "nmp/essp_fp_instr.nmp"
	endif; 
#line 725 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_INVALID") then 
#line 725 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 725 "nmp/essp_fp_instr.nmp"
	endif; 
#line 725 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 725 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FUNF..FP_FUNF> = 1; 
#line 725 "nmp/essp_fp_instr.nmp"
	endif; 
#line 725 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_INVALID") then 
#line 725 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 725 "nmp/essp_fp_instr.nmp"
	endif; 
#line 725 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 725 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FOVF..FP_FOVF> = 1; 
#line 725 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 725 "nmp/essp_fp_instr.nmp"
	if !(	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 725 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 725 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 725 "nmp/essp_fp_instr.nmp"
		GPR[frd] = TMP_FLOT32<31..0>; 
#line 725 "nmp/essp_fp_instr.nmp"
	else 
#line 725 "nmp/essp_fp_instr.nmp"
		if((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) then 
#line 725 "nmp/essp_fp_instr.nmp"
			GPR[frd] = FP_PMAX; 
#line 725 "nmp/essp_fp_instr.nmp"
		else 
#line 725 "nmp/essp_fp_instr.nmp"
			if((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) then 
#line 725 "nmp/essp_fp_instr.nmp"
				GPR[frd] = 0; 
#line 725 "nmp/essp_fp_instr.nmp"
			endif; 
#line 725 "nmp/essp_fp_instr.nmp"
		endif; 
#line 725 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 725 "nmp/essp_fp_instr.nmp"
#line 726 "nmp/essp_fp_instr.nmp"
		 
		if 	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 727 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 727 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  then
#line 727 "nmp/essp_fp_instr.nmp"
#line 728 "nmp/essp_fp_instr.nmp"
			"launch_exception"("instr",PROGRAM);
		endif;
		}
		otawa_kind = EFPMUL   
		

op efsnabs(rD: index, rA: index)
	syntax = format("efsnabs r%d, r%d", rD, rA)
	image  = format("000100 %5b %5b 00000 010 1100 0101", rD, rA)
	action = {
		GPR[rD] = 0b1 :: GPR[rA]<30..0>;
	}


op efsneg(rD: index, rA: index)
	syntax = format("efsneg fr%d, fr%d", rD, rA)
	image = format("000100 %5b %5b 00000 010 1100 0110", rD, rA)
	action = {
		GPR[rD] = (~GPR[rA]<31..31>) :: GPR[rA]<30..0>;	
	}


op efssub ( frd : index, fra : index, frb : index )
   syntax = format ( "efssub r%d, r%d, r%d", frd, fra, frb )
   image  = format ( "000100%5b%5b%5b01011000001", frd, fra, frb )
   action = {
		// indique le mode arrondi ........................
		// ras les flags ..................................
		
		TMP_FLOAT32_A<31..0> = GPR [ fra ];
        TMP_FLOAT32_B<31..0> = GPR [ frb ];

		if (TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> != 0)||(TMP_FLOAT32_A<31..31> == 0 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0)||(TMP_FLOAT32_A<31..31> == 1 && TMP_FLOAT32_A<30..23> == 255 && TMP_FLOAT32_A<22..0> == 0) then // if RA is NaN or infinity
#line 760 "nmp/essp_fp_instr.nmp"
#line 761 "nmp/essp_fp_instr.nmp"
		    if (TMP_FLOAT32_A<31..31>==0) then
#line 761 "nmp/essp_fp_instr.nmp"
#line 762 "nmp/essp_fp_instr.nmp"
				TMP_FLOT32<31..0> = FP_PMAX;
			else
				TMP_FLOT32<31..0> = FP_PMAX;
				TMP_FLOT32<31..31>=1;
#line 765 "nmp/essp_fp_instr.nmp"
#line 766 "nmp/essp_fp_instr.nmp"
			endif;
		else 
			if (TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> != 0)||(TMP_FLOAT32_B<31..31> == 0 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0)||(TMP_FLOAT32_B<31..31> == 1 && TMP_FLOAT32_B<30..23> == 255 && TMP_FLOAT32_B<22..0> == 0) then // if RB is NaN or infinity
#line 768 "nmp/essp_fp_instr.nmp"
#line 769 "nmp/essp_fp_instr.nmp"
				if (TMP_FLOAT32_B<31..31>==0) then
#line 769 "nmp/essp_fp_instr.nmp"
#line 770 "nmp/essp_fp_instr.nmp"
					TMP_FLOT32<31..0> = FP_PMAX;
				else
					TMP_FLOT32<31..0> = FP_PMAX;
					TMP_FLOT32<31..31>=1;
#line 773 "nmp/essp_fp_instr.nmp"
#line 774 "nmp/essp_fp_instr.nmp"
				endif;
			else
				TMP_FLOT32 = TMP_FLOAT32_B - TMP_FLOAT32_B;
			endif;
		endif;	
				if "fpi_testexcept"("FPI_INEXACT") then 
#line 779 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 779 "nmp/essp_fp_instr.nmp"
	endif; 
#line 779 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 779 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 779 "nmp/essp_fp_instr.nmp"
	endif; 
#line 779 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_INVALID") then 
#line 779 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 779 "nmp/essp_fp_instr.nmp"
	endif; 
#line 779 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 779 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FUNF..FP_FUNF> = 1; 
#line 779 "nmp/essp_fp_instr.nmp"
	endif; 
#line 779 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_INVALID") then 
#line 779 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FINV..FP_FINV> = 1; 
#line 779 "nmp/essp_fp_instr.nmp"
	endif; 
#line 779 "nmp/essp_fp_instr.nmp"
	if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 779 "nmp/essp_fp_instr.nmp"
		SPEFSCR <FP_FOVF..FP_FOVF> = 1; 
#line 779 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 779 "nmp/essp_fp_instr.nmp"
	if !(	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 779 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 779 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 779 "nmp/essp_fp_instr.nmp"
		GPR[frd] = TMP_FLOT32<31..0>; 
#line 779 "nmp/essp_fp_instr.nmp"
	else 
#line 779 "nmp/essp_fp_instr.nmp"
		if((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) then 
#line 779 "nmp/essp_fp_instr.nmp"
			GPR[frd] = FP_PMAX; 
#line 779 "nmp/essp_fp_instr.nmp"
		else 
#line 779 "nmp/essp_fp_instr.nmp"
			if((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) then 
#line 779 "nmp/essp_fp_instr.nmp"
				GPR[frd] = 0; 
#line 779 "nmp/essp_fp_instr.nmp"
			endif; 
#line 779 "nmp/essp_fp_instr.nmp"
		endif; 
#line 779 "nmp/essp_fp_instr.nmp"
	endif;; 
#line 779 "nmp/essp_fp_instr.nmp"
#line 780 "nmp/essp_fp_instr.nmp"
		 
		if 	(((SPEFSCR<FP_FINV..FP_FINV>) && (SPEFSCR<FP_FINVE..FP_FINVE>)) || 
#line 781 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FUNF..FP_FUNF>) && (SPEFSCR<FP_FUNFE..FP_FUNFE>)) || 
#line 781 "nmp/essp_fp_instr.nmp"
	 ((SPEFSCR<FP_FOVF..FP_FOVF>) && (SPEFSCR<FP_FOVFE..FP_FOVFE>)) )  then
#line 781 "nmp/essp_fp_instr.nmp"
#line 782 "nmp/essp_fp_instr.nmp"
			"launch_exception"("instr",PROGRAM);
		endif;
		}

op efststeq(crD: card(3), rA: index, rB: index)
	syntax = format("efststeq cr%d, r%d, r%d", crD, rA, rB)
	image  = format("000100 %3b 00 %5b %5b 010 1101 1110", crD, rA, rB)
	action = {
		efs_al<31..0> = GPR[rA];
		efs_bl<31..0> = GPR[rB];
		if efs_al == efs_bl then
			efs_cl = 1;
		else
			efs_cl = 0;
		endif;
		CR[7 - crD]<EQ..EQ> = efs_cl;
	}
		
		
op efststgt(crD: card(3), rA: index, rB: index)
	syntax = format("efststgt cr%d, r%d, r%d", crD, rA, rB)
	image  = format("000100 %3b 00 %5b %5b 010 1101 1100", crD, rA, rB)
	action = {
		efs_al<31..0> = GPR[rA];
		efs_bl<31..0> = GPR[rB];
		if efs_al > efs_bl then
			efs_cl = 1;
		else
			efs_cl = 0;
		endif;
		CR[7 - crD]<GT..GT> = efs_cl;
	}
		
		
op efststlt(crD: card(3), rA: index, rB: index)
	syntax = format("efststlt cr%d, r%d, r%d", crD, rA, rB)
	image  = format("000100 %3b 00 %5b %5b 010 1101 1101", crD, rA, rB)
	action = {
		efs_al<31..0> = GPR[rA];
		efs_bl<31..0> = GPR[rB];
		if efs_al < efs_bl then
			efs_cl = 1;
		else
			efs_cl = 0;
		endif;
		CR[7 - crD]<LT..LT> = efs_cl;
	}

		
#line 1 "nmp/uisa_fp_instr.nmp"
// ****************************************************************************
//                              uisa_fp_instr.nmp
//                              ------------------
//    date            : May 2003
//    copyright       : Institut de Recherche en Informatique de Toulouse
//    author          : Daniel Gracia-Perez & Marc Finet
//    email           : sainrat@irit.fr
// ****************************************************************************

// ****************************************************************************
// *                                                                          *
// *   This program is free software; you can redistribute it and/or modify   *
// *   it under the terms of the GNU General Public License as published by   *
// *   the Free Software Foundation; either version 2 of the License, or      *
// *   (at your option) any later version.                                    *
// *                                                                          *
// ****************************************************************************

// ************************************************************************* //
//                               uisa_fp description                         //
// ************************************************************************* //
// This file contains the nMP description of the floating-point
// instructions of the PowerPC and the associated constants, macros, ...

// ========================================================================= //
// 1. Definitions                                                            //
// ========================================================================= //

// ------------------------------------------------------------------------- //
// 1.1 Constants                                                             //
// ------------------------------------------------------------------------- //

let FP_RN_TONEAREST = 0
let FP_RN_TOWARDZERO =1
let FP_RN_UPWARD =2
let FP_RN_DOWNWARD =3
let FP_FX =31
let FP_FEX =30
let FP_VX =29
let FP_OX= 28
let FP_UX =27
let FP_ZX =26
let FP_XX =25
let FP_VXSNAN =24
let FP_VXISI =23
let FP_VXIDI =22
let FP_VXZDZ =21
let FP_VXIMZ =20
let FP_VXVC =19
let FP_FR =18
let FP_FI =17
let FP_VXSOFT =10
let FP_VXSQRT =9
let FP_VXCVI =8
let FP_VE =7
let FP_OE= 6
let FP_UE =5
let FP_ZE =4
let FP_XE =3
let FP_NI =2

// Category of instructions (old ones)
// Might be used to know in which functional unit the instruction is executed
let FPARITH = IS_ALU | IS_FLOAT //"17"   // Floating-Point Arithmetic Instructions
let FPMUL = IS_ALU | IS_MUL | IS_FLOAT //"18"
let FPDIV = IS_ALU | IS_DIV | IS_FLOAT //"19"
let FPMADD = IS_ALU | IS_FLOAT //"20"     // FP mul add
let FPRC = IS_ALU | IS_FLOAT | IS_INT //"21" // FP rounding and convert
let FPLOAD = IS_MEM | IS_LOAD | IS_FLOAT //"22"
let FPSTORE = IS_MEM | IS_STORE | IS_FLOAT //"23"
let FPSCRI = IS_INTERN | IS_FLOAT //"24" // FP status and control register instructions
let FPCMP = IS_ALU | IS_FLOAT //"25" // FP compare
let FPMOV = IS_ALU | IS_FLOAT //"26"

// ------------------------------------------------------------------------- //
// 1.2 Types                                                                 //
// ------------------------------------------------------------------------- //
// Declared in ppc.nmp : flot flots xflot sflot


// ------------------------------------------------------------------------- //
// 1.3  Memory and registers                                                 //
// ------------------------------------------------------------------------- //

// Declared in ppc.nmp : reg FPR     [ 2 ** REGS , flot ]


// ------------------------------------------------------------------------- //
// 1.4  Internal variables                                                   //
// ------------------------------------------------------------------------- //

// 1.4.1 variables
// ---------------
reg TMP_FLOT   [ 1 , flot ]
reg TMP_FLOT1  [ 1 , flot ]
reg TMP_FLOTS  [ 1 , flots ]
reg TMP_FLOTS1 [ 1 , flots ]
reg TMP_FLOTS2 [ 1 , flots ]
reg TMP_XFLOT  [ 1 , xflot ]
//reg TMP_YFLOT  [ 1 , sflot ]


// 1.4.2 Aliases
// -------------

// Double Presicion Float

reg TMP_FLOT_A7 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 63 ]

reg TMP_FLOT_A6 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 55 ]

reg TMP_FLOT_A5 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 47 ]

reg TMP_FLOT_A4 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 39 ]

reg TMP_FLOT_A3 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 31 ]

reg TMP_FLOT_A2 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 23 ]

reg TMP_FLOT_A1 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 15 ]

reg TMP_FLOT_A0 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 7 ]

// Single Presicion Float

reg TMP_FLOTS_A3 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 31 ]

reg TMP_FLOTS_A2 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 23 ]

reg TMP_FLOTS_A1 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 15 ]

reg TMP_FLOTS_A0 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 7 ]

// Memory aliases for double and single precision
mem MFLOT64  [ 32 , flot  ] alias = M [0]
mem MFLOTS32 [ 32 , flots ] alias = M [0]


// ------------------------------------------------------------------------- //
// 1.5 Addressing Modes                                                      //
// ------------------------------------------------------------------------- //

mode FREG_IND ( r : index ) = FPR [ r ]
	syntax = format ( "fr%d", r )
	image  = format ( "%5b", r )

// ------------------------------------------------------------------------- //
// 1.6 Macros                                                                //
// ------------------------------------------------------------------------- //

#line 165 "nmp/uisa_fp_instr.nmp"
#line 167 "nmp/uisa_fp_instr.nmp"
#line 173 "nmp/uisa_fp_instr.nmp"
#line 176 "nmp/uisa_fp_instr.nmp"
#line 179 "nmp/uisa_fp_instr.nmp"
// HKC
#line 181 "nmp/uisa_fp_instr.nmp"

#line 197 "nmp/uisa_fp_instr.nmp"
#line 202 "nmp/uisa_fp_instr.nmp"

// /HKC

#line 210 "nmp/uisa_fp_instr.nmp"
// HKC-SET
#line 214 "nmp/uisa_fp_instr.nmp"

//	FP_SET_EXCEPTION(FP_VE, @"FPI_INVALID"); \
//	FP_SET_EXCEPTION(FP_OE, @"FPI_OVERFLOW"); \
//	FP_SET_EXCEPTION(FP_UE, @"FPI_UNDERFLOW"); \
//	FP_SET_EXCEPTION(FP_ZE, @"FPI_DIVBYZERO"); \
//	FP_SET_EXCEPTION(FP_XE, @"FPI_INEXACT"); \
	// THESE TWO MUST BE ALWAYS SET
//	"fpi_clearexcept"(@"FPI_INVALID"); \
//	"fpi_clearexcept"(@"FPI_DIVBYZERO"); \
//	clearFPSCR(FP_FEX); \
// /HKC-SET

#line 229 "nmp/uisa_fp_instr.nmp"
#line 232 "nmp/uisa_fp_instr.nmp"
#line 235 "nmp/uisa_fp_instr.nmp"
#line 238 "nmp/uisa_fp_instr.nmp"
#line 241 "nmp/uisa_fp_instr.nmp"
#line 244 "nmp/uisa_fp_instr.nmp"
#line 247 "nmp/uisa_fp_instr.nmp"
#line 250 "nmp/uisa_fp_instr.nmp"
#line 253 "nmp/uisa_fp_instr.nmp"
#line 256 "nmp/uisa_fp_instr.nmp"
#line 259 "nmp/uisa_fp_instr.nmp"
#line 262 "nmp/uisa_fp_instr.nmp"
#line 265 "nmp/uisa_fp_instr.nmp"
#line 268 "nmp/uisa_fp_instr.nmp"
#line 271 "nmp/uisa_fp_instr.nmp"
#line 274 "nmp/uisa_fp_instr.nmp"
#line 301 "nmp/uisa_fp_instr.nmp"
#line 304 "nmp/uisa_fp_instr.nmp"
#line 307 "nmp/uisa_fp_instr.nmp"
#line 310 "nmp/uisa_fp_instr.nmp"
#line 313 "nmp/uisa_fp_instr.nmp"
#line 316 "nmp/uisa_fp_instr.nmp"
#line 319 "nmp/uisa_fp_instr.nmp"
#line 322 "nmp/uisa_fp_instr.nmp"
#line 325 "nmp/uisa_fp_instr.nmp"
#line 328 "nmp/uisa_fp_instr.nmp"
#line 363 "nmp/uisa_fp_instr.nmp"
#line 424 "nmp/uisa_fp_instr.nmp"
#line 435 "nmp/uisa_fp_instr.nmp"
#line 442 "nmp/uisa_fp_instr.nmp"
#line 452 "nmp/uisa_fp_instr.nmp"
#line 459 "nmp/uisa_fp_instr.nmp"
#line 466 "nmp/uisa_fp_instr.nmp"
#line 474 "nmp/uisa_fp_instr.nmp"
//	FP_COPY_FLAGS; \
//	FP_CHECK_VX_EXCEPTION64(freg); \
//	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
//		FP_CHECK_ZX_EXCEPTION64(); \
//		if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
//			FPR[freg] = result; \
//			FP_CHECK_OX_EXCEPTION; \
//			FP_CHECK_UX_EXCEPTION; \
//			FP_CHECK_XX_EXCEPTION; \
//		endif; \
//	endif; \

#line 494 "nmp/uisa_fp_instr.nmp"
//	FP_COPY_FLAGS; \
//	FP_CHECK_VX_EXCEPTION64(freg); \
//	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
//		FP_CHECK_ZX_EXCEPTION64(); \
//		if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
//			FPR[freg] = result; \
//			//FPR[freg] = result; \
//			FP_CHECK_OX_EXCEPTION; \
//			FP_CHECK_XX_EXCEPTION; \
//			FP_CHECK_UX_EXCEPTION; \
//		endif; \
//	endif; \

#line 522 "nmp/uisa_fp_instr.nmp"
// ========================================================================= //
//  2. Instructions                                                          //
// ========================================================================= //

op uisa_fp_instr ( x: uisa_fp_instr_action )
	syntax = x.syntax
	image  = x.image
	action = {
		if MSR<MSR_FP..MSR_FP> then
			x.action;
		else
			"launch_exception"("instr",FP_UNAVAIL);
		endif;
		}
	otawa_kind = x.otawa_kind

op uisa_fp_instr_action =   ufp_load_store_instr      // fp load/store instructions
                          | ufp_instr                 // fp arithmethic instructions
                          | ufp_status_cr_instr       // fp status/control instructions

// ------------------------------------------------------------------------- //
// 2.1 Floating Point load/store instructions
// ------------------------------------------------------------------------- //

op ufp_load_store_instr =   ufp_load
                          | ufp_store

// 2.1.1 Floating Point load instructions
// --------------------------------------
op ufp_load ( x : ufp_load_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPLOAD

op ufp_load_action =   ufp_load_double
                     | ufp_load_single

// fp load single instructions
op ufp_load_single =   ufp_l_single
                     | ufp_l_single_indexed
                     | ufp_l_single_update
                     | ufp_l_single_update_indexed

op ufp_l_single ( frd : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "lfs fr%d,%s(%s)", frd, d.syntax, ra.syntax )
   image  = format ( "110000%5b%s%16b", frd, ra.image, d.image )
   action = {

		;
#line 571 "nmp/uisa_fp_instr.nmp"
#line 572 "nmp/uisa_fp_instr.nmp"

		TMP_EA = ra + d;
		FPR [ frd ] = MFLOTS32[ TMP_EA ];

		}
  user0 = "1"

op ufp_l_single_indexed ( frd : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "lfsx fr%d,%s,%s", frd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000101110", frd, ra.image, rb.image )
   action = {

		;
#line 584 "nmp/uisa_fp_instr.nmp"
#line 585 "nmp/uisa_fp_instr.nmp"
		FPR [ frd ] = MFLOTS32[ TMP_EA ];

		}
   user0 = "2"

op ufp_l_single_update ( frd : index, ra : index, d : IADDR )
   syntax = format ( "lfsu fr%d,%s(r%d)", frd, d.syntax, ra )
   image  = format ( "110001%5b%5b%16b", frd, ra, d.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		;
#line 599 "nmp/uisa_fp_instr.nmp"
#line 600 "nmp/uisa_fp_instr.nmp"

		FPR [ frd ] = MFLOTS32[ TMP_EA ];
		GPR [ ra ]  = GPR [ ra ] + d;

		}

op ufp_l_single_update_indexed ( frd : index, ra : index, rb : REG_IND )
   syntax = format ( "lfsux fr%d,r%d,%s", frd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s10001101110", frd, ra, rb.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		;
#line 615 "nmp/uisa_fp_instr.nmp"
#line 616 "nmp/uisa_fp_instr.nmp"
		TMP_EA = GPR [ ra ] + rb;

		FPR [ frd ] = MFLOTS32[ TMP_EA ];
		GPR [ ra ] = TMP_EA;

		}

// Floating Point Load Double Precision Instructions

op ufp_load_double =   ufp_l_double
                     | ufp_l_double_indexed
                     | ufp_l_double_update
                     | ufp_l_double_update_indexed

op ufp_l_double ( frd : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "lfd fr%d,%s(%s)", frd, d.syntax, ra.syntax )
   image  = format ( "110010%5b%s%16b", frd, ra.image, d.image )
   action = {
		;
#line 634 "nmp/uisa_fp_instr.nmp"
#line 635 "nmp/uisa_fp_instr.nmp"

		TMP_EA = ra + d;
		FPR [ frd ] = MFLOT64[ TMP_EA ];

		}
  user0 = "1"

op ufp_l_double_indexed ( frd : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "lfdx fr%d,%s,%s", frd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10010101110", frd, ra.image, rb.image )
   action = {

		;
#line 647 "nmp/uisa_fp_instr.nmp"
#line 648 "nmp/uisa_fp_instr.nmp"
		TMP_EA = ra + rb;
		FPR [ frd ] = MFLOT64[ TMP_EA ];

            }
   user0 = "2"

op ufp_l_double_update ( frd : index, ra : index, d : IADDR )
   syntax = format ( "lfdu fr%d,%s(r%d)", frd, d.syntax, ra )
   image  = format ( "110011%5b%5b%16b", frd, ra, d.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		;
#line 663 "nmp/uisa_fp_instr.nmp"
#line 664 "nmp/uisa_fp_instr.nmp"
		TMP_EA = GPR [ ra ] + d;
		FPR [ frd ] = MFLOT64[ TMP_EA ];
		GPR [ ra ]  = TMP_EA;

		}

op ufp_l_double_update_indexed ( frd : index, ra : index, rb : REG_IND )
   syntax = format ( "lfdux fr%d,r%d,%s", frd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s10011101110", frd, ra, rb.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		;
#line 679 "nmp/uisa_fp_instr.nmp"
#line 680 "nmp/uisa_fp_instr.nmp"
		TMP_EA = GPR [ ra ] + rb;
		FPR [ frd ] = MFLOT64[ TMP_EA ];
		GPR [ ra ]  = TMP_EA;

		}

// 2.1.2 Floating Point store instructions
// ---------------------------------------
op ufp_store ( x : ufp_store_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPSTORE

op ufp_store_action =   ufp_store_double
                      | ufp_store_single

// Floating Point Store Single Precision Instructions
op ufp_store_single =   ufp_st_single
                      | ufp_st_single_indexed
                      | ufp_st_single_update
                      | ufp_st_single_update_indexed

op ufp_st_single ( frs : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "stfs fr%d,%s(%s)", frs, d.syntax, ra.syntax )
   image  = format ( "110100%5b%s%16b", frs, ra.image, d.image )
   action = {

		;
#line 708 "nmp/uisa_fp_instr.nmp"
#line 709 "nmp/uisa_fp_instr.nmp"
		TMP_EA = ra + d;
		MFLOTS32[ TMP_EA ] = FPR [ frs ];

		}
  user0 = "6"

op ufp_st_single_indexed ( frs : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "stfsx fr%d,%s,%s", frs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100101110", frs, ra.image, rb.image )
   action = {

		;
#line 720 "nmp/uisa_fp_instr.nmp"
#line 721 "nmp/uisa_fp_instr.nmp"
		TMP_EA = ra + rb;
		MFLOTS32[ TMP_EA ] = FPR [ frs ];
		}
   user0 = "5"

op ufp_st_single_update ( frs : index, ra : index, d : IADDR )
   syntax = format ( "stfsu fr%d,%s(r%d)", frs, d.syntax, ra )
   image  = format ( "110101%5b%5b%16b", frs, ra, d.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		;
#line 735 "nmp/uisa_fp_instr.nmp"
#line 736 "nmp/uisa_fp_instr.nmp"
		TMP_EA = GPR [ ra ] + d;

		MFLOTS32[ TMP_EA ] = FPR [ frs ];
		GPR [ ra ] = TMP_EA;

		}

op ufp_st_single_update_indexed ( frs : index, ra : index, rb : REG_IND )
   syntax = format ( "stfsux fr%d,r%d,%s", frs, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s10101101110", frs, ra, rb.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;


		;
#line 753 "nmp/uisa_fp_instr.nmp"
#line 754 "nmp/uisa_fp_instr.nmp"
		TMP_EA = GPR [ ra ] + rb;

		MFLOTS32[ TMP_EA ] = FPR [ frs ];
		GPR [ ra ] = TMP_EA;

		}

// Floating point Store Double precision Instructions

op ufp_store_double =   ufp_st_double
                      | ufp_st_double_indexed
                      | ufp_st_double_update
                      | ufp_st_double_update_indexed

op ufp_st_double ( frs : index, ra : REG_IND_ZERO, d : IADDR )
   syntax = format ( "stfd fr%d,%s(%s)", frs, d.syntax, ra.syntax )
   image  = format ( "110110%5b%s%16b", frs, ra.image, d.image )
   action = {

		;
#line 773 "nmp/uisa_fp_instr.nmp"
#line 774 "nmp/uisa_fp_instr.nmp"
		TMP_EA = ra + d;

		MFLOT64[ TMP_EA ] = FPR [ frs ];

		}
  user0 = "6"

op ufp_st_double_indexed ( frs : index, ra : REG_IND_ZERO, rb : REG_IND )
   syntax = format ( "stfdx fr%d,%s,%s", frs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10110101110", frs, ra.image, rb.image )
   action = {

		;
#line 786 "nmp/uisa_fp_instr.nmp"
#line 787 "nmp/uisa_fp_instr.nmp"
		TMP_EA = ra + rb;

		MFLOT64[ TMP_EA ] = FPR [ frs ];

		}
   user0 = "5"

op ufp_st_double_update ( frs : index, ra : index, d : IADDR )
   syntax = format ( "stfdu fr%d,%s(r%d)", frs, d.syntax, ra )
   image  = format ( "110111%5b%5b%16b", frs, ra, d.image )
   action = {

	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;

		;
#line 804 "nmp/uisa_fp_instr.nmp"
#line 805 "nmp/uisa_fp_instr.nmp"
		TMP_EA = GPR [ ra ] + d;

		MFLOT64[ TMP_EA ] = FPR [ frs ];

		GPR [ ra ] = TMP_EA;

		}

op ufp_st_double_update_indexed ( frs : index, ra : index, rb : REG_IND )
   syntax = format ( "stfdux fr%d,r%d,%s", frs, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s10111101110", frs, ra, rb.image )
   action = {
	       if (ra==0)
               then
		  "launch_exception"("instr",PROGRAM);
               endif;


		;
#line 823 "nmp/uisa_fp_instr.nmp"
#line 824 "nmp/uisa_fp_instr.nmp"
		TMP_EA = GPR [ ra ] + rb;

		MFLOT64[ TMP_EA ] = FPR [ frs ];
		GPR [ ra ] = TMP_EA;

		}

// ------------------------------------------------------------------------- //
// 2.2 Floating point non load/store instructions
// ------------------------------------------------------------------------- //

op ufp_instr ( x : ufp_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = x.otawa_kind

op ufp_instr_action =   ufp_arithmetic
                      | ufp_mult_add_instr
                      | ufp_compare
                      | ufp_move
                      | ufp_round
                      | ufp_convert

// 2.2.1 Floating point arithmetic instructions
// --------------------------------------------

op ufp_arithmetic =   ufp_add
                    | ufp_subtract
                    | ufp_multiply
                    | ufp_divide

// Floating point add Instructions
op  ufp_add( x : ufp_add_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPARITH

op ufp_add_action =   ufp_add_double
                    | ufp_add_dbl_cr_update
                    | ufp_add_single
                    | ufp_add_sgl_cr_update

op ufp_add_double ( frd : index, fra : index, frb : index )
   syntax = format ( "fadd fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000101010", frd, fra, frb )
   action = {
		;
#line 872 "nmp/uisa_fp_instr.nmp"
#line 873 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 873 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 873 "nmp/uisa_fp_instr.nmp"
#line 874 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = FPR [ fra ] + FPR [ frb ];
			// HKC-SETR
#line 875 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 875 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 875 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
;
#line 875 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 875 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 875 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 875 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 875 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 875 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 875 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 875 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 875 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 875 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 875 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 875 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 875 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 875 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 875 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 875 "nmp/uisa_fp_instr.nmp"
 then 
#line 875 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
	else 
#line 875 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 875 "nmp/uisa_fp_instr.nmp"
 then 
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
		else 
#line 875 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 875 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 875 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 875 "nmp/uisa_fp_instr.nmp"
 then 
#line 875 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
			else 
#line 875 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 875 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 875 "nmp/uisa_fp_instr.nmp"
 then 
#line 875 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
				else 
#line 875 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 875 "nmp/uisa_fp_instr.nmp"
 then 
#line 875 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
					else 
#line 875 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 875 "nmp/uisa_fp_instr.nmp"
 then 
#line 875 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
						else 
#line 875 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 875 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 875 "nmp/uisa_fp_instr.nmp"
 then 
#line 875 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
							else 
#line 875 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 875 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 875 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 875 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 875 "nmp/uisa_fp_instr.nmp"
 then 
#line 875 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
								else 
#line 875 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 875 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 875 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 875 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
			else 
#line 875 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 875 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 875 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 875 "nmp/uisa_fp_instr.nmp"
; 
#line 875 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 875 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 875 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 875 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 875 "nmp/uisa_fp_instr.nmp"
;
#line 875 "nmp/uisa_fp_instr.nmp"
#line 876 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 877 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 877 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 877 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 877 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 877 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 877 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 877 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 877 "nmp/uisa_fp_instr.nmp"
 then
#line 877 "nmp/uisa_fp_instr.nmp"
#line 878 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 878 "nmp/uisa_fp_instr.nmp"
;
#line 878 "nmp/uisa_fp_instr.nmp"
#line 879 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 880 "nmp/uisa_fp_instr.nmp"
;
#line 880 "nmp/uisa_fp_instr.nmp"
#line 881 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
		}

op ufp_add_dbl_cr_update ( frd : index, fra : index, frb : index )
   syntax = format ( "fadd. fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000101011", frd, fra, frb )
   action = {

		;
#line 893 "nmp/uisa_fp_instr.nmp"
#line 894 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 894 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 894 "nmp/uisa_fp_instr.nmp"
#line 895 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = FPR [ fra ] + FPR [ frb ];
			// HKC-SETR
#line 896 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 896 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 896 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
;
#line 896 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 896 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 896 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 896 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 896 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 896 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 896 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 896 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 896 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 896 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 896 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 896 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 896 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 896 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 896 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 896 "nmp/uisa_fp_instr.nmp"
 then 
#line 896 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
	else 
#line 896 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 896 "nmp/uisa_fp_instr.nmp"
 then 
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
		else 
#line 896 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 896 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 896 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 896 "nmp/uisa_fp_instr.nmp"
 then 
#line 896 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
			else 
#line 896 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 896 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 896 "nmp/uisa_fp_instr.nmp"
 then 
#line 896 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
				else 
#line 896 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 896 "nmp/uisa_fp_instr.nmp"
 then 
#line 896 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
					else 
#line 896 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 896 "nmp/uisa_fp_instr.nmp"
 then 
#line 896 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
						else 
#line 896 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 896 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 896 "nmp/uisa_fp_instr.nmp"
 then 
#line 896 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
							else 
#line 896 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 896 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 896 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 896 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 896 "nmp/uisa_fp_instr.nmp"
 then 
#line 896 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
								else 
#line 896 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 896 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 896 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 896 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
			else 
#line 896 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 896 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 896 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 896 "nmp/uisa_fp_instr.nmp"
; 
#line 896 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 896 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 896 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 896 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 896 "nmp/uisa_fp_instr.nmp"
;
#line 896 "nmp/uisa_fp_instr.nmp"
#line 897 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 898 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 898 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 898 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 898 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 898 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 898 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 898 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 898 "nmp/uisa_fp_instr.nmp"
 then
#line 898 "nmp/uisa_fp_instr.nmp"
#line 899 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 899 "nmp/uisa_fp_instr.nmp"
;
#line 899 "nmp/uisa_fp_instr.nmp"
#line 900 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 901 "nmp/uisa_fp_instr.nmp"
;
#line 901 "nmp/uisa_fp_instr.nmp"
#line 902 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
        	    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 907 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 907 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 907 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 907 "nmp/uisa_fp_instr.nmp"
;
#line 907 "nmp/uisa_fp_instr.nmp"
#line 908 "nmp/uisa_fp_instr.nmp"
		endif;
		}

op ufp_add_single ( frd : index, fra : index, frb : index )
   syntax = format ( "fadds fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000101010", frd, fra, frb )
   action = {

		;
#line 916 "nmp/uisa_fp_instr.nmp"
#line 917 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 917 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 917 "nmp/uisa_fp_instr.nmp"
#line 918 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = FPR[fra] + FPR[frb];
			// HKC-SETR
#line 919 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 919 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 919 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
;
#line 919 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 919 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 919 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 919 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 919 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 919 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 919 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 919 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 919 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 919 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 919 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 919 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 919 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 919 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 919 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 919 "nmp/uisa_fp_instr.nmp"
 then 
#line 919 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
	else 
#line 919 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 919 "nmp/uisa_fp_instr.nmp"
 then 
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
		else 
#line 919 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 919 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 919 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 919 "nmp/uisa_fp_instr.nmp"
 then 
#line 919 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
			else 
#line 919 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 919 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 919 "nmp/uisa_fp_instr.nmp"
 then 
#line 919 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
				else 
#line 919 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 919 "nmp/uisa_fp_instr.nmp"
 then 
#line 919 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
					else 
#line 919 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 919 "nmp/uisa_fp_instr.nmp"
 then 
#line 919 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
						else 
#line 919 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 919 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 919 "nmp/uisa_fp_instr.nmp"
 then 
#line 919 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
							else 
#line 919 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 919 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 919 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 919 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 919 "nmp/uisa_fp_instr.nmp"
 then 
#line 919 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
								else 
#line 919 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 919 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 919 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 919 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
			else 
#line 919 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 919 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 919 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 919 "nmp/uisa_fp_instr.nmp"
; 
#line 919 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 919 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 919 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 919 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 919 "nmp/uisa_fp_instr.nmp"
;
#line 919 "nmp/uisa_fp_instr.nmp"
#line 920 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 921 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 921 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 921 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 921 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 921 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 921 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 921 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 921 "nmp/uisa_fp_instr.nmp"
 then
#line 921 "nmp/uisa_fp_instr.nmp"
#line 922 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 922 "nmp/uisa_fp_instr.nmp"
;
#line 922 "nmp/uisa_fp_instr.nmp"
#line 923 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 924 "nmp/uisa_fp_instr.nmp"
;
#line 924 "nmp/uisa_fp_instr.nmp"
#line 925 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;

    	}

op ufp_add_sgl_cr_update ( frd : index, fra : index, frb : index )
   syntax = format ( "fadds. fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000101011", frd, fra, frb )
   action = {

		;
#line 938 "nmp/uisa_fp_instr.nmp"
#line 939 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 939 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 939 "nmp/uisa_fp_instr.nmp"
#line 940 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = FPR[fra] + FPR[frb];
			// HKC-SETR
#line 941 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 941 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 941 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
;
#line 941 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 941 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 941 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 941 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 941 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 941 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 941 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 941 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 941 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 941 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 941 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 941 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 941 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 941 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 941 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 941 "nmp/uisa_fp_instr.nmp"
 then 
#line 941 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
	else 
#line 941 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 941 "nmp/uisa_fp_instr.nmp"
 then 
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
		else 
#line 941 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 941 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 941 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 941 "nmp/uisa_fp_instr.nmp"
 then 
#line 941 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
			else 
#line 941 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 941 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 941 "nmp/uisa_fp_instr.nmp"
 then 
#line 941 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
				else 
#line 941 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 941 "nmp/uisa_fp_instr.nmp"
 then 
#line 941 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
					else 
#line 941 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 941 "nmp/uisa_fp_instr.nmp"
 then 
#line 941 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
						else 
#line 941 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 941 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 941 "nmp/uisa_fp_instr.nmp"
 then 
#line 941 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
							else 
#line 941 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 941 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 941 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 941 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 941 "nmp/uisa_fp_instr.nmp"
 then 
#line 941 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
								else 
#line 941 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 941 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 941 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 941 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
			else 
#line 941 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 941 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 941 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 941 "nmp/uisa_fp_instr.nmp"
; 
#line 941 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 941 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 941 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 941 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 941 "nmp/uisa_fp_instr.nmp"
;
#line 941 "nmp/uisa_fp_instr.nmp"
#line 942 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 943 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 943 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 943 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 943 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 943 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 943 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 943 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 943 "nmp/uisa_fp_instr.nmp"
 then
#line 943 "nmp/uisa_fp_instr.nmp"
#line 944 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 944 "nmp/uisa_fp_instr.nmp"
;
#line 944 "nmp/uisa_fp_instr.nmp"
#line 945 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 946 "nmp/uisa_fp_instr.nmp"
;
#line 946 "nmp/uisa_fp_instr.nmp"
#line 947 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 952 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 952 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 952 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 952 "nmp/uisa_fp_instr.nmp"
;
#line 952 "nmp/uisa_fp_instr.nmp"
#line 953 "nmp/uisa_fp_instr.nmp"
		endif;

		}

// Floating point Subtract Instructions
op  ufp_subtract( x : ufp_subtract_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPARITH

op ufp_subtract_action =   ufp_sub_double
                         | ufp_sub_dbl_cr_update
                         | ufp_sub_single
                         | ufp_sub_sgl_cr_update

op ufp_sub_double ( frd : index, fra : index, frb : index )
   syntax = format ( "fsub fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000101000", frd, fra, frb )
   action = {
   		;
#line 973 "nmp/uisa_fp_instr.nmp"
#line 974 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 974 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 974 "nmp/uisa_fp_instr.nmp"
#line 975 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = FPR [ fra ] - FPR [ frb ];
			// HKC-SETR
#line 976 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 976 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 976 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
;
#line 976 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 976 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 976 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 976 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 976 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 976 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 976 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 976 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 976 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 976 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 976 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 976 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 976 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 976 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 976 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 976 "nmp/uisa_fp_instr.nmp"
 then 
#line 976 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
	else 
#line 976 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 976 "nmp/uisa_fp_instr.nmp"
 then 
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
		else 
#line 976 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 976 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 976 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 976 "nmp/uisa_fp_instr.nmp"
 then 
#line 976 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
			else 
#line 976 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 976 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 976 "nmp/uisa_fp_instr.nmp"
 then 
#line 976 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
				else 
#line 976 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 976 "nmp/uisa_fp_instr.nmp"
 then 
#line 976 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
					else 
#line 976 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 976 "nmp/uisa_fp_instr.nmp"
 then 
#line 976 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
						else 
#line 976 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 976 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 976 "nmp/uisa_fp_instr.nmp"
 then 
#line 976 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
							else 
#line 976 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 976 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 976 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 976 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 976 "nmp/uisa_fp_instr.nmp"
 then 
#line 976 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
								else 
#line 976 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 976 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 976 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 976 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
			else 
#line 976 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 976 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 976 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 976 "nmp/uisa_fp_instr.nmp"
; 
#line 976 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 976 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 976 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 976 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 976 "nmp/uisa_fp_instr.nmp"
;
#line 976 "nmp/uisa_fp_instr.nmp"
#line 977 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 978 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 978 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 978 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 978 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 978 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 978 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 978 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 978 "nmp/uisa_fp_instr.nmp"
 then
#line 978 "nmp/uisa_fp_instr.nmp"
#line 979 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 979 "nmp/uisa_fp_instr.nmp"
;
#line 979 "nmp/uisa_fp_instr.nmp"
#line 980 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 981 "nmp/uisa_fp_instr.nmp"
;
#line 981 "nmp/uisa_fp_instr.nmp"
#line 982 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
      	}

op ufp_sub_dbl_cr_update ( frd : index, fra : index, frb : index )
   syntax = format ( "fsub. fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000101001", frd, fra, frb )
   action = {

   		;
#line 994 "nmp/uisa_fp_instr.nmp"
#line 995 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 995 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 995 "nmp/uisa_fp_instr.nmp"
#line 996 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = FPR [ fra ] - FPR [ frb ];
			// HKC-SETR
#line 997 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 997 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 997 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
;
#line 997 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 997 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 997 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 997 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 997 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 997 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 997 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 997 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 997 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 997 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 997 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 997 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 997 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 997 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 997 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 997 "nmp/uisa_fp_instr.nmp"
 then 
#line 997 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
	else 
#line 997 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 997 "nmp/uisa_fp_instr.nmp"
 then 
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
		else 
#line 997 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 997 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 997 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 997 "nmp/uisa_fp_instr.nmp"
 then 
#line 997 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
			else 
#line 997 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 997 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 997 "nmp/uisa_fp_instr.nmp"
 then 
#line 997 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
				else 
#line 997 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 997 "nmp/uisa_fp_instr.nmp"
 then 
#line 997 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
					else 
#line 997 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 997 "nmp/uisa_fp_instr.nmp"
 then 
#line 997 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
						else 
#line 997 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 997 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 997 "nmp/uisa_fp_instr.nmp"
 then 
#line 997 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
							else 
#line 997 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 997 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 997 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 997 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 997 "nmp/uisa_fp_instr.nmp"
 then 
#line 997 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
								else 
#line 997 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 997 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 997 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 997 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
			else 
#line 997 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 997 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 997 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 997 "nmp/uisa_fp_instr.nmp"
; 
#line 997 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 997 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 997 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 997 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 997 "nmp/uisa_fp_instr.nmp"
;
#line 997 "nmp/uisa_fp_instr.nmp"
#line 998 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 999 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 999 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 999 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 999 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 999 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 999 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 999 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 999 "nmp/uisa_fp_instr.nmp"
 then
#line 999 "nmp/uisa_fp_instr.nmp"
#line 1000 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1000 "nmp/uisa_fp_instr.nmp"
;
#line 1000 "nmp/uisa_fp_instr.nmp"
#line 1001 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1002 "nmp/uisa_fp_instr.nmp"
;
#line 1002 "nmp/uisa_fp_instr.nmp"
#line 1003 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1008 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1008 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1008 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1008 "nmp/uisa_fp_instr.nmp"
;
#line 1008 "nmp/uisa_fp_instr.nmp"
#line 1009 "nmp/uisa_fp_instr.nmp"
		endif;
      	}

op ufp_sub_single ( frd : index, fra : index, frb : index )
   syntax = format ( "fsubs fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000101000", frd, fra, frb )
   action = {

		;
#line 1017 "nmp/uisa_fp_instr.nmp"
#line 1018 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1018 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1018 "nmp/uisa_fp_instr.nmp"
#line 1019 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = FPR[fra] - FPR[frb];
			// HKC-SETR
#line 1020 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1020 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1020 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
;
#line 1020 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1020 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1020 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1020 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1020 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1020 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1020 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1020 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1020 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1020 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1020 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1020 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1020 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1020 "nmp/uisa_fp_instr.nmp"
 then 
#line 1020 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
	else 
#line 1020 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1020 "nmp/uisa_fp_instr.nmp"
 then 
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
		else 
#line 1020 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1020 "nmp/uisa_fp_instr.nmp"
 then 
#line 1020 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			else 
#line 1020 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1020 "nmp/uisa_fp_instr.nmp"
 then 
#line 1020 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
				else 
#line 1020 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1020 "nmp/uisa_fp_instr.nmp"
 then 
#line 1020 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
					else 
#line 1020 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1020 "nmp/uisa_fp_instr.nmp"
 then 
#line 1020 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
						else 
#line 1020 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1020 "nmp/uisa_fp_instr.nmp"
 then 
#line 1020 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
							else 
#line 1020 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1020 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1020 "nmp/uisa_fp_instr.nmp"
 then 
#line 1020 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
								else 
#line 1020 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1020 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1020 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1020 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			else 
#line 1020 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1020 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1020 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1020 "nmp/uisa_fp_instr.nmp"
; 
#line 1020 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1020 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1020 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1020 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1020 "nmp/uisa_fp_instr.nmp"
;
#line 1020 "nmp/uisa_fp_instr.nmp"
#line 1021 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1022 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1022 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1022 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1022 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1022 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1022 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1022 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1022 "nmp/uisa_fp_instr.nmp"
 then
#line 1022 "nmp/uisa_fp_instr.nmp"
#line 1023 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1023 "nmp/uisa_fp_instr.nmp"
;
#line 1023 "nmp/uisa_fp_instr.nmp"
#line 1024 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1025 "nmp/uisa_fp_instr.nmp"
;
#line 1025 "nmp/uisa_fp_instr.nmp"
#line 1026 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
		}

op ufp_sub_sgl_cr_update ( frd : index, fra : index, frb : index )
   syntax = format ( "fsubs. fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000101001", frd, fra, frb )
   action = {

		;
#line 1038 "nmp/uisa_fp_instr.nmp"
#line 1039 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1039 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1039 "nmp/uisa_fp_instr.nmp"
#line 1040 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = FPR[fra] - FPR[frb];
			// HKC-SETR
#line 1041 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1041 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1041 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
;
#line 1041 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1041 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1041 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1041 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1041 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1041 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1041 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1041 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1041 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1041 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1041 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1041 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1041 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1041 "nmp/uisa_fp_instr.nmp"
 then 
#line 1041 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
	else 
#line 1041 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1041 "nmp/uisa_fp_instr.nmp"
 then 
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
		else 
#line 1041 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1041 "nmp/uisa_fp_instr.nmp"
 then 
#line 1041 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			else 
#line 1041 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1041 "nmp/uisa_fp_instr.nmp"
 then 
#line 1041 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
				else 
#line 1041 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1041 "nmp/uisa_fp_instr.nmp"
 then 
#line 1041 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
					else 
#line 1041 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1041 "nmp/uisa_fp_instr.nmp"
 then 
#line 1041 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
						else 
#line 1041 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1041 "nmp/uisa_fp_instr.nmp"
 then 
#line 1041 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
							else 
#line 1041 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1041 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1041 "nmp/uisa_fp_instr.nmp"
 then 
#line 1041 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
								else 
#line 1041 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1041 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1041 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1041 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			else 
#line 1041 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1041 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1041 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1041 "nmp/uisa_fp_instr.nmp"
; 
#line 1041 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1041 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1041 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1041 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1041 "nmp/uisa_fp_instr.nmp"
;
#line 1041 "nmp/uisa_fp_instr.nmp"
#line 1042 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1043 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1043 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1043 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1043 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1043 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1043 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1043 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1043 "nmp/uisa_fp_instr.nmp"
 then
#line 1043 "nmp/uisa_fp_instr.nmp"
#line 1044 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1044 "nmp/uisa_fp_instr.nmp"
;
#line 1044 "nmp/uisa_fp_instr.nmp"
#line 1045 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1046 "nmp/uisa_fp_instr.nmp"
;
#line 1046 "nmp/uisa_fp_instr.nmp"
#line 1047 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1052 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1052 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1052 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1052 "nmp/uisa_fp_instr.nmp"
;
#line 1052 "nmp/uisa_fp_instr.nmp"
#line 1053 "nmp/uisa_fp_instr.nmp"
		endif;

        }

// Floating point Multiply Instructions
op  ufp_multiply ( x : ufp_multiply_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPMUL

op ufp_multiply_action =   ufp_mult_double
                         | ufp_mult_dbl_cr_update
                         | ufp_mult_single
                         | ufp_mult_sgl_cr_update

op ufp_mult_double ( frd : index, fra : index, frc : index )
   syntax = format ( "fmul fr%d,fr%d,fr%d", frd, fra, frc )
   image  = format ( "111111%5b%5b00000%5b110010", frd, fra, frc )
   action = {
		;
#line 1073 "nmp/uisa_fp_instr.nmp"
#line 1074 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1074 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1074 "nmp/uisa_fp_instr.nmp"
#line 1075 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = FPR [ fra ] * FPR [ frc ];
			// HKC-SETR
#line 1076 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1076 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1076 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
;
#line 1076 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1076 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1076 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1076 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1076 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1076 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1076 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1076 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1076 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1076 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1076 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1076 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1076 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1076 "nmp/uisa_fp_instr.nmp"
 then 
#line 1076 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
	else 
#line 1076 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1076 "nmp/uisa_fp_instr.nmp"
 then 
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
		else 
#line 1076 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1076 "nmp/uisa_fp_instr.nmp"
 then 
#line 1076 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			else 
#line 1076 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1076 "nmp/uisa_fp_instr.nmp"
 then 
#line 1076 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
				else 
#line 1076 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1076 "nmp/uisa_fp_instr.nmp"
 then 
#line 1076 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
					else 
#line 1076 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1076 "nmp/uisa_fp_instr.nmp"
 then 
#line 1076 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
						else 
#line 1076 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1076 "nmp/uisa_fp_instr.nmp"
 then 
#line 1076 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
							else 
#line 1076 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1076 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1076 "nmp/uisa_fp_instr.nmp"
 then 
#line 1076 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
								else 
#line 1076 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1076 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1076 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1076 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			else 
#line 1076 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1076 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1076 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1076 "nmp/uisa_fp_instr.nmp"
; 
#line 1076 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1076 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1076 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1076 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1076 "nmp/uisa_fp_instr.nmp"
;
#line 1076 "nmp/uisa_fp_instr.nmp"
#line 1077 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1078 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1078 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1078 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1078 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1078 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1078 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1078 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1078 "nmp/uisa_fp_instr.nmp"
 then
#line 1078 "nmp/uisa_fp_instr.nmp"
#line 1079 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1079 "nmp/uisa_fp_instr.nmp"
;
#line 1079 "nmp/uisa_fp_instr.nmp"
#line 1080 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1081 "nmp/uisa_fp_instr.nmp"
;
#line 1081 "nmp/uisa_fp_instr.nmp"
#line 1082 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;

        }

op ufp_mult_dbl_cr_update ( frd : index, fra : index, frc : index )
   syntax = format ( "fmul. fr%d,fr%d,fr%d", frd, fra, frc )
   image  = format ( "111111%5b%5b00000%5b110011", frd, fra, frc )
   action = {

        ;
#line 1095 "nmp/uisa_fp_instr.nmp"
#line 1096 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1096 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1096 "nmp/uisa_fp_instr.nmp"
#line 1097 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = FPR [ fra ] * FPR [ frc ];
			// HKC-SETR
#line 1098 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1098 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1098 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
;
#line 1098 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1098 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1098 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1098 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1098 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1098 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1098 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1098 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1098 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1098 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1098 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1098 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1098 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1098 "nmp/uisa_fp_instr.nmp"
 then 
#line 1098 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
	else 
#line 1098 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1098 "nmp/uisa_fp_instr.nmp"
 then 
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
		else 
#line 1098 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1098 "nmp/uisa_fp_instr.nmp"
 then 
#line 1098 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			else 
#line 1098 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1098 "nmp/uisa_fp_instr.nmp"
 then 
#line 1098 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
				else 
#line 1098 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1098 "nmp/uisa_fp_instr.nmp"
 then 
#line 1098 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
					else 
#line 1098 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1098 "nmp/uisa_fp_instr.nmp"
 then 
#line 1098 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
						else 
#line 1098 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1098 "nmp/uisa_fp_instr.nmp"
 then 
#line 1098 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
							else 
#line 1098 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1098 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1098 "nmp/uisa_fp_instr.nmp"
 then 
#line 1098 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
								else 
#line 1098 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1098 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1098 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1098 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			else 
#line 1098 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1098 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1098 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1098 "nmp/uisa_fp_instr.nmp"
; 
#line 1098 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1098 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1098 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1098 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1098 "nmp/uisa_fp_instr.nmp"
;
#line 1098 "nmp/uisa_fp_instr.nmp"
#line 1099 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1100 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1100 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1100 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1100 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1100 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1100 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1100 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1100 "nmp/uisa_fp_instr.nmp"
 then
#line 1100 "nmp/uisa_fp_instr.nmp"
#line 1101 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1101 "nmp/uisa_fp_instr.nmp"
;
#line 1101 "nmp/uisa_fp_instr.nmp"
#line 1102 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1103 "nmp/uisa_fp_instr.nmp"
;
#line 1103 "nmp/uisa_fp_instr.nmp"
#line 1104 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1109 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1109 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1109 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1109 "nmp/uisa_fp_instr.nmp"
;
#line 1109 "nmp/uisa_fp_instr.nmp"
#line 1110 "nmp/uisa_fp_instr.nmp"
		endif;

		}

op ufp_mult_single ( frd : index, fra : index, frc : index )
   syntax = format ( "fmuls fr%d,fr%d,fr%d", frd, fra, frc )
   image  = format ( "111011%5b%5b00000%5b110010", frd, fra, frc )
   action = {

		;
#line 1119 "nmp/uisa_fp_instr.nmp"
#line 1120 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1120 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1120 "nmp/uisa_fp_instr.nmp"
#line 1121 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = FPR[fra] * FPR[frc];
			// HKC-SETR
#line 1122 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1122 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1122 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
;
#line 1122 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1122 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1122 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1122 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1122 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1122 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1122 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1122 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1122 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1122 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1122 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1122 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1122 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1122 "nmp/uisa_fp_instr.nmp"
 then 
#line 1122 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
	else 
#line 1122 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1122 "nmp/uisa_fp_instr.nmp"
 then 
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
		else 
#line 1122 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1122 "nmp/uisa_fp_instr.nmp"
 then 
#line 1122 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			else 
#line 1122 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1122 "nmp/uisa_fp_instr.nmp"
 then 
#line 1122 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
				else 
#line 1122 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1122 "nmp/uisa_fp_instr.nmp"
 then 
#line 1122 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
					else 
#line 1122 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1122 "nmp/uisa_fp_instr.nmp"
 then 
#line 1122 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
						else 
#line 1122 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1122 "nmp/uisa_fp_instr.nmp"
 then 
#line 1122 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
							else 
#line 1122 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1122 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1122 "nmp/uisa_fp_instr.nmp"
 then 
#line 1122 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
								else 
#line 1122 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1122 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1122 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1122 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			else 
#line 1122 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1122 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1122 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1122 "nmp/uisa_fp_instr.nmp"
; 
#line 1122 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1122 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1122 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1122 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1122 "nmp/uisa_fp_instr.nmp"
;
#line 1122 "nmp/uisa_fp_instr.nmp"
#line 1123 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS;
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1125 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1125 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1125 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1125 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1125 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1125 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1125 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1125 "nmp/uisa_fp_instr.nmp"
 then
#line 1125 "nmp/uisa_fp_instr.nmp"
#line 1126 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1126 "nmp/uisa_fp_instr.nmp"
;
#line 1126 "nmp/uisa_fp_instr.nmp"
#line 1127 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1128 "nmp/uisa_fp_instr.nmp"
;
#line 1128 "nmp/uisa_fp_instr.nmp"
#line 1129 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
		}

op ufp_mult_sgl_cr_update ( frd : index, fra : index, frc : index )
   syntax = format ( "fmuls. fr%d,fr%d,fr%d", frd, fra, frc )
   image  = format ( "111011%5b%5b00000%5b110011", frd, fra, frc )
   action = {

		;
#line 1141 "nmp/uisa_fp_instr.nmp"
#line 1142 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1142 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1142 "nmp/uisa_fp_instr.nmp"
#line 1143 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = FPR[fra] * FPR[frc];
			// HKC-SETR
#line 1144 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1144 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1144 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
;
#line 1144 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1144 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1144 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1144 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1144 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1144 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1144 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1144 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1144 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1144 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1144 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1144 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1144 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1144 "nmp/uisa_fp_instr.nmp"
 then 
#line 1144 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
	else 
#line 1144 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1144 "nmp/uisa_fp_instr.nmp"
 then 
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
		else 
#line 1144 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1144 "nmp/uisa_fp_instr.nmp"
 then 
#line 1144 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			else 
#line 1144 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1144 "nmp/uisa_fp_instr.nmp"
 then 
#line 1144 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
				else 
#line 1144 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1144 "nmp/uisa_fp_instr.nmp"
 then 
#line 1144 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
					else 
#line 1144 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1144 "nmp/uisa_fp_instr.nmp"
 then 
#line 1144 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
						else 
#line 1144 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1144 "nmp/uisa_fp_instr.nmp"
 then 
#line 1144 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
							else 
#line 1144 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1144 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1144 "nmp/uisa_fp_instr.nmp"
 then 
#line 1144 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
								else 
#line 1144 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1144 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1144 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1144 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			else 
#line 1144 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1144 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1144 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1144 "nmp/uisa_fp_instr.nmp"
; 
#line 1144 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1144 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1144 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1144 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1144 "nmp/uisa_fp_instr.nmp"
;
#line 1144 "nmp/uisa_fp_instr.nmp"
#line 1145 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1146 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1146 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1146 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1146 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1146 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1146 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1146 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1146 "nmp/uisa_fp_instr.nmp"
 then
#line 1146 "nmp/uisa_fp_instr.nmp"
#line 1147 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1147 "nmp/uisa_fp_instr.nmp"
;
#line 1147 "nmp/uisa_fp_instr.nmp"
#line 1148 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1149 "nmp/uisa_fp_instr.nmp"
;
#line 1149 "nmp/uisa_fp_instr.nmp"
#line 1150 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX>then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1155 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1155 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1155 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1155 "nmp/uisa_fp_instr.nmp"
;
#line 1155 "nmp/uisa_fp_instr.nmp"
#line 1156 "nmp/uisa_fp_instr.nmp"
		endif;
            }

// Floating point Divide Instructions
op  ufp_divide( x : ufp_divide_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPDIV

op ufp_divide_action =   ufp_div_double
                       | ufp_div_dbl_cr_update
                       | ufp_div_single
                       | ufp_div_sgl_cr_update

op ufp_div_double ( frd : index, fra : index, frb : index )
   syntax = format ( "fdiv fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000100100", frd, fra, frb )
   action = {

 		;
#line 1176 "nmp/uisa_fp_instr.nmp"
#line 1177 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1177 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1177 "nmp/uisa_fp_instr.nmp"
#line 1178 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = FPR [ fra ] / FPR [ frb ];
			// HKC-SETR
#line 1179 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1179 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1179 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
;
#line 1179 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1179 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1179 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1179 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1179 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1179 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1179 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1179 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1179 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1179 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1179 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1179 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1179 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1179 "nmp/uisa_fp_instr.nmp"
 then 
#line 1179 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
	else 
#line 1179 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1179 "nmp/uisa_fp_instr.nmp"
 then 
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
		else 
#line 1179 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1179 "nmp/uisa_fp_instr.nmp"
 then 
#line 1179 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			else 
#line 1179 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1179 "nmp/uisa_fp_instr.nmp"
 then 
#line 1179 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
				else 
#line 1179 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1179 "nmp/uisa_fp_instr.nmp"
 then 
#line 1179 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
					else 
#line 1179 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1179 "nmp/uisa_fp_instr.nmp"
 then 
#line 1179 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
						else 
#line 1179 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1179 "nmp/uisa_fp_instr.nmp"
 then 
#line 1179 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
							else 
#line 1179 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1179 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1179 "nmp/uisa_fp_instr.nmp"
 then 
#line 1179 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
								else 
#line 1179 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1179 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1179 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1179 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			else 
#line 1179 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1179 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1179 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1179 "nmp/uisa_fp_instr.nmp"
; 
#line 1179 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1179 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1179 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1179 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1179 "nmp/uisa_fp_instr.nmp"
;
#line 1179 "nmp/uisa_fp_instr.nmp"
#line 1180 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1181 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1181 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1181 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1181 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1181 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1181 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1181 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1181 "nmp/uisa_fp_instr.nmp"
 then
#line 1181 "nmp/uisa_fp_instr.nmp"
#line 1182 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1182 "nmp/uisa_fp_instr.nmp"
;
#line 1182 "nmp/uisa_fp_instr.nmp"
#line 1183 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1184 "nmp/uisa_fp_instr.nmp"
;
#line 1184 "nmp/uisa_fp_instr.nmp"
#line 1185 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
		}

op ufp_div_dbl_cr_update ( frd : index, fra : index, frb : index )
   syntax = format ( "fdiv. fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000100101", frd, fra, frb )
   action = {

 		;
#line 1197 "nmp/uisa_fp_instr.nmp"
#line 1198 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1198 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1198 "nmp/uisa_fp_instr.nmp"
#line 1199 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = FPR [ fra ] / FPR [ frb ];
			// HKC-SETR
#line 1200 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1200 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1200 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
;
#line 1200 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1200 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1200 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1200 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1200 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1200 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1200 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1200 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1200 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1200 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1200 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1200 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1200 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1200 "nmp/uisa_fp_instr.nmp"
 then 
#line 1200 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
	else 
#line 1200 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1200 "nmp/uisa_fp_instr.nmp"
 then 
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
		else 
#line 1200 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1200 "nmp/uisa_fp_instr.nmp"
 then 
#line 1200 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			else 
#line 1200 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1200 "nmp/uisa_fp_instr.nmp"
 then 
#line 1200 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
				else 
#line 1200 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1200 "nmp/uisa_fp_instr.nmp"
 then 
#line 1200 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
					else 
#line 1200 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1200 "nmp/uisa_fp_instr.nmp"
 then 
#line 1200 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
						else 
#line 1200 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1200 "nmp/uisa_fp_instr.nmp"
 then 
#line 1200 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
							else 
#line 1200 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1200 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1200 "nmp/uisa_fp_instr.nmp"
 then 
#line 1200 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
								else 
#line 1200 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1200 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1200 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1200 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			else 
#line 1200 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1200 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1200 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1200 "nmp/uisa_fp_instr.nmp"
; 
#line 1200 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1200 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1200 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1200 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1200 "nmp/uisa_fp_instr.nmp"
;
#line 1200 "nmp/uisa_fp_instr.nmp"
#line 1201 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1202 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1202 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1202 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1202 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1202 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1202 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1202 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1202 "nmp/uisa_fp_instr.nmp"
 then
#line 1202 "nmp/uisa_fp_instr.nmp"
#line 1203 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1203 "nmp/uisa_fp_instr.nmp"
;
#line 1203 "nmp/uisa_fp_instr.nmp"
#line 1204 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1205 "nmp/uisa_fp_instr.nmp"
;
#line 1205 "nmp/uisa_fp_instr.nmp"
#line 1206 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1211 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1211 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1211 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1211 "nmp/uisa_fp_instr.nmp"
;
#line 1211 "nmp/uisa_fp_instr.nmp"
#line 1212 "nmp/uisa_fp_instr.nmp"
		endif;

        }

op ufp_div_single ( frd : index, fra : index, frb : index )
   syntax = format ( "fdivs fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000100100", frd, fra, frb )
   action = {

 		;
#line 1221 "nmp/uisa_fp_instr.nmp"
#line 1222 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1222 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1222 "nmp/uisa_fp_instr.nmp"
#line 1223 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = FPR[fra]/FPR[frb];
			// HKC-SETR
#line 1224 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1224 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1224 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
;
#line 1224 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1224 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1224 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1224 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1224 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1224 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1224 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1224 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1224 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1224 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1224 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1224 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1224 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1224 "nmp/uisa_fp_instr.nmp"
 then 
#line 1224 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
	else 
#line 1224 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1224 "nmp/uisa_fp_instr.nmp"
 then 
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
		else 
#line 1224 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1224 "nmp/uisa_fp_instr.nmp"
 then 
#line 1224 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			else 
#line 1224 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1224 "nmp/uisa_fp_instr.nmp"
 then 
#line 1224 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
				else 
#line 1224 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1224 "nmp/uisa_fp_instr.nmp"
 then 
#line 1224 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
					else 
#line 1224 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1224 "nmp/uisa_fp_instr.nmp"
 then 
#line 1224 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
						else 
#line 1224 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1224 "nmp/uisa_fp_instr.nmp"
 then 
#line 1224 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
							else 
#line 1224 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1224 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1224 "nmp/uisa_fp_instr.nmp"
 then 
#line 1224 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
								else 
#line 1224 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1224 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1224 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1224 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			else 
#line 1224 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1224 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1224 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1224 "nmp/uisa_fp_instr.nmp"
; 
#line 1224 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1224 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1224 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1224 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1224 "nmp/uisa_fp_instr.nmp"
;
#line 1224 "nmp/uisa_fp_instr.nmp"
#line 1225 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1226 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1226 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1226 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1226 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1226 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1226 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1226 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1226 "nmp/uisa_fp_instr.nmp"
 then
#line 1226 "nmp/uisa_fp_instr.nmp"
#line 1227 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1227 "nmp/uisa_fp_instr.nmp"
;
#line 1227 "nmp/uisa_fp_instr.nmp"
#line 1228 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1229 "nmp/uisa_fp_instr.nmp"
;
#line 1229 "nmp/uisa_fp_instr.nmp"
#line 1230 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
        }

op ufp_div_sgl_cr_update ( frd : index, fra : index, frb : index )
   syntax = format ( "fdivs. fr%d,fr%d,fr%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000100101", frd, fra, frb )
   action = {

		;
#line 1242 "nmp/uisa_fp_instr.nmp"
#line 1243 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1243 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1243 "nmp/uisa_fp_instr.nmp"
#line 1244 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = FPR[fra]/FPR[frb];
			// HKC-SETR
#line 1245 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1245 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1245 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
;
#line 1245 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1245 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1245 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1245 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1245 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1245 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1245 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1245 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1245 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1245 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1245 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1245 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1245 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1245 "nmp/uisa_fp_instr.nmp"
 then 
#line 1245 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
	else 
#line 1245 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1245 "nmp/uisa_fp_instr.nmp"
 then 
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
		else 
#line 1245 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1245 "nmp/uisa_fp_instr.nmp"
 then 
#line 1245 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			else 
#line 1245 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1245 "nmp/uisa_fp_instr.nmp"
 then 
#line 1245 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
				else 
#line 1245 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1245 "nmp/uisa_fp_instr.nmp"
 then 
#line 1245 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
					else 
#line 1245 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1245 "nmp/uisa_fp_instr.nmp"
 then 
#line 1245 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
						else 
#line 1245 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1245 "nmp/uisa_fp_instr.nmp"
 then 
#line 1245 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
							else 
#line 1245 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1245 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1245 "nmp/uisa_fp_instr.nmp"
 then 
#line 1245 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
								else 
#line 1245 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1245 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1245 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1245 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			else 
#line 1245 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1245 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1245 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1245 "nmp/uisa_fp_instr.nmp"
; 
#line 1245 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1245 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1245 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1245 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1245 "nmp/uisa_fp_instr.nmp"
;
#line 1245 "nmp/uisa_fp_instr.nmp"
#line 1246 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1247 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1247 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1247 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1247 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1247 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1247 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1247 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1247 "nmp/uisa_fp_instr.nmp"
 then
#line 1247 "nmp/uisa_fp_instr.nmp"
#line 1248 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1248 "nmp/uisa_fp_instr.nmp"
;
#line 1248 "nmp/uisa_fp_instr.nmp"
#line 1249 "nmp/uisa_fp_instr.nmp"
			else
					FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1250 "nmp/uisa_fp_instr.nmp"
;
#line 1250 "nmp/uisa_fp_instr.nmp"
#line 1251 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1256 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1256 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1256 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1256 "nmp/uisa_fp_instr.nmp"
;
#line 1256 "nmp/uisa_fp_instr.nmp"
#line 1257 "nmp/uisa_fp_instr.nmp"
		endif;
        }

// Floating Multiply Add Instructions
op  ufp_mult_add_instr( x : ufp_mult_add_instr_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPMADD


op ufp_mult_add_instr_action =   ufp_mult_add
                               | ufp_mult_sub

op ufp_mult_add =   ufp_mult_add_dbl
                  | ufp_mult_addd_cr_upd
                  | ufp_mult_add_sgl
                  | ufp_mult_adds_cr_upd
                  | ufp_mult_nadd_dbl
                  | ufp_mult_naddd_cr_upd
                  | ufp_mult_nadd_sgl
                  | ufp_mult_nadds_cr_upd

op ufp_mult_sub =   ufp_mult_sub_dbl
                  | ufp_mult_subd_cr_upd
                  | ufp_mult_sub_sgl
                  | ufp_mult_subs_cr_upd
                  | ufp_mult_nsub_dbl
                  | ufp_mult_nsubd_cr_upd
                  | ufp_mult_nsub_sgl
                  | ufp_mult_nsubs_cr_upd

op ufp_mult_add_dbl ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fmadd fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111010", frd, fra, frb, frc )
   action = {
		;
#line 1293 "nmp/uisa_fp_instr.nmp"
#line 1294 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1294 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1294 "nmp/uisa_fp_instr.nmp"
#line 1295 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ];
			// HKC-SETR
#line 1296 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1296 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1296 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
;
#line 1296 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1296 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1296 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1296 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1296 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1296 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1296 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1296 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1296 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1296 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1296 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1296 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1296 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1296 "nmp/uisa_fp_instr.nmp"
 then 
#line 1296 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
	else 
#line 1296 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1296 "nmp/uisa_fp_instr.nmp"
 then 
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
		else 
#line 1296 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1296 "nmp/uisa_fp_instr.nmp"
 then 
#line 1296 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			else 
#line 1296 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1296 "nmp/uisa_fp_instr.nmp"
 then 
#line 1296 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
				else 
#line 1296 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1296 "nmp/uisa_fp_instr.nmp"
 then 
#line 1296 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
					else 
#line 1296 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1296 "nmp/uisa_fp_instr.nmp"
 then 
#line 1296 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
						else 
#line 1296 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1296 "nmp/uisa_fp_instr.nmp"
 then 
#line 1296 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
							else 
#line 1296 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1296 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1296 "nmp/uisa_fp_instr.nmp"
 then 
#line 1296 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
								else 
#line 1296 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1296 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1296 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1296 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			else 
#line 1296 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1296 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1296 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1296 "nmp/uisa_fp_instr.nmp"
; 
#line 1296 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1296 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1296 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1296 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1296 "nmp/uisa_fp_instr.nmp"
;
#line 1296 "nmp/uisa_fp_instr.nmp"
#line 1297 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1298 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1298 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1298 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1298 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1298 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1298 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1298 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1298 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1298 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1298 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1298 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1298 "nmp/uisa_fp_instr.nmp"
 then
#line 1298 "nmp/uisa_fp_instr.nmp"
#line 1299 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1299 "nmp/uisa_fp_instr.nmp"
;
#line 1299 "nmp/uisa_fp_instr.nmp"
#line 1300 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1301 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1301 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1301 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1301 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1301 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1301 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1301 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1301 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1301 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1301 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1301 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1301 "nmp/uisa_fp_instr.nmp"
) ||
#line 1301 "nmp/uisa_fp_instr.nmp"
#line 1302 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1302 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1302 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1302 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1302 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1302 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1302 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1302 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1302 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1302 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1302 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1302 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1302 "nmp/uisa_fp_instr.nmp"
)) then
#line 1302 "nmp/uisa_fp_instr.nmp"
#line 1303 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1303 "nmp/uisa_fp_instr.nmp"
;
#line 1303 "nmp/uisa_fp_instr.nmp"
#line 1304 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1305 "nmp/uisa_fp_instr.nmp"
;
#line 1305 "nmp/uisa_fp_instr.nmp"
#line 1306 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;

            }

op ufp_mult_addd_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fmadd. fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111011", frd, fra, frb, frc )
   action = {
		;
#line 1319 "nmp/uisa_fp_instr.nmp"
#line 1320 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1320 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1320 "nmp/uisa_fp_instr.nmp"
#line 1321 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT= ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ];
			// HKC-SETR
#line 1322 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1322 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1322 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
;
#line 1322 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1322 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1322 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1322 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1322 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1322 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1322 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1322 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1322 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1322 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1322 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1322 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1322 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1322 "nmp/uisa_fp_instr.nmp"
 then 
#line 1322 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
	else 
#line 1322 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1322 "nmp/uisa_fp_instr.nmp"
 then 
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
		else 
#line 1322 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1322 "nmp/uisa_fp_instr.nmp"
 then 
#line 1322 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			else 
#line 1322 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1322 "nmp/uisa_fp_instr.nmp"
 then 
#line 1322 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
				else 
#line 1322 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1322 "nmp/uisa_fp_instr.nmp"
 then 
#line 1322 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
					else 
#line 1322 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1322 "nmp/uisa_fp_instr.nmp"
 then 
#line 1322 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
						else 
#line 1322 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1322 "nmp/uisa_fp_instr.nmp"
 then 
#line 1322 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
							else 
#line 1322 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1322 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1322 "nmp/uisa_fp_instr.nmp"
 then 
#line 1322 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
								else 
#line 1322 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1322 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1322 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1322 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			else 
#line 1322 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1322 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1322 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1322 "nmp/uisa_fp_instr.nmp"
; 
#line 1322 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1322 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1322 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1322 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1322 "nmp/uisa_fp_instr.nmp"
;
#line 1322 "nmp/uisa_fp_instr.nmp"
#line 1323 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1324 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1324 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1324 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1324 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1324 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1324 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1324 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1324 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1324 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1324 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1324 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1324 "nmp/uisa_fp_instr.nmp"
 then
#line 1324 "nmp/uisa_fp_instr.nmp"
#line 1325 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1325 "nmp/uisa_fp_instr.nmp"
;
#line 1325 "nmp/uisa_fp_instr.nmp"
#line 1326 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1327 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1327 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1327 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1327 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1327 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1327 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1327 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1327 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1327 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1327 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1327 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1327 "nmp/uisa_fp_instr.nmp"
) ||
#line 1327 "nmp/uisa_fp_instr.nmp"
#line 1328 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1328 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1328 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1328 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1328 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1328 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1328 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1328 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1328 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1328 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1328 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1328 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1328 "nmp/uisa_fp_instr.nmp"
)) then
#line 1328 "nmp/uisa_fp_instr.nmp"
#line 1329 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1329 "nmp/uisa_fp_instr.nmp"
;
#line 1329 "nmp/uisa_fp_instr.nmp"
#line 1330 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1331 "nmp/uisa_fp_instr.nmp"
;
#line 1331 "nmp/uisa_fp_instr.nmp"
#line 1332 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1338 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1338 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1338 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1338 "nmp/uisa_fp_instr.nmp"
;
#line 1338 "nmp/uisa_fp_instr.nmp"
#line 1339 "nmp/uisa_fp_instr.nmp"
		endif;
		}

op ufp_mult_add_sgl ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fmadds fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111010", frd, fra, frb, frc )
   action = {
		;
#line 1346 "nmp/uisa_fp_instr.nmp"
#line 1347 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1347 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1347 "nmp/uisa_fp_instr.nmp"
#line 1348 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = (FPR[fra] * FPR[frc])+FPR[frb];
			// HKC-SETR
#line 1349 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1349 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1349 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
;
#line 1349 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1349 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1349 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1349 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1349 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1349 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1349 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1349 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1349 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1349 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1349 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1349 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1349 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1349 "nmp/uisa_fp_instr.nmp"
 then 
#line 1349 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
	else 
#line 1349 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1349 "nmp/uisa_fp_instr.nmp"
 then 
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
		else 
#line 1349 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1349 "nmp/uisa_fp_instr.nmp"
 then 
#line 1349 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			else 
#line 1349 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1349 "nmp/uisa_fp_instr.nmp"
 then 
#line 1349 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
				else 
#line 1349 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1349 "nmp/uisa_fp_instr.nmp"
 then 
#line 1349 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
					else 
#line 1349 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1349 "nmp/uisa_fp_instr.nmp"
 then 
#line 1349 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
						else 
#line 1349 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1349 "nmp/uisa_fp_instr.nmp"
 then 
#line 1349 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
							else 
#line 1349 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1349 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1349 "nmp/uisa_fp_instr.nmp"
 then 
#line 1349 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
								else 
#line 1349 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1349 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1349 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1349 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			else 
#line 1349 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1349 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1349 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1349 "nmp/uisa_fp_instr.nmp"
; 
#line 1349 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1349 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1349 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1349 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1349 "nmp/uisa_fp_instr.nmp"
;
#line 1349 "nmp/uisa_fp_instr.nmp"
#line 1350 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1351 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1351 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1351 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1351 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1351 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1351 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1351 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1351 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1351 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1351 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1351 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1351 "nmp/uisa_fp_instr.nmp"
 then
#line 1351 "nmp/uisa_fp_instr.nmp"
#line 1352 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1352 "nmp/uisa_fp_instr.nmp"
;
#line 1352 "nmp/uisa_fp_instr.nmp"
#line 1353 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1354 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1354 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1354 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1354 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1354 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1354 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1354 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1354 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1354 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1354 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1354 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1354 "nmp/uisa_fp_instr.nmp"
) ||
#line 1354 "nmp/uisa_fp_instr.nmp"
#line 1355 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1355 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1355 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1355 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1355 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1355 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1355 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1355 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1355 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1355 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1355 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1355 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1355 "nmp/uisa_fp_instr.nmp"
)) then
#line 1355 "nmp/uisa_fp_instr.nmp"
#line 1356 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1356 "nmp/uisa_fp_instr.nmp"
;
#line 1356 "nmp/uisa_fp_instr.nmp"
#line 1357 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1358 "nmp/uisa_fp_instr.nmp"
;
#line 1358 "nmp/uisa_fp_instr.nmp"
#line 1359 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
		}

op ufp_mult_adds_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fmadds. fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111011", frd, fra, frb, frc )
   action = {

		;
#line 1372 "nmp/uisa_fp_instr.nmp"
#line 1373 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1373 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1373 "nmp/uisa_fp_instr.nmp"
#line 1374 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = (FPR[fra] * FPR[frc])+FPR[frb];
			// HKC-SETR
#line 1375 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1375 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1375 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
;
#line 1375 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1375 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1375 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1375 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1375 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1375 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1375 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1375 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1375 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1375 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1375 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1375 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1375 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1375 "nmp/uisa_fp_instr.nmp"
 then 
#line 1375 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
	else 
#line 1375 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1375 "nmp/uisa_fp_instr.nmp"
 then 
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
		else 
#line 1375 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1375 "nmp/uisa_fp_instr.nmp"
 then 
#line 1375 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			else 
#line 1375 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1375 "nmp/uisa_fp_instr.nmp"
 then 
#line 1375 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
				else 
#line 1375 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1375 "nmp/uisa_fp_instr.nmp"
 then 
#line 1375 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
					else 
#line 1375 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1375 "nmp/uisa_fp_instr.nmp"
 then 
#line 1375 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
						else 
#line 1375 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1375 "nmp/uisa_fp_instr.nmp"
 then 
#line 1375 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
							else 
#line 1375 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1375 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1375 "nmp/uisa_fp_instr.nmp"
 then 
#line 1375 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
								else 
#line 1375 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1375 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1375 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1375 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			else 
#line 1375 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1375 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1375 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1375 "nmp/uisa_fp_instr.nmp"
; 
#line 1375 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1375 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1375 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1375 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1375 "nmp/uisa_fp_instr.nmp"
;
#line 1375 "nmp/uisa_fp_instr.nmp"
#line 1376 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1377 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1377 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1377 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1377 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1377 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1377 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1377 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1377 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1377 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1377 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1377 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1377 "nmp/uisa_fp_instr.nmp"
 then
#line 1377 "nmp/uisa_fp_instr.nmp"
#line 1378 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1378 "nmp/uisa_fp_instr.nmp"
;
#line 1378 "nmp/uisa_fp_instr.nmp"
#line 1379 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1380 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1380 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1380 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1380 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1380 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1380 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1380 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1380 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1380 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1380 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1380 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1380 "nmp/uisa_fp_instr.nmp"
) ||
#line 1380 "nmp/uisa_fp_instr.nmp"
#line 1381 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1381 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1381 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1381 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1381 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1381 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1381 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1381 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1381 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1381 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1381 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1381 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1381 "nmp/uisa_fp_instr.nmp"
)) then
#line 1381 "nmp/uisa_fp_instr.nmp"
#line 1382 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1382 "nmp/uisa_fp_instr.nmp"
;
#line 1382 "nmp/uisa_fp_instr.nmp"
#line 1383 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1384 "nmp/uisa_fp_instr.nmp"
;
#line 1384 "nmp/uisa_fp_instr.nmp"
#line 1385 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1391 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1391 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1391 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1391 "nmp/uisa_fp_instr.nmp"
;
#line 1391 "nmp/uisa_fp_instr.nmp"
#line 1392 "nmp/uisa_fp_instr.nmp"
		endif;
		}

op ufp_mult_nadd_dbl ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fnmadd fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111110", frd, fra, frb, frc )
   action = {

        ;
#line 1400 "nmp/uisa_fp_instr.nmp"
#line 1401 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1401 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1401 "nmp/uisa_fp_instr.nmp"
#line 1402 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = -( ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ] );
			// HKC-SETR
#line 1403 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1403 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1403 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
;
#line 1403 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1403 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1403 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1403 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1403 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1403 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1403 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1403 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1403 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1403 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1403 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1403 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1403 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1403 "nmp/uisa_fp_instr.nmp"
 then 
#line 1403 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
	else 
#line 1403 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1403 "nmp/uisa_fp_instr.nmp"
 then 
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
		else 
#line 1403 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1403 "nmp/uisa_fp_instr.nmp"
 then 
#line 1403 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			else 
#line 1403 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1403 "nmp/uisa_fp_instr.nmp"
 then 
#line 1403 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
				else 
#line 1403 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1403 "nmp/uisa_fp_instr.nmp"
 then 
#line 1403 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
					else 
#line 1403 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1403 "nmp/uisa_fp_instr.nmp"
 then 
#line 1403 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
						else 
#line 1403 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1403 "nmp/uisa_fp_instr.nmp"
 then 
#line 1403 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
							else 
#line 1403 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1403 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1403 "nmp/uisa_fp_instr.nmp"
 then 
#line 1403 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
								else 
#line 1403 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1403 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1403 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1403 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			else 
#line 1403 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1403 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1403 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1403 "nmp/uisa_fp_instr.nmp"
; 
#line 1403 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1403 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1403 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1403 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1403 "nmp/uisa_fp_instr.nmp"
;
#line 1403 "nmp/uisa_fp_instr.nmp"
#line 1404 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1405 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1405 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1405 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1405 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1405 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1405 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1405 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1405 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1405 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1405 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1405 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1405 "nmp/uisa_fp_instr.nmp"
 then
#line 1405 "nmp/uisa_fp_instr.nmp"
#line 1406 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1406 "nmp/uisa_fp_instr.nmp"
;
#line 1406 "nmp/uisa_fp_instr.nmp"
#line 1407 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1408 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1408 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1408 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1408 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1408 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1408 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1408 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1408 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1408 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1408 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1408 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1408 "nmp/uisa_fp_instr.nmp"
) ||
#line 1408 "nmp/uisa_fp_instr.nmp"
#line 1409 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1409 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1409 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1409 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1409 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1409 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1409 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1409 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1409 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1409 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1409 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1409 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1409 "nmp/uisa_fp_instr.nmp"
)) then
#line 1409 "nmp/uisa_fp_instr.nmp"
#line 1410 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1410 "nmp/uisa_fp_instr.nmp"
;
#line 1410 "nmp/uisa_fp_instr.nmp"
#line 1411 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1412 "nmp/uisa_fp_instr.nmp"
;
#line 1412 "nmp/uisa_fp_instr.nmp"
#line 1413 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
		}

op ufp_mult_naddd_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fnmadd. fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111111", frd, fra, frb, frc )
   action = {
		;
#line 1425 "nmp/uisa_fp_instr.nmp"
#line 1426 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1426 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1426 "nmp/uisa_fp_instr.nmp"
#line 1427 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = -( ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ] );
			// HKC-SETR
#line 1428 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1428 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1428 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
;
#line 1428 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1428 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1428 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1428 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1428 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1428 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1428 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1428 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1428 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1428 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1428 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1428 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1428 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1428 "nmp/uisa_fp_instr.nmp"
 then 
#line 1428 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
	else 
#line 1428 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1428 "nmp/uisa_fp_instr.nmp"
 then 
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
		else 
#line 1428 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1428 "nmp/uisa_fp_instr.nmp"
 then 
#line 1428 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			else 
#line 1428 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1428 "nmp/uisa_fp_instr.nmp"
 then 
#line 1428 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
				else 
#line 1428 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1428 "nmp/uisa_fp_instr.nmp"
 then 
#line 1428 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
					else 
#line 1428 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1428 "nmp/uisa_fp_instr.nmp"
 then 
#line 1428 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
						else 
#line 1428 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1428 "nmp/uisa_fp_instr.nmp"
 then 
#line 1428 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
							else 
#line 1428 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1428 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1428 "nmp/uisa_fp_instr.nmp"
 then 
#line 1428 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
								else 
#line 1428 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1428 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1428 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1428 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			else 
#line 1428 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1428 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1428 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1428 "nmp/uisa_fp_instr.nmp"
; 
#line 1428 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1428 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1428 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1428 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1428 "nmp/uisa_fp_instr.nmp"
;
#line 1428 "nmp/uisa_fp_instr.nmp"
#line 1429 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1430 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1430 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1430 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1430 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1430 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1430 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1430 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1430 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1430 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1430 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1430 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1430 "nmp/uisa_fp_instr.nmp"
 then
#line 1430 "nmp/uisa_fp_instr.nmp"
#line 1431 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1431 "nmp/uisa_fp_instr.nmp"
;
#line 1431 "nmp/uisa_fp_instr.nmp"
#line 1432 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1433 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1433 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1433 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1433 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1433 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1433 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1433 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1433 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1433 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1433 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1433 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1433 "nmp/uisa_fp_instr.nmp"
) ||
#line 1433 "nmp/uisa_fp_instr.nmp"
#line 1434 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1434 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1434 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1434 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1434 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1434 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1434 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1434 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1434 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1434 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1434 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1434 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1434 "nmp/uisa_fp_instr.nmp"
)) then
#line 1434 "nmp/uisa_fp_instr.nmp"
#line 1435 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1435 "nmp/uisa_fp_instr.nmp"
;
#line 1435 "nmp/uisa_fp_instr.nmp"
#line 1436 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1437 "nmp/uisa_fp_instr.nmp"
;
#line 1437 "nmp/uisa_fp_instr.nmp"
#line 1438 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1444 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1444 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1444 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1444 "nmp/uisa_fp_instr.nmp"
;
#line 1444 "nmp/uisa_fp_instr.nmp"
#line 1445 "nmp/uisa_fp_instr.nmp"
		endif;
        }

op ufp_mult_nadd_sgl ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fnmadds fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111110", frd, fra, frb, frc )
   action = {

		;
#line 1453 "nmp/uisa_fp_instr.nmp"
#line 1454 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1454 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1454 "nmp/uisa_fp_instr.nmp"
#line 1455 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = -((FPR[fra] * FPR[frc])+FPR[frb]);
			// HKC-SETR
#line 1456 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1456 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1456 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
;
#line 1456 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1456 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1456 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1456 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1456 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1456 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1456 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1456 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1456 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1456 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1456 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1456 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1456 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1456 "nmp/uisa_fp_instr.nmp"
 then 
#line 1456 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
	else 
#line 1456 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1456 "nmp/uisa_fp_instr.nmp"
 then 
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
		else 
#line 1456 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1456 "nmp/uisa_fp_instr.nmp"
 then 
#line 1456 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			else 
#line 1456 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1456 "nmp/uisa_fp_instr.nmp"
 then 
#line 1456 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
				else 
#line 1456 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1456 "nmp/uisa_fp_instr.nmp"
 then 
#line 1456 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
					else 
#line 1456 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1456 "nmp/uisa_fp_instr.nmp"
 then 
#line 1456 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
						else 
#line 1456 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1456 "nmp/uisa_fp_instr.nmp"
 then 
#line 1456 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
							else 
#line 1456 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1456 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1456 "nmp/uisa_fp_instr.nmp"
 then 
#line 1456 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
								else 
#line 1456 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1456 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1456 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1456 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			else 
#line 1456 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1456 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1456 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1456 "nmp/uisa_fp_instr.nmp"
; 
#line 1456 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1456 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1456 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1456 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1456 "nmp/uisa_fp_instr.nmp"
;
#line 1456 "nmp/uisa_fp_instr.nmp"
#line 1457 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1458 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1458 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1458 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1458 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1458 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1458 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1458 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1458 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1458 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1458 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1458 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1458 "nmp/uisa_fp_instr.nmp"
 then
#line 1458 "nmp/uisa_fp_instr.nmp"
#line 1459 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1459 "nmp/uisa_fp_instr.nmp"
;
#line 1459 "nmp/uisa_fp_instr.nmp"
#line 1460 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1461 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1461 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1461 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1461 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1461 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1461 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1461 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1461 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1461 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1461 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1461 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1461 "nmp/uisa_fp_instr.nmp"
) ||
#line 1461 "nmp/uisa_fp_instr.nmp"
#line 1462 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1462 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1462 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1462 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1462 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1462 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1462 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1462 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1462 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1462 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1462 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1462 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1462 "nmp/uisa_fp_instr.nmp"
)) then
#line 1462 "nmp/uisa_fp_instr.nmp"
#line 1463 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1463 "nmp/uisa_fp_instr.nmp"
;
#line 1463 "nmp/uisa_fp_instr.nmp"
#line 1464 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1465 "nmp/uisa_fp_instr.nmp"
;
#line 1465 "nmp/uisa_fp_instr.nmp"
#line 1466 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
		}

op ufp_mult_nadds_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fnmadds. fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111111", frd, fra, frb, frc )
   action = {

		;
#line 1479 "nmp/uisa_fp_instr.nmp"
#line 1480 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1480 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1480 "nmp/uisa_fp_instr.nmp"
#line 1481 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = -((FPR[fra] * FPR[frc])+FPR[frb]);
			// HKC-SETR
#line 1482 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1482 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1482 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
;
#line 1482 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1482 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1482 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1482 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1482 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1482 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1482 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1482 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1482 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1482 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1482 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1482 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1482 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1482 "nmp/uisa_fp_instr.nmp"
 then 
#line 1482 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
	else 
#line 1482 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1482 "nmp/uisa_fp_instr.nmp"
 then 
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
		else 
#line 1482 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1482 "nmp/uisa_fp_instr.nmp"
 then 
#line 1482 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			else 
#line 1482 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1482 "nmp/uisa_fp_instr.nmp"
 then 
#line 1482 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
				else 
#line 1482 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1482 "nmp/uisa_fp_instr.nmp"
 then 
#line 1482 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
					else 
#line 1482 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1482 "nmp/uisa_fp_instr.nmp"
 then 
#line 1482 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
						else 
#line 1482 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1482 "nmp/uisa_fp_instr.nmp"
 then 
#line 1482 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
							else 
#line 1482 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1482 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1482 "nmp/uisa_fp_instr.nmp"
 then 
#line 1482 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
								else 
#line 1482 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1482 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1482 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1482 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			else 
#line 1482 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1482 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1482 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1482 "nmp/uisa_fp_instr.nmp"
; 
#line 1482 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1482 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1482 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1482 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1482 "nmp/uisa_fp_instr.nmp"
;
#line 1482 "nmp/uisa_fp_instr.nmp"
#line 1483 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1484 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1484 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1484 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1484 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1484 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1484 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1484 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1484 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1484 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1484 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1484 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1484 "nmp/uisa_fp_instr.nmp"
 then
#line 1484 "nmp/uisa_fp_instr.nmp"
#line 1485 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1485 "nmp/uisa_fp_instr.nmp"
;
#line 1485 "nmp/uisa_fp_instr.nmp"
#line 1486 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1487 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1487 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1487 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1487 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1487 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1487 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1487 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1487 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1487 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1487 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1487 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1487 "nmp/uisa_fp_instr.nmp"
) ||
#line 1487 "nmp/uisa_fp_instr.nmp"
#line 1488 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1488 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1488 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1488 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1488 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1488 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1488 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1488 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1488 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1488 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1488 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1488 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1488 "nmp/uisa_fp_instr.nmp"
)) then
#line 1488 "nmp/uisa_fp_instr.nmp"
#line 1489 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1489 "nmp/uisa_fp_instr.nmp"
;
#line 1489 "nmp/uisa_fp_instr.nmp"
#line 1490 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1491 "nmp/uisa_fp_instr.nmp"
;
#line 1491 "nmp/uisa_fp_instr.nmp"
#line 1492 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1498 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1498 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1498 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1498 "nmp/uisa_fp_instr.nmp"
;
#line 1498 "nmp/uisa_fp_instr.nmp"
#line 1499 "nmp/uisa_fp_instr.nmp"
		endif;
		}


op ufp_mult_sub_dbl ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fmsub fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111000", frd, fra, frb, frc )
   action = {

        ;
#line 1508 "nmp/uisa_fp_instr.nmp"
#line 1509 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1509 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1509 "nmp/uisa_fp_instr.nmp"
#line 1510 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ];
			// HKC-SETR
#line 1511 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1511 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1511 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
;
#line 1511 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1511 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1511 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1511 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1511 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1511 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1511 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1511 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1511 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1511 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1511 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1511 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1511 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1511 "nmp/uisa_fp_instr.nmp"
 then 
#line 1511 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
	else 
#line 1511 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1511 "nmp/uisa_fp_instr.nmp"
 then 
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
		else 
#line 1511 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1511 "nmp/uisa_fp_instr.nmp"
 then 
#line 1511 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			else 
#line 1511 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1511 "nmp/uisa_fp_instr.nmp"
 then 
#line 1511 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
				else 
#line 1511 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1511 "nmp/uisa_fp_instr.nmp"
 then 
#line 1511 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
					else 
#line 1511 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1511 "nmp/uisa_fp_instr.nmp"
 then 
#line 1511 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
						else 
#line 1511 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1511 "nmp/uisa_fp_instr.nmp"
 then 
#line 1511 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
							else 
#line 1511 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1511 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1511 "nmp/uisa_fp_instr.nmp"
 then 
#line 1511 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
								else 
#line 1511 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1511 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1511 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1511 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			else 
#line 1511 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1511 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1511 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1511 "nmp/uisa_fp_instr.nmp"
; 
#line 1511 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1511 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1511 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1511 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1511 "nmp/uisa_fp_instr.nmp"
;
#line 1511 "nmp/uisa_fp_instr.nmp"
#line 1512 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1513 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1513 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1513 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1513 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1513 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1513 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1513 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1513 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1513 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1513 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1513 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1513 "nmp/uisa_fp_instr.nmp"
 then
#line 1513 "nmp/uisa_fp_instr.nmp"
#line 1514 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1514 "nmp/uisa_fp_instr.nmp"
;
#line 1514 "nmp/uisa_fp_instr.nmp"
#line 1515 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1516 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1516 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1516 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1516 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1516 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1516 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1516 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1516 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1516 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1516 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1516 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1516 "nmp/uisa_fp_instr.nmp"
) ||
#line 1516 "nmp/uisa_fp_instr.nmp"
#line 1517 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1517 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1517 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1517 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1517 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1517 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1517 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1517 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1517 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1517 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1517 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1517 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1517 "nmp/uisa_fp_instr.nmp"
)) then
#line 1517 "nmp/uisa_fp_instr.nmp"
#line 1518 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1518 "nmp/uisa_fp_instr.nmp"
;
#line 1518 "nmp/uisa_fp_instr.nmp"
#line 1519 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1520 "nmp/uisa_fp_instr.nmp"
;
#line 1520 "nmp/uisa_fp_instr.nmp"
#line 1521 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;

        }

op ufp_mult_subd_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fmsub. fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111001", frd, fra, frb, frc )
   action = {

        ;
#line 1535 "nmp/uisa_fp_instr.nmp"
#line 1536 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1536 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1536 "nmp/uisa_fp_instr.nmp"
#line 1537 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ];
			// HKC-SETR
#line 1538 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1538 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1538 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
;
#line 1538 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1538 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1538 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1538 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1538 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1538 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1538 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1538 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1538 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1538 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1538 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1538 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1538 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1538 "nmp/uisa_fp_instr.nmp"
 then 
#line 1538 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
	else 
#line 1538 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1538 "nmp/uisa_fp_instr.nmp"
 then 
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
		else 
#line 1538 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1538 "nmp/uisa_fp_instr.nmp"
 then 
#line 1538 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			else 
#line 1538 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1538 "nmp/uisa_fp_instr.nmp"
 then 
#line 1538 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
				else 
#line 1538 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1538 "nmp/uisa_fp_instr.nmp"
 then 
#line 1538 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
					else 
#line 1538 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1538 "nmp/uisa_fp_instr.nmp"
 then 
#line 1538 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
						else 
#line 1538 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1538 "nmp/uisa_fp_instr.nmp"
 then 
#line 1538 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
							else 
#line 1538 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1538 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1538 "nmp/uisa_fp_instr.nmp"
 then 
#line 1538 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
								else 
#line 1538 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1538 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1538 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1538 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			else 
#line 1538 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1538 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1538 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1538 "nmp/uisa_fp_instr.nmp"
; 
#line 1538 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1538 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1538 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1538 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1538 "nmp/uisa_fp_instr.nmp"
;
#line 1538 "nmp/uisa_fp_instr.nmp"
#line 1539 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1540 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1540 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1540 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1540 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1540 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1540 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1540 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1540 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1540 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1540 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1540 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1540 "nmp/uisa_fp_instr.nmp"
 then
#line 1540 "nmp/uisa_fp_instr.nmp"
#line 1541 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1541 "nmp/uisa_fp_instr.nmp"
;
#line 1541 "nmp/uisa_fp_instr.nmp"
#line 1542 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1543 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1543 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1543 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1543 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1543 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1543 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1543 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1543 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1543 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1543 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1543 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1543 "nmp/uisa_fp_instr.nmp"
) ||
#line 1543 "nmp/uisa_fp_instr.nmp"
#line 1544 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1544 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1544 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1544 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1544 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1544 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1544 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1544 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1544 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1544 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1544 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1544 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1544 "nmp/uisa_fp_instr.nmp"
)) then
#line 1544 "nmp/uisa_fp_instr.nmp"
#line 1545 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1545 "nmp/uisa_fp_instr.nmp"
;
#line 1545 "nmp/uisa_fp_instr.nmp"
#line 1546 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1547 "nmp/uisa_fp_instr.nmp"
;
#line 1547 "nmp/uisa_fp_instr.nmp"
#line 1548 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1554 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1554 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1554 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1554 "nmp/uisa_fp_instr.nmp"
;
#line 1554 "nmp/uisa_fp_instr.nmp"
#line 1555 "nmp/uisa_fp_instr.nmp"
		endif;
		}

op ufp_mult_sub_sgl ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fmsubs fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111000", frd, fra, frb, frc )
   action = {

		;
#line 1563 "nmp/uisa_fp_instr.nmp"
#line 1564 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1564 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1564 "nmp/uisa_fp_instr.nmp"
#line 1565 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = (FPR[fra] * FPR[frc])-FPR[frb];
			// HKC-SETR
#line 1566 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1566 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1566 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
;
#line 1566 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1566 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1566 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1566 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1566 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1566 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1566 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1566 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1566 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1566 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1566 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1566 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1566 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1566 "nmp/uisa_fp_instr.nmp"
 then 
#line 1566 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
	else 
#line 1566 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1566 "nmp/uisa_fp_instr.nmp"
 then 
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
		else 
#line 1566 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1566 "nmp/uisa_fp_instr.nmp"
 then 
#line 1566 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			else 
#line 1566 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1566 "nmp/uisa_fp_instr.nmp"
 then 
#line 1566 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
				else 
#line 1566 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1566 "nmp/uisa_fp_instr.nmp"
 then 
#line 1566 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
					else 
#line 1566 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1566 "nmp/uisa_fp_instr.nmp"
 then 
#line 1566 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
						else 
#line 1566 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1566 "nmp/uisa_fp_instr.nmp"
 then 
#line 1566 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
							else 
#line 1566 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1566 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1566 "nmp/uisa_fp_instr.nmp"
 then 
#line 1566 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
								else 
#line 1566 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1566 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1566 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1566 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			else 
#line 1566 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1566 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1566 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1566 "nmp/uisa_fp_instr.nmp"
; 
#line 1566 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1566 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1566 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1566 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1566 "nmp/uisa_fp_instr.nmp"
;
#line 1566 "nmp/uisa_fp_instr.nmp"
#line 1567 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1568 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1568 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1568 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1568 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1568 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1568 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1568 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1568 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1568 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1568 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1568 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1568 "nmp/uisa_fp_instr.nmp"
 then
#line 1568 "nmp/uisa_fp_instr.nmp"
#line 1569 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1569 "nmp/uisa_fp_instr.nmp"
;
#line 1569 "nmp/uisa_fp_instr.nmp"
#line 1570 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1571 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1571 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1571 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1571 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1571 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1571 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1571 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1571 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1571 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1571 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1571 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1571 "nmp/uisa_fp_instr.nmp"
) ||
#line 1571 "nmp/uisa_fp_instr.nmp"
#line 1572 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1572 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1572 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1572 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1572 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1572 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1572 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1572 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1572 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1572 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1572 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1572 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1572 "nmp/uisa_fp_instr.nmp"
)) then
#line 1572 "nmp/uisa_fp_instr.nmp"
#line 1573 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1573 "nmp/uisa_fp_instr.nmp"
;
#line 1573 "nmp/uisa_fp_instr.nmp"
#line 1574 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1575 "nmp/uisa_fp_instr.nmp"
;
#line 1575 "nmp/uisa_fp_instr.nmp"
#line 1576 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;

            }

op ufp_mult_subs_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fmsubs. fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111001", frd, fra, frb, frc )
   action = {

		;
#line 1590 "nmp/uisa_fp_instr.nmp"
#line 1591 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1591 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1591 "nmp/uisa_fp_instr.nmp"
#line 1592 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = (FPR[fra] * FPR[frc])-FPR[frb];
			// HKC-SETR
#line 1593 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1593 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1593 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
;
#line 1593 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1593 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1593 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1593 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1593 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1593 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1593 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1593 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1593 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1593 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1593 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1593 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1593 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1593 "nmp/uisa_fp_instr.nmp"
 then 
#line 1593 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
	else 
#line 1593 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1593 "nmp/uisa_fp_instr.nmp"
 then 
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
		else 
#line 1593 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1593 "nmp/uisa_fp_instr.nmp"
 then 
#line 1593 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			else 
#line 1593 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1593 "nmp/uisa_fp_instr.nmp"
 then 
#line 1593 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
				else 
#line 1593 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1593 "nmp/uisa_fp_instr.nmp"
 then 
#line 1593 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
					else 
#line 1593 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1593 "nmp/uisa_fp_instr.nmp"
 then 
#line 1593 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
						else 
#line 1593 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1593 "nmp/uisa_fp_instr.nmp"
 then 
#line 1593 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
							else 
#line 1593 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1593 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1593 "nmp/uisa_fp_instr.nmp"
 then 
#line 1593 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
								else 
#line 1593 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1593 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1593 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1593 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			else 
#line 1593 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1593 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1593 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1593 "nmp/uisa_fp_instr.nmp"
; 
#line 1593 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1593 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1593 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1593 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1593 "nmp/uisa_fp_instr.nmp"
;
#line 1593 "nmp/uisa_fp_instr.nmp"
#line 1594 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1595 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1595 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1595 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1595 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1595 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1595 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1595 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1595 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1595 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1595 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1595 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1595 "nmp/uisa_fp_instr.nmp"
 then
#line 1595 "nmp/uisa_fp_instr.nmp"
#line 1596 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1596 "nmp/uisa_fp_instr.nmp"
;
#line 1596 "nmp/uisa_fp_instr.nmp"
#line 1597 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1598 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1598 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1598 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1598 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1598 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1598 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1598 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1598 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1598 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1598 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1598 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1598 "nmp/uisa_fp_instr.nmp"
) ||
#line 1598 "nmp/uisa_fp_instr.nmp"
#line 1599 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1599 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1599 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1599 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1599 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1599 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1599 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1599 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1599 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1599 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1599 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1599 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1599 "nmp/uisa_fp_instr.nmp"
)) then
#line 1599 "nmp/uisa_fp_instr.nmp"
#line 1600 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1600 "nmp/uisa_fp_instr.nmp"
;
#line 1600 "nmp/uisa_fp_instr.nmp"
#line 1601 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1602 "nmp/uisa_fp_instr.nmp"
;
#line 1602 "nmp/uisa_fp_instr.nmp"
#line 1603 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1609 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1609 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1609 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1609 "nmp/uisa_fp_instr.nmp"
;
#line 1609 "nmp/uisa_fp_instr.nmp"
#line 1610 "nmp/uisa_fp_instr.nmp"
		endif;
		}

op ufp_mult_nsub_dbl ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fnmsub fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111100", frd, fra, frb, frc )
   action = {
		;
#line 1617 "nmp/uisa_fp_instr.nmp"
#line 1618 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1618 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1618 "nmp/uisa_fp_instr.nmp"
#line 1619 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = -( ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ] );
			// HKC-SETR
#line 1620 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1620 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1620 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
;
#line 1620 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1620 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1620 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1620 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1620 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1620 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1620 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1620 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1620 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1620 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1620 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1620 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1620 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1620 "nmp/uisa_fp_instr.nmp"
 then 
#line 1620 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
	else 
#line 1620 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1620 "nmp/uisa_fp_instr.nmp"
 then 
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
		else 
#line 1620 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1620 "nmp/uisa_fp_instr.nmp"
 then 
#line 1620 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			else 
#line 1620 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1620 "nmp/uisa_fp_instr.nmp"
 then 
#line 1620 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
				else 
#line 1620 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1620 "nmp/uisa_fp_instr.nmp"
 then 
#line 1620 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
					else 
#line 1620 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1620 "nmp/uisa_fp_instr.nmp"
 then 
#line 1620 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
						else 
#line 1620 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1620 "nmp/uisa_fp_instr.nmp"
 then 
#line 1620 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
							else 
#line 1620 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1620 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1620 "nmp/uisa_fp_instr.nmp"
 then 
#line 1620 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
								else 
#line 1620 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1620 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1620 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1620 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			else 
#line 1620 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1620 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1620 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1620 "nmp/uisa_fp_instr.nmp"
; 
#line 1620 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1620 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1620 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1620 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1620 "nmp/uisa_fp_instr.nmp"
;
#line 1620 "nmp/uisa_fp_instr.nmp"
#line 1621 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1622 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1622 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1622 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1622 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1622 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1622 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1622 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1622 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1622 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1622 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1622 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1622 "nmp/uisa_fp_instr.nmp"
 then
#line 1622 "nmp/uisa_fp_instr.nmp"
#line 1623 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1623 "nmp/uisa_fp_instr.nmp"
;
#line 1623 "nmp/uisa_fp_instr.nmp"
#line 1624 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1625 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1625 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1625 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1625 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1625 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1625 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1625 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1625 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1625 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1625 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1625 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1625 "nmp/uisa_fp_instr.nmp"
) ||
#line 1625 "nmp/uisa_fp_instr.nmp"
#line 1626 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1626 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1626 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1626 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1626 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1626 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1626 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1626 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1626 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1626 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1626 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1626 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1626 "nmp/uisa_fp_instr.nmp"
)) then
#line 1626 "nmp/uisa_fp_instr.nmp"
#line 1627 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1627 "nmp/uisa_fp_instr.nmp"
;
#line 1627 "nmp/uisa_fp_instr.nmp"
#line 1628 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1629 "nmp/uisa_fp_instr.nmp"
;
#line 1629 "nmp/uisa_fp_instr.nmp"
#line 1630 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
				FPSCR <FP_FX..FP_FX> = 1 
#line 1634 "nmp/uisa_fp_instr.nmp"
;
#line 1634 "nmp/uisa_fp_instr.nmp"
#line 1635 "nmp/uisa_fp_instr.nmp"
			"launch_exception"("instr",PROGRAM);
		endif;
        }

op ufp_mult_nsubd_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fnmsub. fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111101", frd, fra, frb, frc )
   action = {
		;
#line 1643 "nmp/uisa_fp_instr.nmp"
#line 1644 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1644 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1644 "nmp/uisa_fp_instr.nmp"
#line 1645 "nmp/uisa_fp_instr.nmp"
		TMP_FLOT = -( ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ] );
			// HKC-SETR
#line 1646 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1646 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1646 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
;
#line 1646 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1646 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1646 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1646 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1646 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1646 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1646 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1646 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1646 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1646 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1646 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1646 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1646 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1646 "nmp/uisa_fp_instr.nmp"
 then 
#line 1646 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
	else 
#line 1646 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1646 "nmp/uisa_fp_instr.nmp"
 then 
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
		else 
#line 1646 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1646 "nmp/uisa_fp_instr.nmp"
 then 
#line 1646 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			else 
#line 1646 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1646 "nmp/uisa_fp_instr.nmp"
 then 
#line 1646 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
				else 
#line 1646 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1646 "nmp/uisa_fp_instr.nmp"
 then 
#line 1646 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
					else 
#line 1646 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1646 "nmp/uisa_fp_instr.nmp"
 then 
#line 1646 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
						else 
#line 1646 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1646 "nmp/uisa_fp_instr.nmp"
 then 
#line 1646 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
							else 
#line 1646 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1646 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1646 "nmp/uisa_fp_instr.nmp"
 then 
#line 1646 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
								else 
#line 1646 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1646 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1646 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1646 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			else 
#line 1646 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1646 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1646 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1646 "nmp/uisa_fp_instr.nmp"
; 
#line 1646 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1646 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOT; 
#line 1646 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1646 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1646 "nmp/uisa_fp_instr.nmp"
;
#line 1646 "nmp/uisa_fp_instr.nmp"
#line 1647 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1648 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1648 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1648 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1648 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1648 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1648 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1648 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1648 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1648 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1648 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1648 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1648 "nmp/uisa_fp_instr.nmp"
 then
#line 1648 "nmp/uisa_fp_instr.nmp"
#line 1649 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1649 "nmp/uisa_fp_instr.nmp"
;
#line 1649 "nmp/uisa_fp_instr.nmp"
#line 1650 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1651 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1651 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1651 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1651 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1651 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1651 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1651 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1651 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1651 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1651 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1651 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1651 "nmp/uisa_fp_instr.nmp"
) ||
#line 1651 "nmp/uisa_fp_instr.nmp"
#line 1652 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1652 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1652 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1652 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1652 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1652 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1652 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1652 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1652 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1652 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1652 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1652 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1652 "nmp/uisa_fp_instr.nmp"
)) then
#line 1652 "nmp/uisa_fp_instr.nmp"
#line 1653 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1653 "nmp/uisa_fp_instr.nmp"
;
#line 1653 "nmp/uisa_fp_instr.nmp"
#line 1654 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1655 "nmp/uisa_fp_instr.nmp"
;
#line 1655 "nmp/uisa_fp_instr.nmp"
#line 1656 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1662 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1662 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1662 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1662 "nmp/uisa_fp_instr.nmp"
;
#line 1662 "nmp/uisa_fp_instr.nmp"
#line 1663 "nmp/uisa_fp_instr.nmp"
		endif;

            }

op ufp_mult_nsub_sgl ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fnmsubs fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111100", frd, fra, frb, frc )
   action = {

		;
#line 1672 "nmp/uisa_fp_instr.nmp"
#line 1673 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1673 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1673 "nmp/uisa_fp_instr.nmp"
#line 1674 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = -((FPR[fra] * FPR[frc])-FPR[frb]);
			// HKC-SETR
#line 1675 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1675 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1675 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
;
#line 1675 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1675 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1675 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1675 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1675 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1675 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1675 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1675 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1675 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1675 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1675 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1675 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1675 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1675 "nmp/uisa_fp_instr.nmp"
 then 
#line 1675 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
	else 
#line 1675 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1675 "nmp/uisa_fp_instr.nmp"
 then 
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
		else 
#line 1675 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1675 "nmp/uisa_fp_instr.nmp"
 then 
#line 1675 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			else 
#line 1675 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1675 "nmp/uisa_fp_instr.nmp"
 then 
#line 1675 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
				else 
#line 1675 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1675 "nmp/uisa_fp_instr.nmp"
 then 
#line 1675 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
					else 
#line 1675 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1675 "nmp/uisa_fp_instr.nmp"
 then 
#line 1675 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
						else 
#line 1675 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1675 "nmp/uisa_fp_instr.nmp"
 then 
#line 1675 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
							else 
#line 1675 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1675 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1675 "nmp/uisa_fp_instr.nmp"
 then 
#line 1675 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
								else 
#line 1675 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1675 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1675 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1675 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			else 
#line 1675 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1675 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1675 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1675 "nmp/uisa_fp_instr.nmp"
; 
#line 1675 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1675 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1675 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1675 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1675 "nmp/uisa_fp_instr.nmp"
;
#line 1675 "nmp/uisa_fp_instr.nmp"
#line 1676 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1677 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1677 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1677 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1677 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1677 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1677 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1677 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1677 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1677 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1677 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1677 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1677 "nmp/uisa_fp_instr.nmp"
 then
#line 1677 "nmp/uisa_fp_instr.nmp"
#line 1678 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1678 "nmp/uisa_fp_instr.nmp"
;
#line 1678 "nmp/uisa_fp_instr.nmp"
#line 1679 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1680 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1680 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1680 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1680 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1680 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1680 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1680 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1680 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1680 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1680 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1680 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1680 "nmp/uisa_fp_instr.nmp"
) ||
#line 1680 "nmp/uisa_fp_instr.nmp"
#line 1681 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1681 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1681 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1681 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1681 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1681 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1681 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1681 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1681 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1681 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1681 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1681 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1681 "nmp/uisa_fp_instr.nmp"
)) then
#line 1681 "nmp/uisa_fp_instr.nmp"
#line 1682 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1682 "nmp/uisa_fp_instr.nmp"
;
#line 1682 "nmp/uisa_fp_instr.nmp"
#line 1683 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1684 "nmp/uisa_fp_instr.nmp"
;
#line 1684 "nmp/uisa_fp_instr.nmp"
#line 1685 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
		}

op ufp_mult_nsubs_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   syntax = format ( "fnmsubs. fr%d,fr%d,fr%d,fr%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111101", frd, fra, frb, frc )
   action = {
		;
#line 1697 "nmp/uisa_fp_instr.nmp"
#line 1698 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1698 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1698 "nmp/uisa_fp_instr.nmp"
#line 1699 "nmp/uisa_fp_instr.nmp"
		TMP_FLOTS = -((FPR[fra] * FPR[frc])-FPR[frb]);
			// HKC-SETR
#line 1700 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1700 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1700 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
;
#line 1700 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1700 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1700 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1700 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1700 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1700 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1700 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1700 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1700 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1700 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1700 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1700 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1700 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1700 "nmp/uisa_fp_instr.nmp"
 then 
#line 1700 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
	else 
#line 1700 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1700 "nmp/uisa_fp_instr.nmp"
 then 
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
		else 
#line 1700 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1700 "nmp/uisa_fp_instr.nmp"
 then 
#line 1700 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			else 
#line 1700 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1700 "nmp/uisa_fp_instr.nmp"
 then 
#line 1700 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
				else 
#line 1700 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1700 "nmp/uisa_fp_instr.nmp"
 then 
#line 1700 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
					else 
#line 1700 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1700 "nmp/uisa_fp_instr.nmp"
 then 
#line 1700 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
						else 
#line 1700 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1700 "nmp/uisa_fp_instr.nmp"
 then 
#line 1700 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
							else 
#line 1700 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1700 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1700 "nmp/uisa_fp_instr.nmp"
 then 
#line 1700 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
								else 
#line 1700 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1700 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1700 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1700 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			else 
#line 1700 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1700 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1700 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1700 "nmp/uisa_fp_instr.nmp"
; 
#line 1700 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1700 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1700 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1700 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1700 "nmp/uisa_fp_instr.nmp"
;
#line 1700 "nmp/uisa_fp_instr.nmp"
#line 1701 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[fra]<62..52> 
#line 1702 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1702 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1702 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1702 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1702 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1702 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1702 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1702 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frc]<62..52> 
#line 1702 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1702 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1702 "nmp/uisa_fp_instr.nmp"
 && FPR[frc] <51..51> == 0 ) 
#line 1702 "nmp/uisa_fp_instr.nmp"
 then
#line 1702 "nmp/uisa_fp_instr.nmp"
#line 1703 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1703 "nmp/uisa_fp_instr.nmp"
;
#line 1703 "nmp/uisa_fp_instr.nmp"
#line 1704 "nmp/uisa_fp_instr.nmp"
			else
				if (((	( 	FPR[fra]<63..63> 
#line 1705 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1705 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1705 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1705 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[fra]<63..63> 
#line 1705 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[fra]<62..52> 
#line 1705 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1705 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1705 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[frc]<63..63> 
#line 1705 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1705 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<51..0> 
#line 1705 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1705 "nmp/uisa_fp_instr.nmp"
) ||
#line 1705 "nmp/uisa_fp_instr.nmp"
#line 1706 "nmp/uisa_fp_instr.nmp"
					((	( 	FPR[frc]<63..63> 
#line 1706 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frc]<62..52> 
#line 1706 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1706 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1706 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frc]<63..63> 
#line 1706 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frc]<62..52> 
#line 1706 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frc]<51..0> 
#line 1706 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1706 "nmp/uisa_fp_instr.nmp"
) && 	( 	FPR[fra]<63..63> 
#line 1706 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<62..52> 
#line 1706 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[fra]<51..0> 
#line 1706 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1706 "nmp/uisa_fp_instr.nmp"
)) then
#line 1706 "nmp/uisa_fp_instr.nmp"
#line 1707 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_VXIMZ..FP_VXIMZ> = 1 
#line 1707 "nmp/uisa_fp_instr.nmp"
;
#line 1707 "nmp/uisa_fp_instr.nmp"
#line 1708 "nmp/uisa_fp_instr.nmp"
				else
						FPSCR <FP_VXISI..FP_VXISI> = 1 
#line 1709 "nmp/uisa_fp_instr.nmp"
;
#line 1709 "nmp/uisa_fp_instr.nmp"
#line 1710 "nmp/uisa_fp_instr.nmp"
				endif;
			endif;
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1716 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1716 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1716 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1716 "nmp/uisa_fp_instr.nmp"
;
#line 1716 "nmp/uisa_fp_instr.nmp"
#line 1717 "nmp/uisa_fp_instr.nmp"
		endif;
        }


// 2.2.2 Floating point Compare Instructions
// -----------------------------------------

op  ufp_compare ( x : ufp_compare_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPCMP

op ufp_compare_action =   ufp_cmp_ord
                        | ufp_cmp_unord

op ufp_cmp_ord ( crfd : card ( 3 ), fra : index, frb : index )
   syntax = format ( "fcmpo crf%d,fr%d,fr%d", crfd, fra, frb )
   image  = format ( "111111%3b00%5b%5b00001000000", crfd, fra, frb )
   action = {
		if 	( 	FPR[fra]<62..52> 
#line 1737 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1737 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1737 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frb]<62..52> 
#line 1737 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1737 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1737 "nmp/uisa_fp_instr.nmp"
 then
#line 1737 "nmp/uisa_fp_instr.nmp"
#line 1738 "nmp/uisa_fp_instr.nmp"
			TMP_BYTE = 0b0001;
		else
			if FPR [ fra ] < FPR [ frb ] then
				TMP_BYTE = 0b1000;
			else
				if FPR [ fra ] > FPR [ frb ] then
					TMP_BYTE = 0b0100;
				else
					TMP_BYTE = 0b0010;
				endif;
			endif;
		endif;
		FPSCR<15..12>=TMP_BYTE<3..0>;
		CR[(7-crfd)] < LT..SO > = TMP_BYTE <3..0>;

		if 	( 	( 	FPR[fra]<62..52> 
#line 1753 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1753 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1753 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1753 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1753 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1753 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1753 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1753 "nmp/uisa_fp_instr.nmp"
 then
#line 1753 "nmp/uisa_fp_instr.nmp"
#line 1754 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1754 "nmp/uisa_fp_instr.nmp"
;
#line 1754 "nmp/uisa_fp_instr.nmp"
#line 1755 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1755 "nmp/uisa_fp_instr.nmp"
;
#line 1755 "nmp/uisa_fp_instr.nmp"
#line 1756 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE>==0 then
					FPSCR <FP_VXVC..FP_VXVC> = 1 
#line 1757 "nmp/uisa_fp_instr.nmp"
;
#line 1757 "nmp/uisa_fp_instr.nmp"
#line 1758 "nmp/uisa_fp_instr.nmp"
			endif;
		endif;

		if 	( 	( 	FPR[fra]<62..52> 
#line 1761 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1761 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1761 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 1 ) 
#line 1761 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1761 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1761 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1761 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 1 ) 
#line 1761 "nmp/uisa_fp_instr.nmp"
 then
#line 1761 "nmp/uisa_fp_instr.nmp"
#line 1762 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VXVC..FP_VXVC> = 1 
#line 1762 "nmp/uisa_fp_instr.nmp"
;
#line 1762 "nmp/uisa_fp_instr.nmp"
#line 1763 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1763 "nmp/uisa_fp_instr.nmp"
;
#line 1763 "nmp/uisa_fp_instr.nmp"
#line 1764 "nmp/uisa_fp_instr.nmp"
		endif;

        }

op ufp_cmp_unord ( crfd : card ( 3 ), fra : index, frb : index )
   syntax = format ( "fcmpu crf%d,fr%d,fr%d", crfd, fra, frb )
   image  = format ( "111111%3b00%5b%5b00000000000", crfd, fra, frb )
   action = {

        if 	( 	FPR[fra]<62..52> 
#line 1773 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1773 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1773 "nmp/uisa_fp_instr.nmp"
 || 	( 	FPR[frb]<62..52> 
#line 1773 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1773 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1773 "nmp/uisa_fp_instr.nmp"
 then
#line 1773 "nmp/uisa_fp_instr.nmp"
#line 1774 "nmp/uisa_fp_instr.nmp"
			TMP_BYTE = 0b0001;
		else
			if FPR [ fra ] < FPR [ frb ] then
            	TMP_BYTE = 0b1000;
            else
                if FPR [ fra ] > FPR [ frb ] then
                    TMP_BYTE = 0b0100;
                else
                	TMP_BYTE = 0b0010;
                endif;
        	endif;
		endif;
		FPSCR<15..12> = TMP_BYTE<3..0>;
        CR[(7-crfd)] < LT..SO > = TMP_BYTE <3..0>;

		if 	( 	( 	FPR[fra]<62..52> 
#line 1789 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[fra]<51..0> 
#line 1789 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1789 "nmp/uisa_fp_instr.nmp"
 && FPR[fra] <51..51> == 0 ) 
#line 1789 "nmp/uisa_fp_instr.nmp"
 || 	( 	( 	FPR[frb]<62..52> 
#line 1789 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1789 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1789 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1789 "nmp/uisa_fp_instr.nmp"
 then
#line 1789 "nmp/uisa_fp_instr.nmp"
#line 1790 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1790 "nmp/uisa_fp_instr.nmp"
;
#line 1790 "nmp/uisa_fp_instr.nmp"
#line 1791 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1791 "nmp/uisa_fp_instr.nmp"
;
#line 1791 "nmp/uisa_fp_instr.nmp"
#line 1792 "nmp/uisa_fp_instr.nmp"
		endif;
		}

// 2.2.3 Floating point move Instructions
// --------------------------------------

op  ufp_move( x : ufp_move_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPMOV

op ufp_move_action =   ufp_mov_reg
                     | ufp_neg
                     | ufp_abs_val
                     | ufp_neg_abs_val

op ufp_mov_reg =   ufp_mr
                 | ufp_mr_cr_update

op ufp_mr ( frd : index, frb : index )
   syntax = format ( "fmr fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00010010000", frd, frb )
   action = {

               FPR [ frd ] = FPR [ frb ];

            }

op ufp_mr_cr_update ( frd : index, frb : index )
   syntax = format ( "fmr. fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00010010001", frd, frb )
   action = {

               FPR [ frd ] = FPR [ frb ];

		    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1828 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1828 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1828 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1828 "nmp/uisa_fp_instr.nmp"
;
#line 1828 "nmp/uisa_fp_instr.nmp"
#line 1829 "nmp/uisa_fp_instr.nmp"

            }

op ufp_neg =   ufp_neg_normal
             | ufp_neg_cr_update

op ufp_neg_normal ( frd : index, frb : index )
   syntax = format ( "fneg fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00001010000", frd, frb )
   action = {

               FPR [ frd ] < 63..63 > = ~FPR [ frb ] < 63..63 >;
               FPR [ frd ] < 62..0 > = FPR [ frb ] < 62..0 >;

            }

op ufp_neg_cr_update ( frd : index, frb : index )
   syntax = format ( "fneg. fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00001010001", frd, frb )
   action = {

               FPR [ frd ] < 63..63 > = ~FPR [ frb ] < 63..63 >;
               FPR [ frd ] < 62..0 > = FPR [ frb ] < 62..0 >;

		    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1853 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1853 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1853 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1853 "nmp/uisa_fp_instr.nmp"
;
#line 1853 "nmp/uisa_fp_instr.nmp"
#line 1854 "nmp/uisa_fp_instr.nmp"

            }

op ufp_abs_val =   ufp_abs
                 | ufp_abs_cr_update

op ufp_abs ( frd : index, frb : index )
   syntax = format ( "fabs fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b01000010000", frd, frb )
   action = {

               FPR [ frd ] < 63..63 > = 0;
               FPR [ frd ] < 62..0 > = FPR [ frb ] < 62..0 >;

            }

op ufp_abs_cr_update ( frd : index, frb : index )
   syntax = format ( "fabs. fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b01000010001", frd, frb )
   action = {

               FPR [ frd ] < 63..63 > = 0;
               FPR [ frd ] < 62..0 > = FPR [ frb ] < 62..0 >;

		    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1878 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1878 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1878 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1878 "nmp/uisa_fp_instr.nmp"
;
#line 1878 "nmp/uisa_fp_instr.nmp"
#line 1879 "nmp/uisa_fp_instr.nmp"

            }

op ufp_neg_abs_val =   ufp_nabs
                     | ufp_nabs_cr_update

op ufp_nabs ( frd : index, frb : index )
   syntax = format ( "fnabs fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00100010000", frd, frb )
   action = {

               FPR [ frd ] < 63..63 > = 1;
               FPR [ frd ] < 62..0 > = FPR [ frb ] < 62..0 >;

            }

op ufp_nabs_cr_update ( frd : index, frb : index )
   syntax = format ( "fnabs. fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00100010001", frd, frb )
   action = {

               FPR [ frd ] < 63..63 > = 1;
               FPR [ frd ] < 62..0 > = FPR [ frb ] < 62..0 >;

		    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1903 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1903 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1903 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1903 "nmp/uisa_fp_instr.nmp"
;
#line 1903 "nmp/uisa_fp_instr.nmp"
#line 1904 "nmp/uisa_fp_instr.nmp"

            }

// 2.2.4 Floating point round instructions
// ---------------------------------------
op  ufp_round ( x : ufp_round_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPRC

op ufp_round_action =   ufp_rsp
                      | ufp_rsp_cr_update

// Floating point round to single precision.

op ufp_rsp ( frd : index, frb : index )
   syntax = format ( "frsp fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00000011000", frd, frb )
   action = {
		;
#line 1924 "nmp/uisa_fp_instr.nmp"
#line 1925 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1925 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1925 "nmp/uisa_fp_instr.nmp"
#line 1926 "nmp/uisa_fp_instr.nmp"
        TMP_FLOTS = FPR [ frb ]; // use the host machine conversion.
			// HKC-SETR
#line 1927 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1927 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1927 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
;
#line 1927 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1927 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1927 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1927 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1927 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1927 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1927 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1927 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1927 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1927 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1927 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1927 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1927 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1927 "nmp/uisa_fp_instr.nmp"
 then 
#line 1927 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
	else 
#line 1927 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1927 "nmp/uisa_fp_instr.nmp"
 then 
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
		else 
#line 1927 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1927 "nmp/uisa_fp_instr.nmp"
 then 
#line 1927 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			else 
#line 1927 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1927 "nmp/uisa_fp_instr.nmp"
 then 
#line 1927 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
				else 
#line 1927 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1927 "nmp/uisa_fp_instr.nmp"
 then 
#line 1927 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
					else 
#line 1927 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1927 "nmp/uisa_fp_instr.nmp"
 then 
#line 1927 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
						else 
#line 1927 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1927 "nmp/uisa_fp_instr.nmp"
 then 
#line 1927 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
							else 
#line 1927 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1927 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1927 "nmp/uisa_fp_instr.nmp"
 then 
#line 1927 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
								else 
#line 1927 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1927 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1927 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1927 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			else 
#line 1927 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1927 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1927 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1927 "nmp/uisa_fp_instr.nmp"
; 
#line 1927 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1927 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1927 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1927 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1927 "nmp/uisa_fp_instr.nmp"
;
#line 1927 "nmp/uisa_fp_instr.nmp"
#line 1928 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
				FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1929 "nmp/uisa_fp_instr.nmp"
;
#line 1929 "nmp/uisa_fp_instr.nmp"
#line 1930 "nmp/uisa_fp_instr.nmp"
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
		}

op ufp_rsp_cr_update ( frd : index, frb : index )
   syntax = format ( "frsp. fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00000011001", frd, frb )
   action = {
		;
#line 1940 "nmp/uisa_fp_instr.nmp"
#line 1941 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1941 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1941 "nmp/uisa_fp_instr.nmp"
#line 1942 "nmp/uisa_fp_instr.nmp"
        TMP_FLOTS = FPR [ frb ]; // use the host machine conversion.
			// HKC-SETR
#line 1943 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INEXACT") then 
#line 1943 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1943 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
;
#line 1943 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1943 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1943 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1943 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1943 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1943 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1943 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1943 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1943 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1943 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1943 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1943 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1943 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1943 "nmp/uisa_fp_instr.nmp"
 then 
#line 1943 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
	else 
#line 1943 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1943 "nmp/uisa_fp_instr.nmp"
 then 
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
		else 
#line 1943 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1943 "nmp/uisa_fp_instr.nmp"
 then 
#line 1943 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			else 
#line 1943 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1943 "nmp/uisa_fp_instr.nmp"
 then 
#line 1943 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
				else 
#line 1943 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1943 "nmp/uisa_fp_instr.nmp"
 then 
#line 1943 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
					else 
#line 1943 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1943 "nmp/uisa_fp_instr.nmp"
 then 
#line 1943 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
						else 
#line 1943 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1943 "nmp/uisa_fp_instr.nmp"
 then 
#line 1943 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
							else 
#line 1943 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1943 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1943 "nmp/uisa_fp_instr.nmp"
 then 
#line 1943 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
								else 
#line 1943 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1943 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1943 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1943 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			else 
#line 1943 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1943 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1943 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1943 "nmp/uisa_fp_instr.nmp"
; 
#line 1943 "nmp/uisa_fp_instr.nmp"
	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then 
#line 1943 "nmp/uisa_fp_instr.nmp"
		FPR[frd] = TMP_FLOTS; 
#line 1943 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1943 "nmp/uisa_fp_instr.nmp"
	// /HKC-SETR
#line 1943 "nmp/uisa_fp_instr.nmp"
;
#line 1943 "nmp/uisa_fp_instr.nmp"
#line 1944 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
				FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1945 "nmp/uisa_fp_instr.nmp"
;
#line 1945 "nmp/uisa_fp_instr.nmp"
#line 1946 "nmp/uisa_fp_instr.nmp"
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 1950 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 1950 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 1950 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 1950 "nmp/uisa_fp_instr.nmp"
;
#line 1950 "nmp/uisa_fp_instr.nmp"
#line 1951 "nmp/uisa_fp_instr.nmp"
		endif;
			}

// Floating point Rounding and Conversion Instructions

op  ufp_convert ( x : ufp_convert_action )
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   otawa_kind = FPRC

op ufp_convert_action =   ufp_ctiw | ufp_ctiw_cr_update | ufp_ctiwz | ufp_ctiwz_cr_update

op ufp_ctiw ( frd : index, frb : index )
   syntax = format ( "fctiw fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00000011100", frd, frb)
   action = {
		;
#line 1968 "nmp/uisa_fp_instr.nmp"
#line 1969 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1969 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1969 "nmp/uisa_fp_instr.nmp"
#line 1970 "nmp/uisa_fp_instr.nmp"
		TMP_SWORD = coerce(int(32), FPR[frb]);
				if "fpi_testexcept"("FPI_INEXACT") then 
#line 1971 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1971 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
;
#line 1971 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1971 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1971 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1971 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1971 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1971 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1971 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1971 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1971 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1971 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1971 "nmp/uisa_fp_instr.nmp"
 then 
#line 1971 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	else 
#line 1971 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1971 "nmp/uisa_fp_instr.nmp"
 then 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		else 
#line 1971 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1971 "nmp/uisa_fp_instr.nmp"
 then 
#line 1971 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			else 
#line 1971 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1971 "nmp/uisa_fp_instr.nmp"
 then 
#line 1971 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				else 
#line 1971 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1971 "nmp/uisa_fp_instr.nmp"
 then 
#line 1971 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
					else 
#line 1971 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1971 "nmp/uisa_fp_instr.nmp"
 then 
#line 1971 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
						else 
#line 1971 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1971 "nmp/uisa_fp_instr.nmp"
 then 
#line 1971 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
							else 
#line 1971 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1971 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1971 "nmp/uisa_fp_instr.nmp"
 then 
#line 1971 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
								else 
#line 1971 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1971 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1971 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			else 
#line 1971 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1971 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1971 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	//FP_CHECK_VX_EXCEPTION64(frd); \
#line 1971 "nmp/uisa_fp_instr.nmp"
	//if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
#line 1971 "nmp/uisa_fp_instr.nmp"
	//	FP_CHECK_ZX_EXCEPTION32(frd,TMP_SWORD); \
#line 1971 "nmp/uisa_fp_instr.nmp"
	//	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
#line 1971 "nmp/uisa_fp_instr.nmp"
			FPR[frd]<31..0> = TMP_SWORD; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			FPR[frd]<63..32> = 0; 
#line 1971 "nmp/uisa_fp_instr.nmp"
			//FPR[frd] = TMP_SWORD; \
#line 1971 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_OX..FP_OX> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_OE..FP_OE> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		else 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_XX..FP_XX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_XX..FP_XX> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_UX..FP_UX> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_UE..FP_UE> then 
#line 1971 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1971 "nmp/uisa_fp_instr.nmp"
; 
#line 1971 "nmp/uisa_fp_instr.nmp"
	//	endif; \
#line 1971 "nmp/uisa_fp_instr.nmp"
	//endif; \
#line 1971 "nmp/uisa_fp_instr.nmp"
;
#line 1971 "nmp/uisa_fp_instr.nmp"
#line 1972 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[frb]<62..52> 
#line 1973 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1973 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1973 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1973 "nmp/uisa_fp_instr.nmp"
 then
#line 1973 "nmp/uisa_fp_instr.nmp"
#line 1974 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1974 "nmp/uisa_fp_instr.nmp"
;
#line 1974 "nmp/uisa_fp_instr.nmp"
#line 1975 "nmp/uisa_fp_instr.nmp"
			endif;
				FPSCR <FP_VXCVI..FP_VXCVI> = 1 
#line 1976 "nmp/uisa_fp_instr.nmp"
;
#line 1976 "nmp/uisa_fp_instr.nmp"
#line 1977 "nmp/uisa_fp_instr.nmp"
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
   }

op ufp_ctiw_cr_update ( frd : index, frb : index )
   syntax = format ( "fctiw. fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00000011101", frd, frb)
   action = {
		;
#line 1987 "nmp/uisa_fp_instr.nmp"
#line 1988 "nmp/uisa_fp_instr.nmp"
			"fpi_clearexcept"(fp_clear); 
#line 1988 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 1988 "nmp/uisa_fp_instr.nmp"
#line 1989 "nmp/uisa_fp_instr.nmp"
		TMP_SWORD = coerce(int(32), FPR[frb]);
				if "fpi_testexcept"("FPI_INEXACT") then 
#line 1990 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 1990 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
;
#line 1990 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1990 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 1990 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 1990 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 1990 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 1990 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 1990 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 1990 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 1990 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1990 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 1990 "nmp/uisa_fp_instr.nmp"
 then 
#line 1990 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	else 
#line 1990 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1990 "nmp/uisa_fp_instr.nmp"
 then 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		else 
#line 1990 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1990 "nmp/uisa_fp_instr.nmp"
 then 
#line 1990 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			else 
#line 1990 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1990 "nmp/uisa_fp_instr.nmp"
 then 
#line 1990 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				else 
#line 1990 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1990 "nmp/uisa_fp_instr.nmp"
 then 
#line 1990 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
					else 
#line 1990 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 1990 "nmp/uisa_fp_instr.nmp"
 then 
#line 1990 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
						else 
#line 1990 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1990 "nmp/uisa_fp_instr.nmp"
 then 
#line 1990 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
							else 
#line 1990 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 1990 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 1990 "nmp/uisa_fp_instr.nmp"
 then 
#line 1990 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
								else 
#line 1990 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 1990 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 1990 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			else 
#line 1990 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 1990 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 1990 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	//FP_CHECK_VX_EXCEPTION64(frd); \
#line 1990 "nmp/uisa_fp_instr.nmp"
	//if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
#line 1990 "nmp/uisa_fp_instr.nmp"
	//	FP_CHECK_ZX_EXCEPTION32(frd,TMP_SWORD); \
#line 1990 "nmp/uisa_fp_instr.nmp"
	//	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
#line 1990 "nmp/uisa_fp_instr.nmp"
			FPR[frd]<31..0> = TMP_SWORD; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			FPR[frd]<63..32> = 0; 
#line 1990 "nmp/uisa_fp_instr.nmp"
			//FPR[frd] = TMP_SWORD; \
#line 1990 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_OX..FP_OX> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_OE..FP_OE> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		else 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_XX..FP_XX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_XX..FP_XX> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_UX..FP_UX> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_UE..FP_UE> then 
#line 1990 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 1990 "nmp/uisa_fp_instr.nmp"
; 
#line 1990 "nmp/uisa_fp_instr.nmp"
	//	endif; \
#line 1990 "nmp/uisa_fp_instr.nmp"
	//endif; \
#line 1990 "nmp/uisa_fp_instr.nmp"
;
#line 1990 "nmp/uisa_fp_instr.nmp"
#line 1991 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[frb]<62..52> 
#line 1992 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 1992 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 1992 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 1992 "nmp/uisa_fp_instr.nmp"
 then
#line 1992 "nmp/uisa_fp_instr.nmp"
#line 1993 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 1993 "nmp/uisa_fp_instr.nmp"
;
#line 1993 "nmp/uisa_fp_instr.nmp"
#line 1994 "nmp/uisa_fp_instr.nmp"
			endif;
				FPSCR <FP_VXCVI..FP_VXCVI> = 1 
#line 1995 "nmp/uisa_fp_instr.nmp"
;
#line 1995 "nmp/uisa_fp_instr.nmp"
#line 1996 "nmp/uisa_fp_instr.nmp"
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 2000 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 2000 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 2000 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 2000 "nmp/uisa_fp_instr.nmp"
;
#line 2000 "nmp/uisa_fp_instr.nmp"
#line 2001 "nmp/uisa_fp_instr.nmp"
		endif;
   }

op ufp_ctiwz ( frd : index, frb : index )
   syntax = format ( "fctiwz fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00000011110", frd, frb)
   action = {
   		"fpi_setround"("FPI_TOWARDZERO");
			"fpi_clearexcept"(fp_clear); 
#line 2009 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 2009 "nmp/uisa_fp_instr.nmp"
#line 2010 "nmp/uisa_fp_instr.nmp"

		TMP_SWORD = coerce(int(32), FPR[frb]);

				if "fpi_testexcept"("FPI_INEXACT") then 
#line 2013 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 2013 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
;
#line 2013 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 2013 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 2013 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 2013 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 2013 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 2013 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 2013 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 2013 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 2013 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 2013 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 2013 "nmp/uisa_fp_instr.nmp"
 then 
#line 2013 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	else 
#line 2013 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 2013 "nmp/uisa_fp_instr.nmp"
 then 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		else 
#line 2013 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 2013 "nmp/uisa_fp_instr.nmp"
 then 
#line 2013 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			else 
#line 2013 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 2013 "nmp/uisa_fp_instr.nmp"
 then 
#line 2013 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				else 
#line 2013 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 2013 "nmp/uisa_fp_instr.nmp"
 then 
#line 2013 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
					else 
#line 2013 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 2013 "nmp/uisa_fp_instr.nmp"
 then 
#line 2013 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
						else 
#line 2013 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 2013 "nmp/uisa_fp_instr.nmp"
 then 
#line 2013 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
							else 
#line 2013 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 2013 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 2013 "nmp/uisa_fp_instr.nmp"
 then 
#line 2013 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
								else 
#line 2013 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 2013 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 2013 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			else 
#line 2013 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 2013 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 2013 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	//FP_CHECK_VX_EXCEPTION64(frd); \
#line 2013 "nmp/uisa_fp_instr.nmp"
	//if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
#line 2013 "nmp/uisa_fp_instr.nmp"
	//	FP_CHECK_ZX_EXCEPTION32(frd,TMP_SWORD); \
#line 2013 "nmp/uisa_fp_instr.nmp"
	//	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
#line 2013 "nmp/uisa_fp_instr.nmp"
			FPR[frd]<31..0> = TMP_SWORD; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			FPR[frd]<63..32> = 0; 
#line 2013 "nmp/uisa_fp_instr.nmp"
			//FPR[frd] = TMP_SWORD; \
#line 2013 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_OX..FP_OX> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_OE..FP_OE> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		else 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_XX..FP_XX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_XX..FP_XX> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_UX..FP_UX> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_UE..FP_UE> then 
#line 2013 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2013 "nmp/uisa_fp_instr.nmp"
; 
#line 2013 "nmp/uisa_fp_instr.nmp"
	//	endif; \
#line 2013 "nmp/uisa_fp_instr.nmp"
	//endif; \
#line 2013 "nmp/uisa_fp_instr.nmp"
;
#line 2013 "nmp/uisa_fp_instr.nmp"
#line 2014 "nmp/uisa_fp_instr.nmp"

		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[frb]<62..52> 
#line 2016 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 2016 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 2016 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 2016 "nmp/uisa_fp_instr.nmp"
 then
#line 2016 "nmp/uisa_fp_instr.nmp"
#line 2017 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 2017 "nmp/uisa_fp_instr.nmp"
;
#line 2017 "nmp/uisa_fp_instr.nmp"
#line 2018 "nmp/uisa_fp_instr.nmp"
			endif;
				FPSCR <FP_VXCVI..FP_VXCVI> = 1 
#line 2019 "nmp/uisa_fp_instr.nmp"
;
#line 2019 "nmp/uisa_fp_instr.nmp"
#line 2020 "nmp/uisa_fp_instr.nmp"
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		endif;
   }

op ufp_ctiwz_cr_update ( frd : index, frb : index )
   syntax = format ( "fctiwz. fr%d,fr%d", frd, frb )
   image  = format ( "111111%5b00000%5b00000011111", frd, frb)
   action = {
   		"fpi_setround"("FPI_TOWARDZERO");
			"fpi_clearexcept"(fp_clear); 
#line 2031 "nmp/uisa_fp_instr.nmp"
	FPSCR<FP_FEX .. FP_FEX> = 0;;
#line 2031 "nmp/uisa_fp_instr.nmp"
#line 2032 "nmp/uisa_fp_instr.nmp"
		TMP_SWORD = coerce(int(32), FPR[frb]);
				if "fpi_testexcept"("FPI_INEXACT") then 
#line 2033 "nmp/uisa_fp_instr.nmp"
		// "puts"("EXN: INEXACT"); \
#line 2033 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_XX..FP_XX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			FPSCR <FP_FX..FP_FX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
;
#line 2033 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 2033 "nmp/uisa_fp_instr.nmp"
	if "fpi_testexcept"("FPI_DIVBYZERO" | "FPI_UNDERFLOW" | "FPI_OVERFLOW" | "FPI_INVALID") then 
#line 2033 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY \
#line 2033 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_DIVBYZERO") then 
#line 2033 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: DIVBYZERO"); \
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_ZX..FP_ZX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_ZE..FP_ZE> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_UNDERFLOW") then 
#line 2033 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: UNDERFLOW"); \
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_UX..FP_UX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_UE..FP_UE> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_INVALID") then 
#line 2033 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: INVALID"); \
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_VX..FP_VX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			// HKC-SETR \
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FR..FP_FR> = 0 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 0 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			// /HKC-SETR \
#line 2033 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_VE..FP_VE> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				// HKC-SETR \
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPR[frd]<63..0>=0x7FF8000000000000 ; // TODO replace with macro argument 
#line 2033 "nmp/uisa_fp_instr.nmp"
					if 	( 	( 	FPR[frd]<62..52> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 2033 "nmp/uisa_fp_instr.nmp"
 && FPR[frd] <51..51> == 1 ) 
#line 2033 "nmp/uisa_fp_instr.nmp"
 then 
#line 2033 "nmp/uisa_fp_instr.nmp"
			FPSCR <16..12> = 0b10001; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	else 
#line 2033 "nmp/uisa_fp_instr.nmp"
		if 	( 	FPR[frd]<63..63> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frd]<51..0> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 2033 "nmp/uisa_fp_instr.nmp"
 then 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <16..12> = 0b01001; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		else 
#line 2033 "nmp/uisa_fp_instr.nmp"
			if 	( 	FPR[frd]<63..63> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 2033 "nmp/uisa_fp_instr.nmp"
 then 
#line 2033 "nmp/uisa_fp_instr.nmp"
					FPSCR <16..12> = 0b01000; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			else 
#line 2033 "nmp/uisa_fp_instr.nmp"
				if 	( 	FPR[frd]<63..63> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 2033 "nmp/uisa_fp_instr.nmp"
 then 
#line 2033 "nmp/uisa_fp_instr.nmp"
						FPSCR <16..12> = 0b11000; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				else 
#line 2033 "nmp/uisa_fp_instr.nmp"
					if 	( 	FPR[frd]<63..63> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 1 && 	FPR[frd]<62..52> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 2033 "nmp/uisa_fp_instr.nmp"
 then 
#line 2033 "nmp/uisa_fp_instr.nmp"
							FPSCR <16..12> = 0b10010; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
					else 
#line 2033 "nmp/uisa_fp_instr.nmp"
						if 	( 	FPR[frd]<63..63> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 0 ) 
#line 2033 "nmp/uisa_fp_instr.nmp"
 then 
#line 2033 "nmp/uisa_fp_instr.nmp"
								FPSCR <16..12> = 0b00010; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
						else 
#line 2033 "nmp/uisa_fp_instr.nmp"
							if 	( 	FPR[frd]<63..63> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<51..0> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 2033 "nmp/uisa_fp_instr.nmp"
 then 
#line 2033 "nmp/uisa_fp_instr.nmp"
									FPSCR <16..12> = 0b10100; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
							else 
#line 2033 "nmp/uisa_fp_instr.nmp"
								if 	( 	FPR[frd]<63..63> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 == 0 && 	FPR[frd]<62..52> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 > 0 && 	FPR[frd]<62..52> 
#line 2033 "nmp/uisa_fp_instr.nmp"
 < 2047 ) 
#line 2033 "nmp/uisa_fp_instr.nmp"
 then 
#line 2033 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b00100; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
								else 
#line 2033 "nmp/uisa_fp_instr.nmp"
										FPSCR <16..12> = 0b01101; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
								endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
							endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
						endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
					endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				// /HKC-SETR
#line 2033 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		if "fpi_testexcept"("FPI_OVERFLOW") then 
#line 2033 "nmp/uisa_fp_instr.nmp"
			// "puts"("EXN: OVERFLOW"); \
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_OX..FP_OX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FX..FP_FX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			if FPSCR<FP_OE..FP_OE> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_FEX..FP_FEX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			else 
#line 2033 "nmp/uisa_fp_instr.nmp"
				if MSR<MSR_FE0..MSR_FE0>!=0 && MSR<MSR_FE1..MSR_FE1>!=0 then 
#line 2033 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_XX..FP_XX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
						FPSCR <FP_FI..FP_FI> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	// HKC-COPY \
#line 2033 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	// /HKC-COPY
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	//FP_CHECK_VX_EXCEPTION64(frd); \
#line 2033 "nmp/uisa_fp_instr.nmp"
	//if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
#line 2033 "nmp/uisa_fp_instr.nmp"
	//	FP_CHECK_ZX_EXCEPTION32(frd,TMP_SWORD); \
#line 2033 "nmp/uisa_fp_instr.nmp"
	//	if !(FPSCR<FP_FEX..FP_FEX> && MSR<MSR_FE0..MSR_FE0>==0 && MSR<MSR_FE1..MSR_FE1>==0) then \
#line 2033 "nmp/uisa_fp_instr.nmp"
			FPR[frd]<31..0> = TMP_SWORD; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			FPR[frd]<63..32> = 0; 
#line 2033 "nmp/uisa_fp_instr.nmp"
			//FPR[frd] = TMP_SWORD; \
#line 2033 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_OX..FP_OX> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_OE..FP_OE> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		else 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_XX..FP_XX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FI..FP_FI> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_XX..FP_XX> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_XE..FP_XE> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
				if FPSCR<FP_UX..FP_UX> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_UE..FP_UE> then 
#line 2033 "nmp/uisa_fp_instr.nmp"
				FPSCR <FP_FEX..FP_FEX> = 1 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2033 "nmp/uisa_fp_instr.nmp"
; 
#line 2033 "nmp/uisa_fp_instr.nmp"
	//	endif; \
#line 2033 "nmp/uisa_fp_instr.nmp"
	//endif; \
#line 2033 "nmp/uisa_fp_instr.nmp"
;
#line 2033 "nmp/uisa_fp_instr.nmp"
#line 2034 "nmp/uisa_fp_instr.nmp"
		if FPSCR<FP_VX..FP_VX> then
			if 	( 	( 	FPR[frb]<62..52> 
#line 2035 "nmp/uisa_fp_instr.nmp"
 == 2047 && 	FPR[frb]<51..0> 
#line 2035 "nmp/uisa_fp_instr.nmp"
 != 0 ) 
#line 2035 "nmp/uisa_fp_instr.nmp"
 && FPR[frb] <51..51> == 0 ) 
#line 2035 "nmp/uisa_fp_instr.nmp"
 then
#line 2035 "nmp/uisa_fp_instr.nmp"
#line 2036 "nmp/uisa_fp_instr.nmp"
					FPSCR <FP_VXSNAN..FP_VXSNAN> = 1 
#line 2036 "nmp/uisa_fp_instr.nmp"
;
#line 2036 "nmp/uisa_fp_instr.nmp"
#line 2037 "nmp/uisa_fp_instr.nmp"
			endif;
				FPSCR <FP_VXCVI..FP_VXCVI> = 1 
#line 2038 "nmp/uisa_fp_instr.nmp"
;
#line 2038 "nmp/uisa_fp_instr.nmp"
#line 2039 "nmp/uisa_fp_instr.nmp"
		endif;
		if FPSCR<FP_FEX..FP_FEX> then
			"launch_exception"("instr",PROGRAM);
		else
			    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 2043 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 2043 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 2043 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 2043 "nmp/uisa_fp_instr.nmp"
;
#line 2043 "nmp/uisa_fp_instr.nmp"
#line 2044 "nmp/uisa_fp_instr.nmp"
		endif;
   }

// 2.2.5 Floating-Point Status and Control Register Instructions
// -------------------------------------------------------------
// MCRFS, MFFSx, MTFSB0x, MTFSB1x, MTFSFx, MTFSFIx

op ufp_status_cr_instr ( x : ufp_status_cr_instr_action )
	syntax = x.syntax
	image = x.image
	action = { x.action; }
        otawa_kind = FPSCRI

op ufp_status_cr_instr_action =   ufp_mov_cr_fs
                                | ufp_movf_fs
				| ufp_movf_fsx
				| ufp_movt_fsb0
				| ufp_movt_fsb0x
				| ufp_movt_fsb1
				| ufp_movt_fsb1x
				| ufp_movt_fsf
				| ufp_movt_fsfx
				| ufp_movt_fsfi
				| ufp_movt_fsfix

op ufp_mov_cr_fs ( crfd: card ( 3 ), crfs: card ( 3 ) )
	syntax = format ( "mcrfs crf%d,crf%d", crfd, crfs )
	image  = format ( "111111%3b00%3b000000000010000000", crfd, crfs )
	action = {
		CR[7-crfd]=FPSCR<31-(4*crfs)..28-(4*crfs)>;
		if crfs == 0 then
			FPSCR<31..31>=0;
			FPSCR<28..28>=0;
		endif;
		if crfs == 1 then
			FPSCR<27..24>=0;
		endif;
		if crfs == 2 then
			FPSCR<23..20>=0;
		endif;
		if crfs == 3 then
			FPSCR<19..19>=0;
		endif;
		if crfs == 5 then
			FPSCR<10..8>=0;
		endif;
		}

op ufp_movf_fs ( frd: index )
	syntax = format ( "mffs fr%d", frd )
	image  = format ( "111111%5b000000000010010001110", frd )
	action = {
		FPR[frd]<31..0>=FPSCR;
		}

op ufp_movf_fsx ( frd: index )
	syntax = format ( "mffs. fr%d", frd )
	image  = format ( "111111%5b000000000010010001111", frd )
	action = {
		FPR[frd]<31..0>=FPSCR;
		    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 2104 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 2104 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 2104 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 2104 "nmp/uisa_fp_instr.nmp"
;
#line 2104 "nmp/uisa_fp_instr.nmp"
#line 2105 "nmp/uisa_fp_instr.nmp"
		}

op ufp_movt_fsb0 ( crbd: index )
	syntax = format ( "mtfsb0 crb%d", crbd )
	image  = format ( "111111%5b000000000000010001100", crbd )
	action = {
		if ( crbd != FEX & crbd != VX ) then
			FPSCR<31-crbd..31-crbd> = 0;
			// HKC
					if 	FPSCR < 1..0 > 
#line 2114 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TONEAREST then 
#line 2114 "nmp/uisa_fp_instr.nmp"
		"fpi_setround"("FPI_TONEAREST"); 
#line 2114 "nmp/uisa_fp_instr.nmp"
	else 
#line 2114 "nmp/uisa_fp_instr.nmp"
		if 	FPSCR < 1..0 > 
#line 2114 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TOWARDZERO then 
#line 2114 "nmp/uisa_fp_instr.nmp"
			"fpi_setround"("FPI_TOWARDZERO"); 
#line 2114 "nmp/uisa_fp_instr.nmp"
		else 
#line 2114 "nmp/uisa_fp_instr.nmp"
			if 	FPSCR < 1..0 > 
#line 2114 "nmp/uisa_fp_instr.nmp"
 == FP_RN_UPWARD then 
#line 2114 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_UPWARD"); 
#line 2114 "nmp/uisa_fp_instr.nmp"
			else 
#line 2114 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_DOWNWARD"); 
#line 2114 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2114 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2114 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2114 "nmp/uisa_fp_instr.nmp"
; 
#line 2114 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_OE .. FP_OE> then fp_clear = fp_clear | "FPI_OVERFLOW"; endif; 
#line 2114 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_UE .. FP_UE> then fp_clear = fp_clear | "FPI_UNDERFLOW"; endif; 
#line 2114 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_XE .. FP_XE> then fp_clear = fp_clear | "FPI_INEXACT"; endif;;
#line 2114 "nmp/uisa_fp_instr.nmp"
#line 2115 "nmp/uisa_fp_instr.nmp"
			// /HKC
		endif;
		}

op ufp_movt_fsb0x ( crbd: index )
	syntax = format ( "mtfsb0. crb%d", crbd )
	image  = format ( "111111%5b000000000000010001101", crbd )
	action = {
		if ( crbd != FEX & crbd != VX ) then
			FPSCR<31-crbd..31-crbd> = 0;
			// HKC
					if 	FPSCR < 1..0 > 
#line 2126 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TONEAREST then 
#line 2126 "nmp/uisa_fp_instr.nmp"
		"fpi_setround"("FPI_TONEAREST"); 
#line 2126 "nmp/uisa_fp_instr.nmp"
	else 
#line 2126 "nmp/uisa_fp_instr.nmp"
		if 	FPSCR < 1..0 > 
#line 2126 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TOWARDZERO then 
#line 2126 "nmp/uisa_fp_instr.nmp"
			"fpi_setround"("FPI_TOWARDZERO"); 
#line 2126 "nmp/uisa_fp_instr.nmp"
		else 
#line 2126 "nmp/uisa_fp_instr.nmp"
			if 	FPSCR < 1..0 > 
#line 2126 "nmp/uisa_fp_instr.nmp"
 == FP_RN_UPWARD then 
#line 2126 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_UPWARD"); 
#line 2126 "nmp/uisa_fp_instr.nmp"
			else 
#line 2126 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_DOWNWARD"); 
#line 2126 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2126 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2126 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2126 "nmp/uisa_fp_instr.nmp"
; 
#line 2126 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_OE .. FP_OE> then fp_clear = fp_clear | "FPI_OVERFLOW"; endif; 
#line 2126 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_UE .. FP_UE> then fp_clear = fp_clear | "FPI_UNDERFLOW"; endif; 
#line 2126 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_XE .. FP_XE> then fp_clear = fp_clear | "FPI_INEXACT"; endif;;
#line 2126 "nmp/uisa_fp_instr.nmp"
#line 2127 "nmp/uisa_fp_instr.nmp"
			// /HKC
		endif;
		    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 2129 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 2129 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 2129 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 2129 "nmp/uisa_fp_instr.nmp"
;
#line 2129 "nmp/uisa_fp_instr.nmp"
#line 2130 "nmp/uisa_fp_instr.nmp"
		}

op ufp_movt_fsb1 ( crbd: index )
	syntax = format ( "mtfsb1 crb%d", crbd )
	image  = format ( "111111%5b000000000000001001100", crbd )
	action = {
		if ( crbd != FEX & crbd != VX ) then
			FPSCR<31-crbd..31-crbd> = 1;
			// HKC
					if 	FPSCR < 1..0 > 
#line 2139 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TONEAREST then 
#line 2139 "nmp/uisa_fp_instr.nmp"
		"fpi_setround"("FPI_TONEAREST"); 
#line 2139 "nmp/uisa_fp_instr.nmp"
	else 
#line 2139 "nmp/uisa_fp_instr.nmp"
		if 	FPSCR < 1..0 > 
#line 2139 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TOWARDZERO then 
#line 2139 "nmp/uisa_fp_instr.nmp"
			"fpi_setround"("FPI_TOWARDZERO"); 
#line 2139 "nmp/uisa_fp_instr.nmp"
		else 
#line 2139 "nmp/uisa_fp_instr.nmp"
			if 	FPSCR < 1..0 > 
#line 2139 "nmp/uisa_fp_instr.nmp"
 == FP_RN_UPWARD then 
#line 2139 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_UPWARD"); 
#line 2139 "nmp/uisa_fp_instr.nmp"
			else 
#line 2139 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_DOWNWARD"); 
#line 2139 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2139 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2139 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2139 "nmp/uisa_fp_instr.nmp"
; 
#line 2139 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_OE .. FP_OE> then fp_clear = fp_clear | "FPI_OVERFLOW"; endif; 
#line 2139 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_UE .. FP_UE> then fp_clear = fp_clear | "FPI_UNDERFLOW"; endif; 
#line 2139 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_XE .. FP_XE> then fp_clear = fp_clear | "FPI_INEXACT"; endif;;
#line 2139 "nmp/uisa_fp_instr.nmp"
#line 2140 "nmp/uisa_fp_instr.nmp"
			// /HKC
		endif;
		}

op ufp_movt_fsb1x ( crbd: index )
	syntax = format ( "mtfsb1. crb%d", crbd )
	image  = format ( "111111%5b000000000000001001101", crbd )
	action = {
		if ( crbd != FEX & crbd != VX ) then
			FPSCR<31-crbd..31-crbd> = 1;
			// HKC
					if 	FPSCR < 1..0 > 
#line 2151 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TONEAREST then 
#line 2151 "nmp/uisa_fp_instr.nmp"
		"fpi_setround"("FPI_TONEAREST"); 
#line 2151 "nmp/uisa_fp_instr.nmp"
	else 
#line 2151 "nmp/uisa_fp_instr.nmp"
		if 	FPSCR < 1..0 > 
#line 2151 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TOWARDZERO then 
#line 2151 "nmp/uisa_fp_instr.nmp"
			"fpi_setround"("FPI_TOWARDZERO"); 
#line 2151 "nmp/uisa_fp_instr.nmp"
		else 
#line 2151 "nmp/uisa_fp_instr.nmp"
			if 	FPSCR < 1..0 > 
#line 2151 "nmp/uisa_fp_instr.nmp"
 == FP_RN_UPWARD then 
#line 2151 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_UPWARD"); 
#line 2151 "nmp/uisa_fp_instr.nmp"
			else 
#line 2151 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_DOWNWARD"); 
#line 2151 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2151 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2151 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2151 "nmp/uisa_fp_instr.nmp"
; 
#line 2151 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_OE .. FP_OE> then fp_clear = fp_clear | "FPI_OVERFLOW"; endif; 
#line 2151 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_UE .. FP_UE> then fp_clear = fp_clear | "FPI_UNDERFLOW"; endif; 
#line 2151 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_XE .. FP_XE> then fp_clear = fp_clear | "FPI_INEXACT"; endif;;
#line 2151 "nmp/uisa_fp_instr.nmp"
#line 2152 "nmp/uisa_fp_instr.nmp"
			// /HKC
		endif;
		    CR[6]<FX..FX> = FPSCR<FX..FX>; 
#line 2154 "nmp/uisa_fp_instr.nmp"
    CR[6]<FEX..FEX> = FPSCR<FEX..FEX>; 
#line 2154 "nmp/uisa_fp_instr.nmp"
    CR[6]<VX..VX> = FPSCR<VX..VX>; 
#line 2154 "nmp/uisa_fp_instr.nmp"
    CR[6]<OX..OX> = FPSCR<OX..OX>; 
#line 2154 "nmp/uisa_fp_instr.nmp"
;
#line 2154 "nmp/uisa_fp_instr.nmp"
#line 2155 "nmp/uisa_fp_instr.nmp"
		}

op ufp_movt_fsf ( fm: card ( 8 ), frb: FREG_IND )
	syntax = format ( "mtfsf %d,%s", fm, frb.syntax )
	image  = format ( "1111110%8b0%s10110001110", fm, frb.image )
	action = {
		}

op ufp_movt_fsfx ( fm: card ( 8 ), frb: FREG_IND )
	syntax = format ( "mtfsf. %d,%s", fm, frb.syntax )
	image  = format ( "1111110%8b0%s10110001111", fm, frb.image )
	action = {
		}

op ufp_movt_fsfi ( crf: card ( 3 ), imm :   card(4) )
	syntax = format ( "mtfsfi crf%d,%d", crf, imm)
	image  = format ( "111111%3b0000000%4b000100001100", crf, imm )
	action = {
		TMP_WORD = 31-(crf*4);
		TMP_WORD1 = imm;
		if (TMP_WORD == 31 ) then
			FPSCR<31..31> = TMP_WORD1 <3..3>;
			FPSCR<28..28> = TMP_WORD1 <0..0>;
		else
			FPSCR<TMP_WORD..TMP_WORD-3> = TMP_WORD1<3..0>;
			// HKC
					if 	FPSCR < 1..0 > 
#line 2181 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TONEAREST then 
#line 2181 "nmp/uisa_fp_instr.nmp"
		"fpi_setround"("FPI_TONEAREST"); 
#line 2181 "nmp/uisa_fp_instr.nmp"
	else 
#line 2181 "nmp/uisa_fp_instr.nmp"
		if 	FPSCR < 1..0 > 
#line 2181 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TOWARDZERO then 
#line 2181 "nmp/uisa_fp_instr.nmp"
			"fpi_setround"("FPI_TOWARDZERO"); 
#line 2181 "nmp/uisa_fp_instr.nmp"
		else 
#line 2181 "nmp/uisa_fp_instr.nmp"
			if 	FPSCR < 1..0 > 
#line 2181 "nmp/uisa_fp_instr.nmp"
 == FP_RN_UPWARD then 
#line 2181 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_UPWARD"); 
#line 2181 "nmp/uisa_fp_instr.nmp"
			else 
#line 2181 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_DOWNWARD"); 
#line 2181 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2181 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2181 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2181 "nmp/uisa_fp_instr.nmp"
; 
#line 2181 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_OE .. FP_OE> then fp_clear = fp_clear | "FPI_OVERFLOW"; endif; 
#line 2181 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_UE .. FP_UE> then fp_clear = fp_clear | "FPI_UNDERFLOW"; endif; 
#line 2181 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_XE .. FP_XE> then fp_clear = fp_clear | "FPI_INEXACT"; endif;;
#line 2181 "nmp/uisa_fp_instr.nmp"
#line 2182 "nmp/uisa_fp_instr.nmp"
			// /HKC
		endif;
		}

op ufp_movt_fsfix ( crf: card ( 3 ), imm :   card(4) )
	syntax = format ( "mtfsfi. crf%d,%d", crf, imm)
	image  = format ( "111111%3b0000000%4b000100001101", crf, imm )
	action = {
		TMP_WORD = 31-(crf*4);
		TMP_WORD1 = imm;
		if (TMP_WORD == 31 ) then
			FPSCR<31..31> = TMP_WORD1 <3..3>;
			FPSCR<28..28> = TMP_WORD1 <0..0>;
		else
			FPSCR<TMP_WORD..TMP_WORD-3> = TMP_WORD1<3..0>;
			// HKC
					if 	FPSCR < 1..0 > 
#line 2198 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TONEAREST then 
#line 2198 "nmp/uisa_fp_instr.nmp"
		"fpi_setround"("FPI_TONEAREST"); 
#line 2198 "nmp/uisa_fp_instr.nmp"
	else 
#line 2198 "nmp/uisa_fp_instr.nmp"
		if 	FPSCR < 1..0 > 
#line 2198 "nmp/uisa_fp_instr.nmp"
 == FP_RN_TOWARDZERO then 
#line 2198 "nmp/uisa_fp_instr.nmp"
			"fpi_setround"("FPI_TOWARDZERO"); 
#line 2198 "nmp/uisa_fp_instr.nmp"
		else 
#line 2198 "nmp/uisa_fp_instr.nmp"
			if 	FPSCR < 1..0 > 
#line 2198 "nmp/uisa_fp_instr.nmp"
 == FP_RN_UPWARD then 
#line 2198 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_UPWARD"); 
#line 2198 "nmp/uisa_fp_instr.nmp"
			else 
#line 2198 "nmp/uisa_fp_instr.nmp"
				"fpi_setround"("FPI_DOWNWARD"); 
#line 2198 "nmp/uisa_fp_instr.nmp"
			endif; 
#line 2198 "nmp/uisa_fp_instr.nmp"
		endif; 
#line 2198 "nmp/uisa_fp_instr.nmp"
	endif; 
#line 2198 "nmp/uisa_fp_instr.nmp"
; 
#line 2198 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_OE .. FP_OE> then fp_clear = fp_clear | "FPI_OVERFLOW"; endif; 
#line 2198 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_UE .. FP_UE> then fp_clear = fp_clear | "FPI_UNDERFLOW"; endif; 
#line 2198 "nmp/uisa_fp_instr.nmp"
	if FPSCR<FP_XE .. FP_XE> then fp_clear = fp_clear | "FPI_INEXACT"; endif;;
#line 2198 "nmp/uisa_fp_instr.nmp"
#line 2199 "nmp/uisa_fp_instr.nmp"
			// /HKC
		endif;
		}
// End of uisa_fp description
#line 1 "nmp/book_e.nmp"
/*
 * PPC2 - BOOK E -- Book E instructions
 * Copyright (C) 2011, TRACES - IRIT <casse@irit.fr>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
 
op book_e =
	  icbt
	| mbar
	| mfdcr
	| msync
	| mtdcr
	| tlbivax
	| tlbre
	| tlbsx
	| tlbsync
	| tlbwe
	| wrtee
	| wrteei

op icbt(CT: card(5), rA: REG_IND_ZERO, rB: index)
	syntax = format("icbt %d, %s, r%d", CT, rA, rB)
	image = format("011111 %5b %s %5b 0000 0101 10X", CT, rA, rB)
	action = { }	// not implemented

op mbar(MO: card(5))
	syntax = format("mbar %d", MO)
	image = format("011111 %5b XXXX XXXX XX 1101 0101 10X", MO)
	action = { }	// not implemented	

op mfdcr(rD: index, DCRN: card(10))
	syntax = format("mfdcr, r%d, %d", rD, DCRN)
	image = format("011111 %5b %5b %5b 0101000011X", rD, DCRN<4..0>, DCRN<9..5>)
	action = { }	// not implemented

op msync()
	syntax = "msync"
	image = "011111 XXXX XXXX XXXX XXX 1001 0101 10X"
	action = { }	// not implemented

op mtdcr(DCRN: card(10), rD: index)
	syntax = format("mtdcr %d, r%d", DCRN, rD)
	image = format("011111 %5b %5b %5b 0111000011X", rD, DCRN<4..0>, DCRN<9..5>)
	action = { }	// not implemented

op tlbivax(rA: REG_IND_ZERO, rB: index)
	syntax = format("tlbivax %s, r%d", rA, rB)
	image = format("011111 XXXXX %s %5b 1100 0100 10X", rA, rB)
	action = { }	// not implemented

op tlbre()
	syntax = "tlbre"
	image = "011111 XXXX XXXX XXXX XXX 1110 1100 10X"
	action = { }	// not implemented

op tlbsx(rA: index, rB: index)
	syntax = format("tlbsx r%d, r%d", rA, rB)
	image = format("011111 XXXXX %5b %5b 1110 0100 10X", rA, rB)
	action = { }	// not implemented

op tlbsync()
	syntax = "tlbsync"
	image = "011111 XXXX XXXX XXXX XXX 10001101 10X"
	action = { }	// not implemented

op tlbwe()
	syntax = "tlbwe"
	image = "011111 XXXX XXXX XXXX XXX 1111 0100 10X"
	action = { }	// not implemented

op wrtee(rS: index)
	syntax = format("wrtee r%d", rS)
	image = format("011111 %5b XXXX XXXX XX 0010 0000 11X", rS)
	action = { MSR<MSR_EE..MSR_EE> = GPR[rS]<15..15>; }

op wrteei(E: bit)
	syntax = format("wrtee %d", E)
	image = format("011111 XXXX XXXX XX %1b XXXX 0010 1000 11X", E)
	action = { MSR<MSR_EE..MSR_EE> = E; }
#line 1 "nmp/vle.nmp"

// common ressources

#line 11 "nmp/vle.nmp"

#line 16 "nmp/vle.nmp"

#line 18 "nmp/vle.nmp"

#line 23 "nmp/vle.nmp"

#line 25 "nmp/vle.nmp"

#line 33 "nmp/vle.nmp"

#line 36 "nmp/vle.nmp"


#line 52 "nmp/vle.nmp"

#line 54 "nmp/vle.nmp"
#line 55 "nmp/vle.nmp"
#line 56 "nmp/vle.nmp"
#line 57 "nmp/vle.nmp"
#line 58 "nmp/vle.nmp"

var IMM[1, word]
var ctr_ok[1, bit]
var cond_ok[1, bit]
var EA[1, card(32)]
var r[1, card(32)]
var m[1, card(32)]

mode vle_crb(i: index) = CR[(31-(i)) >> 2]<((31-(i)) & 0x3)..((31-(i)) & 0x3)>
	syntax = format("crb%d", i)
	image = format("%5b", i)
	index = (31-(i)) >> 2


// ===== VLE 16-bits ======

op vle16_list =
	  se_add
	| se_addi
	| se_and
	| se_andi
	| se_andc
	| se_b
	| se_bc
	| se_bclri
	| se_bctr
	| se_bgeni
	| se_blr
	| se_bmski
	| se_bseti
	| se_btsti
	| se_cmp
	| se_cmph
	| se_cmphl
	| se_cmpi
	| se_cmpl
	| se_cmpli
	| se_extsb
	| se_extsh
	| se_extzb
	| se_extzh
	| se_lbz
	| se_lhz
	| se_lwz
	| se_li
	| se_mfar
	| se_mfctr
	| se_mflr
	| se_mr
	| se_mtar
	| se_mtctr
	| se_mtlr
	| se_mullw
	| se_neg
	| se_not
	| se_or
	| se_rfci
	| se_rfdi
	| se_rfi
	| se_sc
	| se_slw
	| se_slwi
	| se_sraw
	| se_srawi
	| se_srw
	| se_srwi
	| se_stb
	| se_sth
	| se_stw
	| se_sub
	| se_subf
	| se_subi
	

#line 134 "nmp/vle.nmp"

mode vle_idx(idx: card(4)) = GPR[	if idx < 8 then idx else coerce(card(32), idx) + 16 endif]
#line 135 "nmp/vle.nmp"
#line 136 "nmp/vle.nmp"
	syntax = format("r%d", 	if idx < 8 then idx else coerce(card(32), idx) + 16 endif)
#line 136 "nmp/vle.nmp"
#line 137 "nmp/vle.nmp"
	image = format("%4b", idx)
	index = 	if idx < 8 then idx else coerce(card(32), idx) + 16 endif
#line 138 "nmp/vle.nmp"
#line 139 "nmp/vle.nmp"

mode vle_ar(idx: card(4)) = GPR[idx + 8]
	syntax = format("r%d", idx + 8)
	image = format("%4b", idx)
	index = idx + 8

op se_add(rX: vle_idx, rY: vle_idx)
	syntax = format("se_add %s,%s", rX, rY)
	image = format("000001 00 %s %s", rX, rY)
	action = { rX = rX + rY; }

op se_addi(OIM5: card(5), rX: vle_idx)
	syntax = format("se_addi %s, %d", rX, 	(OIM5) + 1)
#line 151 "nmp/vle.nmp"
#line 152 "nmp/vle.nmp"
	image = format("001000 0 %5b %s", OIM5, rX)
	action = { rX = rX + 	(OIM5) + 1; }
#line 153 "nmp/vle.nmp"
#line 154 "nmp/vle.nmp"

op se_and(Rc: bit, rX: vle_idx, rY: vle_idx)
	syntax = format("e_and%s %s, %s ", (if Rc == 0 then "" else "." endif), rX, rY)
#line 156 "nmp/vle.nmp"
#line 157 "nmp/vle.nmp"
	image = format("010001 1 %1b %s %s", Rc, rX, rY)
	action = {
		TMP_WORD = rX & rY;
		if Rc then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 160 "nmp/vle.nmp"
	else 
#line 160 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 160 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 160 "nmp/vle.nmp"
		endif; 
#line 160 "nmp/vle.nmp"
	endif; endif;
#line 160 "nmp/vle.nmp"
#line 161 "nmp/vle.nmp"
		rX = TMP_WORD;
	}

op se_andi(UI5: card(5), rX: vle_idx)
	syntax = format("se_andi %s, %d", rX.syntax, UI5)
	image = format("001011 1 %5b %s", UI5, rX.image)
	action = { rX = rX & UI5; }

op se_andc(rX: vle_idx, rY: vle_idx)
	syntax = format("se_andc %s, %s", rX.syntax, rY.syntax)
	image = format("010001 01 %s %s", rY.image, rX.image)
	action = { rX = rX + rY; }
 
op se_b(BD8: int(8), LK: bool)
	syntax = format("se_b%s %08x", (if LK == 0 then "" else "l" endif), __IADDR + (coerce(int(32), BD8) << 1))
#line 175 "nmp/vle.nmp"
#line 176 "nmp/vle.nmp"
	image = format("111010 0 %1b %8b", LK, BD8)
	action = {
		NIA = CIA + (coerce(int(32), BD8) << 1);
		if LK then LR = CIA + 2; endif;
	}

op se_bc(BO16: card(1), BI16: card(2), BD8: int(8))
	syntax = format("se_bc %x, %x, %08x", BO16, BO16, __IADDR + (coerce(int(32), BD8) << 1))
#line 183 "nmp/vle.nmp"
#line 184 "nmp/vle.nmp"
	image = format("11100 %1b %2b %8b", BO16, BI16, BD8)
	action = { if CR[0]<(3 - BI16) .. (3 - BI16)> == BO16 then NIA = CIA + (coerce(int(32), BD8) << 1); endif; }
#line 185 "nmp/vle.nmp"
#line 186 "nmp/vle.nmp"
	
op se_bclri(UI5: card(5), rX: vle_idx)
	syntax = format("bclri %s, %d", rX.syntax, UI5)
	image = format("011000 0 %5b %s", UI5, rX.image)
	action = { rX = rX & ~(1 << (31 - UI5)); }

op se_bctr(LK: bool)
	syntax = format("se_bctr%s", (if LK == 0 then "" else "l" endif))
#line 193 "nmp/vle.nmp"
#line 194 "nmp/vle.nmp"
	image = format("0000 0000 0000 011%1b", LK)
	action = {
		NIA = CTR << 1;
		if LK then LR = CIA + 2; endif;
	}

op se_bgeni(UI5: card(5), rX: vle_idx)
	syntax = format("bgeni %s, %d", rX.syntax, UI5)
	image = format("011000 1 %5b %s", UI5, rX.image)
	action = { rX = rX | (1 << (31 - UI5)); }

op se_blr(LK: bit)
	syntax = format("blr%s", (if LK == 0 then "" else "l" endif))
#line 206 "nmp/vle.nmp"
#line 207 "nmp/vle.nmp"
	image = format("0000 0000 0000 010%1b", LK)
	action = {
		NIA = LR & ~0x3;
		if LK then LR = CIA + 2; endif;
	}

op se_bmski(rX: vle_idx, UI5: card(5))
	syntax = format("se_bmski %s, %d", rX.syntax, UI5)
	image = format("001011 0 %5b %s", UI5, rX.image)
	action = { if UI5 == 0 then rX = 0xffffffff; else rX = (1 << UI5) - 1; endif; }

op se_bseti(rX: vle_idx, UI5: card(5))
	syntax = format("se_bseti %s, %d", rX.syntax, UI5)
	image = format("011001 0 %5b %s", UI5, rX.image)
	action = { rX = rX | (1 << (31 - UI5)); }

op se_btsti(rX: vle_idx, UI5: card(5))
	syntax = format("se_btsti %s, %d", rX, UI5)
	image = format("011001 1 %5b %s", UI5, rX)
	action = { if rX & (1 << (31 - UI5)) == 0 then CR[0] = 0b0010; else CR[0] = 0b0100; endif; }

op se_cmp(rX: vle_idx, rY: vle_idx)
	syntax = format("se_cmp %s, %s", rX, rY)
	image = format("000011 00 %s %s", rY, rX)
	action = { TMP_WORD = rX - rY; 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 231 "nmp/vle.nmp"
	else 
#line 231 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 231 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 231 "nmp/vle.nmp"
		endif; 
#line 231 "nmp/vle.nmp"
	endif; }
#line 231 "nmp/vle.nmp"
#line 232 "nmp/vle.nmp"
	
op se_cmpi(rX: vle_idx, UI5: card(5))
	syntax = format("se_cmpi %s, %d", rX, UI5)
	image = format("001010 1 %5b %s", UI5, rX)
	action = { TMP_WORD = rX - UI5; 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 236 "nmp/vle.nmp"
	else 
#line 236 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 236 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 236 "nmp/vle.nmp"
		endif; 
#line 236 "nmp/vle.nmp"
	endif; }
#line 236 "nmp/vle.nmp"
#line 237 "nmp/vle.nmp"

op se_cmph(rX: vle_idx, rY: vle_idx)
	syntax = format("se_cmph %s, %s", rX, rY)
	image = format("000011 10 %s %s", rY, rX)
	action = { TMP_WORD = coerce(int(32), rX<15..0>) - coerce(int(32), rY<15..0>); 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 241 "nmp/vle.nmp"
	else 
#line 241 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 241 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 241 "nmp/vle.nmp"
		endif; 
#line 241 "nmp/vle.nmp"
	endif; }
#line 241 "nmp/vle.nmp"
#line 242 "nmp/vle.nmp"

op se_cmphl(rX: vle_idx, rY: vle_idx)
	syntax = format("se_cmphl %s, %s", rX, rY)
	image = format("000011 11 %s %s", rY, rX)
	action = { TMP_WORD = coerce(card(32), rX<15..0>) - coerce(card(32), rY<15..0>); 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 246 "nmp/vle.nmp"
	else 
#line 246 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 246 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 246 "nmp/vle.nmp"
		endif; 
#line 246 "nmp/vle.nmp"
	endif; }
#line 246 "nmp/vle.nmp"
#line 247 "nmp/vle.nmp"

op se_cmpl(rX: vle_idx, rY: vle_idx)
	syntax = format("se_cmpl %s, %s", rX, rY)
	image = format("000011 01 %s %s", rY, rX)
	action = { 	if  coerce(card(32), rX) < coerce(card(32), rY) then CR[0]<LT..LT> = 1; 
#line 251 "nmp/vle.nmp"
	else if  coerce(card(32), rX) > coerce(card(32), rY) then CR[0]<GT..GT> = 1; 
#line 251 "nmp/vle.nmp"
	else CR[0]<EQ..EQ> = 1; endif; endif; }
#line 251 "nmp/vle.nmp"
#line 252 "nmp/vle.nmp"

op se_cmpli(rX: vle_idx, OIM5: card(5))
	syntax = format("se_cmpli %s, %d", rX, OIM5)
	image = format("001000 1 %5b %s", OIM5, rX)
	action = { 	if  coerce(card(32), rX) < OIM5 then CR[0]<LT..LT> = 1; 
#line 256 "nmp/vle.nmp"
	else if  coerce(card(32), rX) > OIM5 then CR[0]<GT..GT> = 1; 
#line 256 "nmp/vle.nmp"
	else CR[0]<EQ..EQ> = 1; endif; endif; }
#line 256 "nmp/vle.nmp"
#line 257 "nmp/vle.nmp"

op se_extsb(rX: vle_idx)
	syntax = format("se_extsb %s", rX.syntax)
	image = format("000000 001101 %s", rX.image)
	action = { if rX<7..7> then rX = rX | 0xffffff00; endif; }

op se_extsh(rX: vle_idx)
	syntax = format("se_extsh %s", rX.syntax)
	image = format("000000 001111 %s", rX.image)
	action = { if rX<15..15> then rX = rX | 0xffff0000; endif; }

op se_extzb(rX: vle_idx)
	syntax = format("se_extzb %s", rX.syntax)
	image = format("000000 001100 %s", rX.image)
	action = { rX = rX & 0xffffff00; }

op se_extzh(rX: vle_idx)
	syntax = format("se_extzh %s", rX.syntax)
	image = format("000000 001110 %s", rX.image)
	action = { rX = rX & 0xffff0000; }

op se_lbz(rZ: vle_idx, SD4: card(4), rX: vle_idx)
	syntax = format("se_lbz %s, %d(%s)", rZ.syntax, SD4, rX.syntax)
	image = format("1000 %4b %s %s", SD4, rZ.image, rX.image)
	action = { EA = rX + SD4; rZ = M[EA]; }
	  
op se_lhz(rZ: vle_idx, SD4: card(4), rX: vle_idx)
	syntax = format("se_lhz %s, %d(%s)", rZ.syntax, SD4, rX.syntax)
	image = format("1010 %4b %s %s", SD4, rZ.image, rX.image)
	action = { EA = rX + SD4; rZ = M16[EA]; }

op se_li(rX: vle_idx, UI7: card(7))
	syntax = format("se_li %s, %d", rX.syntax, UI7)
	image = format("01001 %7b %s", UI7, rX.image)
	action = { rX = UI7; }

op se_mfar(rX: vle_idx, rY: vle_ar)
	syntax = format("se_mfar %s, %s", rX.syntax, rY.syntax)
	image = format("000000 11 %s %s", rY.image, rX.image)
	action = { rX = rY; }

op se_lwz(rZ: vle_idx, SD4: card(4), rX: vle_idx)
	syntax = format("se_lwz %s, %d(%s)", rZ.syntax, SD4, rX.syntax)
	image = format("1100 %4b %s %s", SD4, rZ.image, rX.image)
	action = { EA = rX + SD4; rZ = M32[EA]; }

op se_mfctr(rX: vle_idx)
	syntax = format("se_mfctr %s", rX.syntax)
	image = format("000000 001010 %s", rX.image)
	action = { rX = CTR; }

op se_mflr(rX: vle_idx)
	syntax = format("se_mflr %s", rX.syntax)
	image = format("000000 001000 %s", rX.image)
	action = { rX = LR; }

op se_mr(rX: vle_idx, rY: vle_idx)
	syntax = format("se_mr %s, %s", rX.syntax, rY.syntax)
	image = format("000000 01 %s %s", rY.image, rX.image)
	action = { rX = rY; }

op se_mtar(rX: vle_ar, rY: vle_idx)
	syntax = format("se_mtar %s, %s", rX.syntax, rY.syntax)
	image = format("000000 10 %s %s", rY.image, rX.image)
	action = { rX = rY; }

op se_mtctr(rX: vle_idx)
	syntax = format("se_mtctr %s", rX.syntax)
	image = format("000000 001011 %s", rX.image)
	action = { CTR = rX; }

op se_mtlr(rX: vle_idx)
	syntax = format("se_mtlr %s", rX.syntax)
	image = format("000000 001001 %s", rX.image)
	action = { LR = rX; }

op se_mullw(rX: vle_idx, rY: vle_idx)
	syntax = format("se_mullw %s, %s", rX.syntax, rY.syntax)
	image = format("000001 01 %s %s", rY.image, rX.image)
	action = { rX = rX * rY; }

op se_neg(rX: vle_idx)
	syntax = format("se_neg %s", rX.syntax)
	image = format("000000 000011 %s", rX.image)
	action = { rX = -rX; }

op se_not(rX: vle_idx)
	syntax = format("se_not %s", rX.syntax)
	image = format("000000 000010 %s", rX.image)
	action = { rX = ~rX; }

op se_or(rX: vle_idx, rY: vle_idx)
	syntax = format("se_or %s, %s", rX.syntax, rY.syntax)
	image = format("010001 00 %s %s", rY.image, rX.image)
	action = { rX = rX | rY; }

op se_rfci()
	syntax = "se_rfci"
	image = "0000 0000 0000 1001"
	action = {  }		// not implemented

op se_rfdi()
	syntax = "se_rfdi"
	image = "0000 0000 0000 1010"
	action = {  }		// not implemented

op se_rfi()
	syntax = "se_rfi"
	image = "0000 0000 0000 1000"
	action = {  }		// not implemented

op se_sc()
	syntax = "se_sc"
	image = "0000 0000 0000 0010"
	action = { "sc_impl"("instr","state",M); }

op se_slw(rX: vle_idx, rY: vle_idx)
	syntax = format("se_slw %s, %s", rX, rY)
	image = format("010000 10 %s %s", rY, rX)
	action = { rX = rX << rY<4..0>; } 

op se_slwi(rX: vle_idx, UI5: card(5))
	syntax = format("se_slwi %s, %d", rX, UI5)
	image = format("011011 0 %5b %s", UI5, rX)
	action = { rX = rX << UI5; }

op se_sraw(rX: vle_idx, rY: vle_idx)
	syntax = format("se_sraw %s, %s", rX, rY)
	image = format("010000 01 %s %s", rY, rX)
	action = { rX = rX >> rY<4..0>; } 

op se_srawi(rX: vle_idx, UI5: card(5))
	syntax = format("se_srawi %s, %d", rX, UI5)
	image = format("011010 1 %5b %s", UI5, rX)
	action = { rX = rX >> UI5; }

op se_srw(rX: vle_idx, rY: vle_idx)
	syntax = format("se_srw %s, %s", rX, rY)
	image = format("010000 00 %s %s", rY, rX)
	action = { rX = coerce(card(32), rX) >> rY<4..0>; } 
#line 396 "nmp/vle.nmp"
#line 397 "nmp/vle.nmp"

op se_srwi(rX: vle_idx, UI5: card(5))
	syntax = format("se_srwi %s, %d", rX, UI5)
	image = format("011010 0 %5b %s", UI5, rX)
	action = { rX = coerce(card(32), rX) >> UI5; }
#line 401 "nmp/vle.nmp"
#line 402 "nmp/vle.nmp"


op se_stb(rZ: vle_idx, SD4: int(4), rX: vle_idx)
	syntax = format("se_stb %s, %d(%s)", rZ.syntax, SD4, rX.syntax)
	image = format("1001 %4b %s %s", SD4, rZ.image, rX.image)
	action = { EA = rX + SD4; M[EA] = rZ; }


op se_sth(rZ: vle_idx, SD4: int(4), rX: vle_idx)
	syntax = format("se_sth %s, %d(%s)", rZ.syntax, coerce(card(32), SD4) << 1, rX.syntax)
#line 411 "nmp/vle.nmp"
#line 412 "nmp/vle.nmp"
	image = format("1011 %4b %s %s", SD4, rZ.image, rX.image)
	action = { EA = rX + (coerce(card(32), SD4) << 1); M16[EA] = rZ; }
#line 413 "nmp/vle.nmp"
#line 414 "nmp/vle.nmp"


op se_stw(rZ: vle_idx, SD4: int(4), rX: vle_idx)
	syntax = format("se_stw %s, %d(%s)", rZ.syntax, coerce(card(32), SD4) << 2, rX.syntax)
#line 417 "nmp/vle.nmp"
#line 418 "nmp/vle.nmp"
	image = format("1101 %4b %s %s", SD4, rZ.image, rX.image)
	action = { EA = rX + (coerce(card(32), SD4) << 2); M32[EA] = rZ; }
#line 419 "nmp/vle.nmp"
#line 420 "nmp/vle.nmp"

op se_sub(rX: vle_idx, rY: vle_idx)
	syntax = format("se_sub %s, %s", rX.syntax, rY.syntax)
	image = format("000001 10 %s %s", rY.image, rX.image)
	action = { rX = rX - rY; }

op se_subf(rX: vle_idx, rY: vle_idx)
	syntax = format("se_subf %s, %s", rX.syntax, rY.syntax)
	image = format("000001 11 %s %s", rY.image, rX.image)
	action = { rX = rY - rX; }

op se_subi(rX: vle_idx, OIM5: card(5), Rc: bit)
	syntax = format("se_subi%s %s, %d", (if Rc == 0 then "" else "." endif), rX.syntax, 	(OIM5) + 1)
#line 432 "nmp/vle.nmp"
#line 433 "nmp/vle.nmp"
	image = format("001001 %1b %5b %s", Rc, OIM5, rX.image)
	action = {
		TMP_WORD = rX + 	(OIM5) + 1;
#line 435 "nmp/vle.nmp"
#line 436 "nmp/vle.nmp"
		if Rc then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 436 "nmp/vle.nmp"
	else 
#line 436 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 436 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 436 "nmp/vle.nmp"
		endif; 
#line 436 "nmp/vle.nmp"
	endif; endif;
#line 436 "nmp/vle.nmp"
#line 437 "nmp/vle.nmp"
		rX = TMP_WORD;
	}


// ====== VLE 32-bits ======

mode vle32_idx(idx: card(5)) = GPR[idx]
	syntax = format("r%d", idx)
	image = format("%5b", idx)
	index = idx

op vle32_list =
	  e_add16i
	| e_add2i_
	| e_add2is
	| e_addi
	| e_addic
	| e_and2i_
	| e_and2is_
	| e_andi
	| e_b
	| e_bc	
	| e_cmp16i
	| e_cmph
	| e_cmph16i
	| e_cmphl
	| e_cmphl16i
	| e_cmpi
	| e_cmpl16i
	| e_cmpli
	| e_crand 	
	| e_crandc 	
	| e_creqv 	
	| e_crnand 		
	| e_crnor 	
	| e_cror 	
	| e_crorc 	
	| e_crxor
	| e_lbz
	| e_lbzu
	| e_lha
	| e_lhau
	| e_lhz
	| e_lhzu
	| e_li
	| e_lis
	| e_lwz
	| e_lwzu
	| e_lmw
	| e_mcrf
	| e_mulli
	| e_mull2i
	| e_or2i
	| e_or2is
	| e_ori
	| e_rlw
	| e_rlwi
	| e_rlwimi
	| e_rlwinm
	| e_slwi
	| e_srwi
	| e_stb
	| e_stbu
	| e_sth
	| e_sthu
	| e_stw
	| e_stwu
	| e_stmw	
	| e_subfic
	| e_xori


op e_add16i(rD: vle32_idx, rA: vle32_idx, SI: int(16))
	syntax = format("e_add16i %s, %s, %d", rD.syntax, rA.syntax, SI)
	image = format("000111 %s %s %16b", rD.image, rA.image, SI)
	action = { rD = rA + SI; }

op e_add2i_(rA: vle32_idx, SI: int(16))
	syntax = format("e_add2i. %s, %d",  rA.syntax, SI)
	image = format("011100 %5b %s 10001 %11b", SI<15..11>, rA.image, SI<10..0>)
	action = { TMP_WORD = rA + SI; 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 517 "nmp/vle.nmp"
	else 
#line 517 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 517 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 517 "nmp/vle.nmp"
		endif; 
#line 517 "nmp/vle.nmp"
	endif; rA = TMP_WORD; } 
#line 517 "nmp/vle.nmp"
#line 518 "nmp/vle.nmp"
	
op e_add2is(rA: vle32_idx, SI: int(16))
	syntax = format("e_add2is %s, %d", rA.syntax, SI)
	image = format("011100 %5b %s 10010 %11b", SI<15..11>, rA.image, SI<10..0>)
	action = { rA = rA + (coerce(long, SI) << 16); }

op e_addi(rD: vle32_idx, rA: vle32_idx, Rc: bit, F: bit, SCL: card(2), UI8: card(8))
	syntax = format("e_addi%s %s, %s, %d", (if Rc == 0 then "" else "." endif), rD.syntax, rA.syntax, 	switch( SCL) { 
#line 525 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 525 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 525 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 525 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 525 "nmp/vle.nmp"
	})
#line 525 "nmp/vle.nmp"
#line 526 "nmp/vle.nmp"
	image = format("000110 %s %s 1000 %1b %1b %2b %8b", rD.image, rA.image, Rc, F, SCL, UI8)
	action = {
		TMP_WORD = rA + 	switch( SCL) { 
#line 528 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 528 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 528 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 528 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 528 "nmp/vle.nmp"
	};
#line 528 "nmp/vle.nmp"
#line 529 "nmp/vle.nmp"
		if Rc then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 529 "nmp/vle.nmp"
	else 
#line 529 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 529 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 529 "nmp/vle.nmp"
		endif; 
#line 529 "nmp/vle.nmp"
	endif; endif;
#line 529 "nmp/vle.nmp"
#line 530 "nmp/vle.nmp"
		rD = TMP_WORD;
	}

op e_addic(rD: vle32_idx, rA: vle32_idx, Rc: bit, F: bit, SCL: card(2), UI8: card(8))
	syntax = format("e_addic%s %s, %s, %d", (if Rc == 0 then "" else "." endif), rD.syntax, rA.syntax, 	switch( SCL) { 
#line 534 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 534 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 534 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 534 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 534 "nmp/vle.nmp"
	})
#line 534 "nmp/vle.nmp"
#line 535 "nmp/vle.nmp"
	image = format("000110 %s %s 1001 %1b %1b %2b %8b", rD.image, rA.image, Rc, F, SCL, UI8)
	action = {
		IMM = 	switch( SCL) { 
#line 537 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 537 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 537 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 537 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 537 "nmp/vle.nmp"
	};
#line 537 "nmp/vle.nmp"
#line 538 "nmp/vle.nmp"
		TMP_WORD = rA + IMM;
			if ( rA >= 0 && IMM >= 0) then 
#line 539 "nmp/vle.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 539 "nmp/vle.nmp"
	else 
#line 539 "nmp/vle.nmp"
		if ( rA < 0 && IMM < 0) then 
#line 539 "nmp/vle.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 539 "nmp/vle.nmp"
		else 
#line 539 "nmp/vle.nmp"
			if (TMP_WORD >= 0) then 
#line 539 "nmp/vle.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 539 "nmp/vle.nmp"
			else 
#line 539 "nmp/vle.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 539 "nmp/vle.nmp"
			endif; 
#line 539 "nmp/vle.nmp"
		endif; 
#line 539 "nmp/vle.nmp"
	endif;;
#line 539 "nmp/vle.nmp"
#line 540 "nmp/vle.nmp"
		if Rc then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 540 "nmp/vle.nmp"
	else 
#line 540 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 540 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 540 "nmp/vle.nmp"
		endif; 
#line 540 "nmp/vle.nmp"
	endif; endif;
#line 540 "nmp/vle.nmp"
#line 541 "nmp/vle.nmp"
		rD = TMP_WORD;
	}

op e_and2i_(rD: vle32_idx, UI: card(16))
	syntax = format("e_and2i. %s, %d", rD.syntax, UI)
	image = format("011100 %s %5b 11001 %11b", rD.image, UI<15..11>, UI<10..0>)
	action = {
		TMP_WORD = rD & (UI<11..0>);
			if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 549 "nmp/vle.nmp"
	else 
#line 549 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 549 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 549 "nmp/vle.nmp"
		endif; 
#line 549 "nmp/vle.nmp"
	endif;
#line 549 "nmp/vle.nmp"
#line 550 "nmp/vle.nmp"
		rD = TMP_WORD;
	}

op e_and2is_(rD: vle32_idx, UI: card(16))
	syntax = format("e_and2is. %s, %d", rD.syntax, UI)
	image = format("011100 %s %5b 11101 %11b", rD.image, UI<15..11>, UI<10..0>)
	action = {
		TMP_WORD = rD & (coerce(word, UI<11..0>) << 16);
			if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 558 "nmp/vle.nmp"
	else 
#line 558 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 558 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 558 "nmp/vle.nmp"
		endif; 
#line 558 "nmp/vle.nmp"
	endif;
#line 558 "nmp/vle.nmp"
#line 559 "nmp/vle.nmp"
		rD = TMP_WORD;
	}

op e_andi(rS: vle32_idx, rA: vle32_idx, Rc: bit, F: bit, SCL: card(2), UI8: card(8))
	syntax = format("e_addic%s %s, %s, %d", (if Rc == 0 then "" else "." endif), rS.syntax, rA.syntax, 	switch( SCL) { 
#line 563 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 563 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 563 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 563 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 563 "nmp/vle.nmp"
	})
#line 563 "nmp/vle.nmp"
#line 564 "nmp/vle.nmp"
	image = format("000110 %s %s 1100 %1b %1b %2b %8b", rS.image, rA.image, Rc, F, SCL, UI8)
	action = {
		IMM = 	switch( SCL) { 
#line 566 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 566 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 566 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 566 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 566 "nmp/vle.nmp"
	};
#line 566 "nmp/vle.nmp"
#line 567 "nmp/vle.nmp"
		TMP_WORD = rS + IMM;
		if Rc then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 568 "nmp/vle.nmp"
	else 
#line 568 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 568 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 568 "nmp/vle.nmp"
		endif; 
#line 568 "nmp/vle.nmp"
	endif; endif;
#line 568 "nmp/vle.nmp"
#line 569 "nmp/vle.nmp"
		rA = TMP_WORD;
	}

op e_b(BD24: int(24), LK: bool)
	syntax = format("e_b%s %08x", (if LK == 0 then "" else "l" endif), __IADDR + (coerce(int(32), BD24) << 1))
#line 573 "nmp/vle.nmp"
#line 574 "nmp/vle.nmp"
	image = format("011110 0 %24b %1b", BD24, LK)
	action = {
		NIA = CIA + (coerce(int(32), BD24) << 1);
		if LK == 1 then LR = CIA + 4; endif;
	}

op e_bc(BO32: card(2), BI32: card(4), BD15: int(15), LK: bool)
	syntax = format("e_bc%s %x, %x %08x", (if LK == 0 then "" else "l" endif), BO32, BI32, __IADDR + (coerce(int(32), BD15) << 1))
#line 581 "nmp/vle.nmp"
#line 582 "nmp/vle.nmp"
	image = format("011110 1000 %2b %4b %15b %1b", BO32, BI32, BD15, LK)
	action = {
		if BO32<1..1> then CTR = CTR - 1; endif;
		ctr_ok = !BO32<1..1> | ((CTR != 0) ^ BO32<0..0>);
		cond_ok = BO32<1..1> | (CR[(31 - BI32) >> 2]<((31 - BI32) & 0x3)..((31 - BI32) & 0x3)> == BO32<0..0>);
#line 586 "nmp/vle.nmp"
#line 587 "nmp/vle.nmp"
		if ctr_ok && cond_ok then NIA = CIA + (coerce(int(32), BD15) << 1); endif;
#line 587 "nmp/vle.nmp"
#line 588 "nmp/vle.nmp"
		if LK == 1 then LR = CIA + 4; endif;
	}

op e_cmp16i(rA: vle32_idx, SI: int(16))
	syntax = format("e_cmp16i %s, %d", rA, SI)
	image = format("011100 %5b %s 10011 %11b", SI<15..11>, rA, SI<10..0>)
	action = { 	if  rA < SI then CR[0]<LT..LT> = 1; 
#line 594 "nmp/vle.nmp"
	else if  rA > SI then CR[0]<GT..GT> = 1; 
#line 594 "nmp/vle.nmp"
	else CR[0]<EQ..EQ> = 1; endif; endif; }
#line 594 "nmp/vle.nmp"
#line 595 "nmp/vle.nmp"

op e_cmph16i(rA: vle32_idx, SI: int(16))
	syntax = format("e_cmph16i %s, %d", rA, SI)
	image = format("011100 %5b %s 10110 %11b", SI<15..11>, rA, SI<10..0>)
	action = { 	if  coerce(int(32), rA<15..0>) < coerce(int(32), SI) then CR[0]<LT..LT> = 1; 
#line 599 "nmp/vle.nmp"
	else if  coerce(int(32), rA<15..0>) > coerce(int(32), SI) then CR[0]<GT..GT> = 1; 
#line 599 "nmp/vle.nmp"
	else CR[0]<EQ..EQ> = 1; endif; endif; }
#line 599 "nmp/vle.nmp"
#line 600 "nmp/vle.nmp"

op e_cmph(crD: card(3), rA: vle32_idx, rB: vle32_idx)
	syntax = format("e_cmph cr%d, %s, %s", crD, rA, rB)
	image = format("011111 %3b XX %s %s 0000 0011 10X", crD, rA, rB)
	action = { 	if  coerce(int(32), rA<15..0>) < coerce(int(32), rB<15..0>) then CR[crD]<LT..LT> = 1; 
#line 604 "nmp/vle.nmp"
	else if  coerce(int(32), rA<15..0>) > coerce(int(32), rB<15..0>) then CR[crD]<GT..GT> = 1; 
#line 604 "nmp/vle.nmp"
	else CR[crD]<EQ..EQ> = 1; endif; endif; }
#line 604 "nmp/vle.nmp"
#line 605 "nmp/vle.nmp"

op e_cmphl(crD: card(3), rA: vle32_idx, rB: vle32_idx)
	syntax = format("e_cmphl cr%d, %s, %s", crD, rA, rB)
	image = format("011111 %3b XX %s %s 0000 1011 10X", crD, rA, rB)
	action = { 	if  coerce(card(32), rA<15..0>) < coerce(card(32), rB<15..0>) then CR[crD]<LT..LT> = 1; 
#line 609 "nmp/vle.nmp"
	else if  coerce(card(32), rA<15..0>) > coerce(card(32), rB<15..0>) then CR[crD]<GT..GT> = 1; 
#line 609 "nmp/vle.nmp"
	else CR[crD]<EQ..EQ> = 1; endif; endif; }
#line 609 "nmp/vle.nmp"
#line 610 "nmp/vle.nmp"

op e_cmphl16i(rA: vle32_idx, UI: card(16))
	syntax = format("e_cmphl16i %s, %d", rA, UI)
	image = format("011100 %5b %s 10111 %11b", UI<15..11>, rA, UI<10..0>)
	action = { 	if  coerce(card(32), rA<15..0>) < UI then CR[0]<LT..LT> = 1; 
#line 614 "nmp/vle.nmp"
	else if  coerce(card(32), rA<15..0>) > UI then CR[0]<GT..GT> = 1; 
#line 614 "nmp/vle.nmp"
	else CR[0]<EQ..EQ> = 1; endif; endif; }
#line 614 "nmp/vle.nmp"
#line 615 "nmp/vle.nmp"

op e_cmpi(crD32: card(2), rA: vle32_idx, F: bit, SCL: card(2), UI8: card(8))
	syntax = format("e_cmpi cr%d, %s, %d", crD32, rA, 	switch( SCL) { 
#line 617 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 617 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 617 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 617 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 617 "nmp/vle.nmp"
	})
#line 617 "nmp/vle.nmp"
#line 618 "nmp/vle.nmp"
	image = format("000110 000 %2b %s 10101 %1b %2b %8b", crD32, rA, F, SCL, UI8)
	action = { 	if  rA < 	switch( SCL) { 
#line 619 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 619 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 619 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 619 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 619 "nmp/vle.nmp"
	} then CR[crD32]<LT..LT> = 1; 
#line 619 "nmp/vle.nmp"
	else if  rA > 	switch( SCL) { 
#line 619 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 619 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 619 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 619 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 619 "nmp/vle.nmp"
	} then CR[crD32]<GT..GT> = 1; 
#line 619 "nmp/vle.nmp"
	else CR[crD32]<EQ..EQ> = 1; endif; endif; }
#line 619 "nmp/vle.nmp"
#line 620 "nmp/vle.nmp"

op e_cmpl16i(rA: vle32_idx, UI: card(16))
	syntax = format("e_cmpl16i %s, %d", rA, UI)
	image = format("011100 %5b %s 10101 %11b", UI<15..11>, rA, UI<10..0>)
	action = { 	if  coerce(card(32), rA) < UI then CR[0]<LT..LT> = 1; 
#line 624 "nmp/vle.nmp"
	else if  coerce(card(32), rA) > UI then CR[0]<GT..GT> = 1; 
#line 624 "nmp/vle.nmp"
	else CR[0]<EQ..EQ> = 1; endif; endif; } 
#line 624 "nmp/vle.nmp"
#line 625 "nmp/vle.nmp"

op e_cmpli(crD32: card(2), rA: vle32_idx, F: bit, SCL: card(2), UI8: card(8))
	syntax = format("e_cmpli cr%d, %s, %d", crD32, rA, 	switch( SCL) { 
#line 627 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 627 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 627 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 627 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 627 "nmp/vle.nmp"
	})
#line 627 "nmp/vle.nmp"
#line 628 "nmp/vle.nmp"
	image = format("000110 001 %2b %s 10101 %1b %2b %8b", crD32, rA, F, SCL, UI8)
	action = { 	if  coerce(card(32), rA) < 	switch( SCL) { 
#line 629 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 629 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 629 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 629 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 629 "nmp/vle.nmp"
	} then CR[crD32]<LT..LT> = 1; 
#line 629 "nmp/vle.nmp"
	else if  coerce(card(32), rA) > 	switch( SCL) { 
#line 629 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 629 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 629 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 629 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 629 "nmp/vle.nmp"
	} then CR[crD32]<GT..GT> = 1; 
#line 629 "nmp/vle.nmp"
	else CR[crD32]<EQ..EQ> = 1; endif; endif; }
#line 629 "nmp/vle.nmp"
#line 630 "nmp/vle.nmp"

op e_crand(crbD: vle_crb, crbA: vle_crb, crbB: vle_crb)
	syntax = format("e_crand %s, %s, %s", crbD.syntax, crbA.syntax, crbB.syntax)
	image = format("011111 %s %s %s 0100 0000 01X", crbD.image, crbA.image, crbB.image)
	action = { crbD = crbA & crbB; } 

op e_crandc(crbD: vle_crb, crbA: vle_crb, crbB: vle_crb)
	syntax = format("e_crandc %s, %s, %s", crbD.syntax, crbA.syntax, crbB.syntax)
	image = format("011111 %s %s %s 0010 0000 01X", crbD.image, crbA.image, crbB.image)
	action = { crbD = crbA & ~crbB; } 

op e_creqv(crbD: vle_crb, crbA: vle_crb, crbB: vle_crb)
	syntax = format("e_creqv %s, %s, %s", crbD.syntax, crbA.syntax, crbB.syntax)
	image = format("011111 %s %s %s 0100 1000 01X", crbD.image, crbA.image, crbB.image)
	action = { crbD = crbA == crbB; } 

op e_crnand(crbD: vle_crb, crbA: vle_crb, crbB: vle_crb)
	syntax = format("e_crnand %s, %s, %s", crbD.syntax, crbA.syntax, crbB.syntax)
	image = format("011111 %s %s %s 0011 1000 01X", crbD.image, crbA.image, crbB.image)
	action = { crbD = ~(crbA & crbB); } 

op e_crnor(crbD: vle_crb, crbA: vle_crb, crbB: vle_crb)
	syntax = format("e_crnor %s, %s, %s", crbD.syntax, crbA.syntax, crbB.syntax)
	image = format("011111 %s %s %s 0000 1000 01X", crbD.image, crbA.image, crbB.image)
	action = { crbD = ~(crbA | crbB); } 

op e_cror(crbD: vle_crb, crbA: vle_crb, crbB: vle_crb)
	syntax = format("e_cror %s, %s, %s", crbD.syntax, crbA.syntax, crbB.syntax)
	image = format("011111 %s %s %s 0111 0000 01X", crbD.image, crbA.image, crbB.image)
	action = { crbD = crbA | crbB; } 

op e_crorc(crbD: vle_crb, crbA: vle_crb, crbB: vle_crb)
	syntax = format("e_crorc %s, %s, %s", crbD.syntax, crbA.syntax, crbB.syntax)
	image = format("011111 %s %s %s 0110 1000 01X", crbD.image, crbA.image, crbB.image)
	action = { crbD = crbA | ~crbB; } 

op e_crxor(crbD: vle_crb, crbA: vle_crb, crbB: vle_crb)
	syntax = format("e_crxor %s, %s, %s", crbD.syntax, crbA.syntax, crbB.syntax)
	image = format("011111 %s %s %s 0011 0000 01X", crbD.image, crbA.image, crbB.image)
	action = { crbD = crbA ^ ~crbB; } 

op e_mcrf(crD: card(3), crS: card(3))
	syntax = format("e_mcrf cr%d, cr%d", crD, crS)
	image = format("011111 %3b XX %3b XXXX XXX 0000 0100 00X", crD, crS)
	action = { CR[crD] = CR[crS]; } 

op e_lbz(rD: index, D: int(16), rA: REG_IND_ZERO)
	syntax = format("e_lbz r%d, %d(%s)", rD, D, rA.syntax)
	image = format("001100 %5b %s %16b", rD, rA.image, D)
	action = { EA = rA + coerce(int(32), D); GPR[rD] = M[EA]; }
#line 679 "nmp/vle.nmp"
#line 680 "nmp/vle.nmp"

op e_lbzu(rD: index, D: int(8), rA: REG_IND_ZERO)
	syntax = format("e_lbzu r%d, %d(%s)", rD, D, rA.syntax)
	image = format("000110 %5b %s 0000 0000 %8b", rD, rA.image, D)
	action = { EA = rA + coerce(int(32), D); GPR[rD] = M[EA]; GPR[rA.value] = EA;  }
#line 684 "nmp/vle.nmp"
#line 685 "nmp/vle.nmp"

op e_lha(rD: index, D: int(16), rA: REG_IND_ZERO)
	syntax = format("e_lha r%d, %d(%s)", rD, D, rA.syntax)
	image = format("001110 %5b %s %16b", rD, rA.image, D)
	action = { EA = rA + coerce(int(32), D); GPR[rD] = coerce(int(32), M16[EA]);  }
#line 689 "nmp/vle.nmp"
#line 690 "nmp/vle.nmp"

op e_lhau(rD: index, D: int(8), rA: REG_IND_ZERO)
	syntax = format("e_lhau r%d, %d(%s)", rD, D, rA.syntax)
	image = format("000110 %5b %s 0000 0011 %8b", rD, rA.image, D)
	action = { EA = rA + coerce(int(32), D); GPR[rD] = coerce(int(32), M16[EA]); GPR[rA.value] = EA;  }
#line 694 "nmp/vle.nmp"
#line 695 "nmp/vle.nmp"

op e_lhz(rD: index, D: int(16), rA: REG_IND_ZERO)
	syntax = format("e_lhz r%d, %d(%s)", rD, D, rA.syntax)
	image = format("010110 %5b %s %16b", rD, rA.image, D)
	action = { EA = rA + coerce(int(32), D); GPR[rD] = M16[EA]; }
#line 699 "nmp/vle.nmp"
#line 700 "nmp/vle.nmp"

op e_lhzu(rD: index, D: int(8), rA: REG_IND_ZERO)
	syntax = format("e_lhzu r%d, %d(%s)", rD, D, rA.syntax)
	image = format("000110 %5b %s 0000 0001 %8b", rD, rA.image, D)
	action = { EA = rA + coerce(int(32), D); GPR[rD] = M16[EA]; GPR[rA.value] = EA;  }
#line 704 "nmp/vle.nmp"
#line 705 "nmp/vle.nmp"

op e_li(rD: vle32_idx, LI20: int(20))
	syntax = format("e_li %s, %x", rD, LI20)
	image = format("011100 %s %5b 0 %4b %11b", rD, LI20<15..11>, LI20<19..16>, LI20<10..0>)
	action = { rD = coerce(int(32), LI20); }
#line 709 "nmp/vle.nmp"
#line 710 "nmp/vle.nmp"

op e_lis(rD: vle32_idx, UI: card(16))
	syntax = format("e_lis %s, %x", rD, UI)
	image = format("011100 %s %5b 11100 %11b", rD, UI<15..11>, UI<10..0>)
	action = { rD = coerce(card(32), UI) << 16; }
#line 714 "nmp/vle.nmp"
#line 715 "nmp/vle.nmp"

op e_lwz(rD: index, D: int(16), rA: REG_IND_ZERO)
	syntax = format("e_lwz r%d, %d(%s)", rD, D, rA.syntax)
	image = format("010100 %5b %s %16b", rD, rA.image, D)
	action = { EA = rA + coerce(int(32), D); GPR[rD] = M32[EA]; }
#line 719 "nmp/vle.nmp"
#line 720 "nmp/vle.nmp"

op e_lwzu(rD: index, D: int(8), rA: REG_IND_ZERO)
	syntax = format("e_lwzu r%d, %d(%s)", rD, D, rA.syntax)
	image = format("000110 %5b %s 0000 0010 %8b", rD, rA.image, D)
	action = { EA = rA + coerce(int(32), D); GPR[rD] = M32[EA]; GPR[rA.value] = EA;  }
#line 724 "nmp/vle.nmp"
#line 725 "nmp/vle.nmp"

op e_lmw(rD: index, D8: int(8), rA: REG_IND_ZERO)
	syntax = format("e_lmw r%d, %d(%s)", rD, D8, rA.syntax)
	image = format("000110 %5b %s 0000 1000 %8b", rD, rA.image, D8)
	action = { EA = rA + coerce(int(32), D8); r = rD; rec; }
#line 729 "nmp/vle.nmp"
#line 730 "nmp/vle.nmp"
	rec = { if r <= 31 then GPR[r] = M32[EA]; r = r + 1; EA = EA + 4; rec; endif; }

op e_mulli(rD: vle32_idx, rA: vle32_idx, F: bit, SCL: card(2), UI8: card(8))
	syntax = format("e_mulli %s, %s, %d", rD, rA, 	switch( SCL) { 
#line 733 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 733 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 733 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 733 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 733 "nmp/vle.nmp"
	})
#line 733 "nmp/vle.nmp"
#line 734 "nmp/vle.nmp"
	image = format("000110 %s %s 10100 %1b %2b %8b", rD, rA, F, SCL, UI8)
	action = { rD = rA * 	switch( SCL) { 
#line 735 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 735 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 735 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 735 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 735 "nmp/vle.nmp"
	}; }
#line 735 "nmp/vle.nmp"
#line 736 "nmp/vle.nmp"

op e_mull2i(rA: vle32_idx, SI: int(16))
	syntax = format("e_mull2i %s, %d", rA, SI)
	image = format("011100 %5b %s 10100 %11b", SI<15..11>, rA, SI<10..0>)
	action = { rA = rA * coerce(int(32), SI); }
#line 740 "nmp/vle.nmp"
#line 741 "nmp/vle.nmp"

op e_or2i(rD: vle32_idx, UI: card(16))
	syntax = format("e_or2i %s, %x", rD, UI)
	image = format("011100 %s %5b 11000 %11b", rD, UI<15..11>, UI<10..0>)
	action = { rD = rD | UI; }

op e_or2is(rD: vle32_idx, UI: card(16))
	syntax = format("e_or2is %s, %x", rD, UI)
	image = format("011100 %s %5b 11010 %11b", rD, UI<15..11>, UI<10..0>)
	action = { rD = rD | (coerce(card(32), UI) << 16); }
#line 750 "nmp/vle.nmp"
#line 751 "nmp/vle.nmp"

op e_ori(rA: vle32_idx, rS: vle32_idx, F: bit, SCL: card(2), UI8: card(8), Rc: bit)
	syntax = format("e_ori%s %s, %s, %x", (if Rc == 0 then "" else "." endif), rA, rS, 	switch( SCL) { 
#line 753 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 753 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 753 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 753 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 753 "nmp/vle.nmp"
	})
#line 753 "nmp/vle.nmp"
#line 754 "nmp/vle.nmp"
	image = format("000110 %s %s 1101 %1b %1b %2b %8b", rS, rA, Rc, F, SCL, UI8)
	action = {
		TMP_WORD = rS | 	switch( SCL) { 
#line 756 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 756 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 756 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 756 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 756 "nmp/vle.nmp"
	};
#line 756 "nmp/vle.nmp"
#line 757 "nmp/vle.nmp"
		if Rc == 1 then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 757 "nmp/vle.nmp"
	else 
#line 757 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 757 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 757 "nmp/vle.nmp"
		endif; 
#line 757 "nmp/vle.nmp"
	endif; endif;
#line 757 "nmp/vle.nmp"
#line 758 "nmp/vle.nmp"
		rA = TMP_WORD; 
	}

op e_rlw(rA: vle32_idx, rS: vle32_idx, rB: vle32_idx, Rc: bit)
	syntax = format("e_rlw%s %s, %s, %s", (if Rc == 0 then "" else "." endif), rA, rS, rB)
#line 762 "nmp/vle.nmp"
#line 763 "nmp/vle.nmp"
	image = format("011111 %s %s %s 0100 0110 00 %1b", rS, rA, rB, Rc)
	action = {
		TMP_WORD = rS <<< rB<4..0>;
		if Rc == 1 then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 766 "nmp/vle.nmp"
	else 
#line 766 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 766 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 766 "nmp/vle.nmp"
		endif; 
#line 766 "nmp/vle.nmp"
	endif; endif;
#line 766 "nmp/vle.nmp"
#line 767 "nmp/vle.nmp"
		rA = TMP_WORD;
	}

op e_rlwi(rA: vle32_idx, rS: vle32_idx, SH: card(5), Rc: bit)
	syntax = format("e_rlwi%s %s, %s, %d", (if Rc == 0 then "" else "." endif), rA, rS, SH)
#line 771 "nmp/vle.nmp"
#line 772 "nmp/vle.nmp"
	image = format("011111 %s %s %5b 0100 1110 00 %1b", rS, rA, SH, Rc)
	action = {
		TMP_WORD = rS <<< SH;
		if Rc == 1 then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 775 "nmp/vle.nmp"
	else 
#line 775 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 775 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 775 "nmp/vle.nmp"
		endif; 
#line 775 "nmp/vle.nmp"
	endif; endif;
#line 775 "nmp/vle.nmp"
#line 776 "nmp/vle.nmp"
		rA = TMP_WORD;
	}

op e_rlwimi(rA: vle32_idx, rS: vle32_idx, SH: card(5), MB: card(5), ME: card(5))
	syntax = format("e_rlwimi %s, %s, %d, %d, %d", rA, rS, SH, MB, ME)
	image = format("011101 %s %s %5b %5b %5b 0", rS, rA, SH, MB, ME)
	action = {
		m = ((1 << (ME - MB + 1)) - 1) << (31 - ME);
		rA = ((rS <<< SH) & m) | (rA & ~m);
	}

op e_rlwinm(rA: vle32_idx, rS: vle32_idx, SH: card(5), MB: card(5), ME: card(5))
	syntax = format("e_rlwinm %s, %s, %d, %d, %d", rA, rS, SH, MB, ME)
	image = format("011101 %s %s %5b %5b %5b 1", rS, rA, SH, MB, ME)
	action = {
		m = ((1 << (ME - MB + 1)) - 1) << (31 - ME);
		rA = (rS <<< SH) & m;
	}

op e_slwi(rA: vle32_idx, rS: vle32_idx, SH: card(5), Rc: bit)
	syntax = format("e_slwi%s %s, %s, %d", (if Rc == 0 then "" else "." endif), rA, rS, SH)
#line 796 "nmp/vle.nmp"
#line 797 "nmp/vle.nmp"
	image = format("011111 %s %s %5b 0000 1110 00 %1b", rS, rA, SH, Rc)
	action = {
		TMP_WORD = rS << SH;
		if Rc == 1 then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 800 "nmp/vle.nmp"
	else 
#line 800 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 800 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 800 "nmp/vle.nmp"
		endif; 
#line 800 "nmp/vle.nmp"
	endif; endif;
#line 800 "nmp/vle.nmp"
#line 801 "nmp/vle.nmp"
		rA = TMP_WORD;
	}

op e_srwi(rA: vle32_idx, rS: vle32_idx, SH: card(5), Rc: bit)
	syntax = format("e_srwi%s %s, %s, %d", (if Rc == 0 then "" else "." endif), rA, rS, SH)
#line 805 "nmp/vle.nmp"
#line 806 "nmp/vle.nmp"
	image = format("011111 %s %s %5b 1000 1110 00 %1b", rS, rA, SH, Rc)
	action = {
		TMP_WORD = rS >> SH;
		if Rc == 1 then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 809 "nmp/vle.nmp"
	else 
#line 809 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 809 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 809 "nmp/vle.nmp"
		endif; 
#line 809 "nmp/vle.nmp"
	endif; endif;
#line 809 "nmp/vle.nmp"
#line 810 "nmp/vle.nmp"
		rA = TMP_WORD;
	}

op e_stb(rS: index, D: int(16), rA: REG_IND_ZERO)
	syntax = format("e_stb r%d, %d(%s)", rS, D, rA.syntax)
	image = format("001101 %5b %s %16b", rS, rA.image, D)
	action = { EA = rA + coerce(int(32), D); M[EA] = GPR[rS]; }
#line 816 "nmp/vle.nmp"
#line 817 "nmp/vle.nmp"

op e_stbu(rS: index, D8: int(8), rA: REG_IND_ZERO)
	syntax = format("e_stbu r%d, %d(%s)", rS, D8, rA.syntax)
	image = format("000110 %5b %s 0000 0100 %8b", rS, rA.image, D8)
	action = { EA = rA + coerce(int(32), D8); M[EA] = GPR[rS]; if rA.value != 0 then GPR[rA.value] = EA; endif; }
#line 821 "nmp/vle.nmp"
#line 822 "nmp/vle.nmp"

op e_sth(rS: index, D: int(16), rA: REG_IND_ZERO)
	syntax = format("e_sth r%d, %d(%s)", rS, D, rA.syntax)
	image = format("010111 %5b %s %16b", rS, rA.image, D)
	action = { EA = rA + coerce(int(32), D); M16[EA] = GPR[rS]; }
#line 826 "nmp/vle.nmp"
#line 827 "nmp/vle.nmp"

op e_sthu(rS: index, D8: int(8), rA: REG_IND_ZERO)
	syntax = format("e_sthu r%d, %d(%s)", rS, D8, rA.syntax)
	image = format("000110 %5b %s 0000 0101 %8b", rS, rA.image, D8)
	action = { EA = rA + coerce(int(32), D8); M16[EA] = GPR[rS]; if rA.value != 0 then GPR[rA.value] = EA; endif; }
#line 831 "nmp/vle.nmp"
#line 832 "nmp/vle.nmp"

op e_stw(rS: index, D: int(16), rA: REG_IND_ZERO)
	syntax = format("e_stw r%d, %d(%s)", rS, D, rA.syntax)
	image = format("010101 %5b %s %16b", rS, rA.image, D)
	action = { EA = rA + coerce(int(32), D); M32[EA] = GPR[rS]; }
#line 836 "nmp/vle.nmp"
#line 837 "nmp/vle.nmp"

op e_stwu(rS: index, D8: int(8), rA: REG_IND_ZERO)
	syntax = format("e_stwu r%d, %d(%s)", rS, D8, rA.syntax)
	image = format("000110 %5b %s 0000 0110 %8b", rS, rA.image, D8)
	action = { EA = rA + coerce(int(32), D8); M32[EA] = GPR[rS]; if rA.value != 0 then GPR[rA.value] = EA; endif; }
#line 841 "nmp/vle.nmp"
#line 842 "nmp/vle.nmp"

op e_stmw(rS: index, D8: int(8), rA: REG_IND_ZERO)
	syntax = format("e_stmw r%d, %d(%s)", rS, D8, rA.syntax)
	image = format("000110 %5b %s 0000 1001 %8b", rS, rA.image, D8)
	action = { EA = rA + coerce(int(32), D8); r = rS; rec; }
#line 846 "nmp/vle.nmp"
#line 847 "nmp/vle.nmp"
	rec = { if r <= 31 then M32[EA] = GPR[r]; r = r + 1; EA = EA + 4; rec; endif; }

op e_subfic(rD: vle32_idx, rA: vle32_idx, F: bit, SCL: card(2), UI8: card(8), Rc: bit)
	syntax = format("e_subfic%s %s, %s, %d", (if Rc == 0 then "" else "." endif),rD, rA, 	switch( SCL) { 
#line 850 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 850 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 850 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 850 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 850 "nmp/vle.nmp"
	})
#line 850 "nmp/vle.nmp"
#line 851 "nmp/vle.nmp"
	image = format("000110 %s %s 1011 %1b %1b %2b %8b", rD, rA, Rc, F, SCL, UI8)
	action = {
		IMM = -	switch( SCL) { 
#line 853 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 853 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 853 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 853 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 853 "nmp/vle.nmp"
	};
#line 853 "nmp/vle.nmp"
#line 854 "nmp/vle.nmp"
		TMP_WORD = rA + IMM;
		if Rc == 1 then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 855 "nmp/vle.nmp"
	else 
#line 855 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 855 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 855 "nmp/vle.nmp"
		endif; 
#line 855 "nmp/vle.nmp"
	endif; endif;
#line 855 "nmp/vle.nmp"
#line 856 "nmp/vle.nmp"
		rD = TMP_WORD;
			if ( rA >= 0 && IMM >= 0) then 
#line 857 "nmp/vle.nmp"
		XER <CA_XER..CA_XER> = 0; 
#line 857 "nmp/vle.nmp"
	else 
#line 857 "nmp/vle.nmp"
		if ( rA < 0 && IMM < 0) then 
#line 857 "nmp/vle.nmp"
			XER <CA_XER..CA_XER> = 1; 
#line 857 "nmp/vle.nmp"
		else 
#line 857 "nmp/vle.nmp"
			if (TMP_WORD >= 0) then 
#line 857 "nmp/vle.nmp"
				XER <CA_XER..CA_XER> = 1; 
#line 857 "nmp/vle.nmp"
			else 
#line 857 "nmp/vle.nmp"
				XER <CA_XER..CA_XER> = 0; 
#line 857 "nmp/vle.nmp"
			endif; 
#line 857 "nmp/vle.nmp"
		endif; 
#line 857 "nmp/vle.nmp"
	endif;;
#line 857 "nmp/vle.nmp"
#line 858 "nmp/vle.nmp"
	}

op e_xori(rA: vle32_idx, rS: vle32_idx, F: bit, SCL: card(2), UI8: card(8), Rc: bit)
	syntax = format("e_xori%s %s, %s, %x", (if Rc == 0 then "" else "." endif), rA, rS, 	switch( SCL) { 
#line 861 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 861 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 861 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 861 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 861 "nmp/vle.nmp"
	})
#line 861 "nmp/vle.nmp"
#line 862 "nmp/vle.nmp"
	image = format("000110 %s %s 1110 %1b %1b %2b %8b", rS, rA, Rc, F, SCL, UI8)
	action = {
		TMP_WORD = rS ^ 	switch( SCL) { 
#line 864 "nmp/vle.nmp"
	case 0:		(if F != 0 then 0xffffff00 else 0 endif) | UI8 
#line 864 "nmp/vle.nmp"
	case 1:		(if F != 0 then 0xffff00ff else 0 endif) | (UI8 << 8) 
#line 864 "nmp/vle.nmp"
	case 2:		(if F != 0 then 0xff00ffff else 0 endif) | (UI8 << 16) 
#line 864 "nmp/vle.nmp"
	default:	(if F != 0 then 0x00ffffff else 0 endif) | (UI8 << 24) 
#line 864 "nmp/vle.nmp"
	};
#line 864 "nmp/vle.nmp"
#line 865 "nmp/vle.nmp"
		if Rc then 	if TMP_WORD < 0 then CR[0]<LT..LT> = 1; 
#line 865 "nmp/vle.nmp"
	else 
#line 865 "nmp/vle.nmp"
		if TMP_WORD == 0 then CR[0]<EQ..EQ> = 1; 
#line 865 "nmp/vle.nmp"
		else CR[0]<GT..GT> = 1; 
#line 865 "nmp/vle.nmp"
		endif; 
#line 865 "nmp/vle.nmp"
	endif; endif;
#line 865 "nmp/vle.nmp"
#line 866 "nmp/vle.nmp"
		rA = TMP_WORD;
	}
	




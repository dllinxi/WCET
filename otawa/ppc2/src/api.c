/* Generated by gep (117/07/07 15:08:27) copyright (c) 2008 IRIT - UPS */

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <ppc/api.h>
#include "platform.h"
#include <ppc/env.h>
#include <ppc/macros.h>
#include <ppc/config.h>


static char *ppc_string_ident[] = {
	"PPC_UNKNOWN",
	"PPC_WRTEE_D",
	"PPC_WRTEE_RD",
	"PPC_TLBWE",
	"PPC_TLBSYNC",
	"PPC_TLBSX_RD__RD",
	"PPC_TLBRE",
	"PPC_TLBIVAX_RD__RD",
	"PPC_MSYNC",
	"PPC_MTDCR_D__RD",
	"PPC_MFDCR__RD__D",
	"PPC_MBAR_D",
	"PPC_ICBT_D__RD__RD",
	"PPC_XOR__RD_RD_RD",
	"PPC_XOR_RD_RD_RD",
	"PPC_ICBI_RD_RD",
	"PPC_DCBZ_RD_RD",
	"PPC_DCBTST_RD_RD",
	"PPC_DCBT_RD_RD",
	"PPC_DCBST_RD_RD",
	"PPC_DCBI_RD__RD",
	"PPC_DCBF_RD__RD",
	"PPC_DCBA_RD_RD",
	"PPC_TW_D_RD_RD",
	"PPC_MFCR_RD",
	"PPC_SUBFZEO__RD_RD",
	"PPC_SUBFZEO_RD_RD",
	"PPC_SUBFZE__RD_RD",
	"PPC_SUBFZE_RD_RD",
	"PPC_SUBFMEO__RD_RD",
	"PPC_SUBFMEO_RD_RD",
	"PPC_SUBFME__RD_RD",
	"PPC_SUBFME_RD_RD",
	"PPC_SUBFEO__RD_RD_RD",
	"PPC_SUBFEO_RD_RD_RD",
	"PPC_SUBFE__RD_RD_RD",
	"PPC_SUBFE_RD_RD_RD",
	"PPC_SUBFCO__RD_RD_RD",
	"PPC_SUBFCO_RD_RD_RD",
	"PPC_SUBFC__RD_RD_RD",
	"PPC_SUBFC_RD_RD_RD",
	"PPC_SUBFO__RD_RD_RD",
	"PPC_SUBFO_RD_RD_RD",
	"PPC_SUBF__RD_RD_RD",
	"PPC_SUBF_RD_RD_RD",
	"PPC_STWCX__RD_RD_RD",
	"PPC_STWBRX_RD_RD_RD",
	"PPC_STSWI_RD_RD_D",
	"PPC_STSWX_RD_RD_RD",
	"PPC_STHBRX_RD_RD_RD",
	"PPC_STWUX_RD_RD_RD",
	"PPC_STWX_RD_RD_RD",
	"PPC_STHUX_RD_RD_RD",
	"PPC_STHX_RD_RD_RD",
	"PPC_STBUX_RD_RD_RD",
	"PPC_STBX_RD_RD_RD",
	"PPC_SRW__RD_RD_RD",
	"PPC_SRW_RD_RD_RD",
	"PPC_SRAWI__RD_RD_D",
	"PPC_SRAWI_RD_RD_D",
	"PPC_SRAW__RD_RD_RD",
	"PPC_SRAW_RD_RD_RD",
	"PPC_SLW__RD_RD_RD",
	"PPC_SLW_RD_RD_RD",
	"PPC_ORC__RD_RD_RD",
	"PPC_ORC_RD_RD_RD",
	"PPC_OR__RD_RD_RD",
	"PPC_OR_RD_RD_RD",
	"PPC_MTSPR_D_RD",
	"PPC_MTMSR_RD",
	"PPC_MFSPR_RD_D",
	"PPC_MFMSR_RD",
	"PPC_NOR__RD_RD_RD",
	"PPC_NOR_RD_RD_RD",
	"PPC_NEGO__RD_RD",
	"PPC_NEGO_RD_RD",
	"PPC_NEG__RD_RD",
	"PPC_NEG_RD_RD",
	"PPC_NAND__RD_RD_RD",
	"PPC_NAND_RD_RD_RD",
	"PPC_MULLWO__RD_RD_RD",
	"PPC_MULLWO_RD_RD_RD",
	"PPC_MULLW__RD_RD_RD",
	"PPC_MULLW_RD_RD_RD",
	"PPC_MULHWU__RD_RD_RD",
	"PPC_MULHWU_RD_RD_RD",
	"PPC_MULHW__RD_RD_RD",
	"PPC_MULHW_RD_RD_RD",
	"PPC_MTSPR_S_RD",
	"PPC_MCRXR_CRFD",
	"PPC_MTCRF_D_RD",
	"PPC_MFSPR_RD_S",
	"PPC_LWARX_RD_RD_RD",
	"PPC_LWBRX_RD_RD_RD",
	"PPC_LWZUX_RD_RD_RD",
	"PPC_LWZX_RD_RD_RD",
	"PPC_LHZUX_RD_RD_RD",
	"PPC_LHZX_RD_RD_RD",
	"PPC_LHBRX_RD_RD_RD",
	"PPC_LHAUX_RD_RD_RD",
	"PPC_LHAX_RD_RD_RD",
	"PPC_LBZUX_RD_RD_RD",
	"PPC_LBZX_RD_RD_RD",
	"PPC_ISEL_RD__RD__R5B__D",
	"PPC_EXTSH__RD_RD",
	"PPC_EXTSH_RD_RD",
	"PPC_EXTSB__RD_RD",
	"PPC_EXTSB_RD_RD",
	"PPC_EQV__RD_RD_RD",
	"PPC_EQV_RD_RD_RD",
	"PPC_DIVWUO__RD_RD_RD",
	"PPC_DIVWUO_RD_RD_RD",
	"PPC_DIVWU__RD_RD_RD",
	"PPC_DIVWU_RD_RD_RD",
	"PPC_DIVWO__RD_RD_RD",
	"PPC_DIVWO_RD_RD_RD",
	"PPC_DIVW__RD_RD_RD",
	"PPC_DIVW_RD_RD_RD",
	"PPC_CNTLZW__RD__RD",
	"PPC_CNTLZW_RD__RD",
	"PPC_CMPL_D_D_RD_RD",
	"PPC_CMP_D_D_RD_RD",
	"PPC_ANDC__RD_RD_RD",
	"PPC_ANDC_RD_RD_RD",
	"PPC_AND__RD_RD_RD",
	"PPC_AND_RD_RD_RD",
	"PPC_ADDZEO__RD_RD",
	"PPC_ADDZEO_RD_RD",
	"PPC_ADDZE__RD_RD",
	"PPC_ADDZE_RD_RD",
	"PPC_ADDMEO__RD_RD",
	"PPC_ADDMEO_RD_RD",
	"PPC_ADDME__RD_RD",
	"PPC_ADDME_RD_RD",
	"PPC_ADDEO__RD_RD_RD",
	"PPC_ADDEO_RD_RD_RD",
	"PPC_ADDE__RD_RD_RD",
	"PPC_ADDE_RD_RD_RD",
	"PPC_ADDCO__RD_RD_RD",
	"PPC_ADDCO_RD_RD_RD",
	"PPC_ADDC__RD_RD_RD",
	"PPC_ADDC_RD_RD_RD",
	"PPC_ADDSS_RD_RD_RD",
	"PPC_E_XORIS_RD__RD__X",
	"PPC_E_SUBFICS_RD__RD__D",
	"PPC_E_STMW_RD__D_LP_RD_RP_",
	"PPC_E_STWU_RD__D_LP_RD_RP_",
	"PPC_E_STW_RD__D_LP_RD_RP_",
	"PPC_E_STHU_RD__D_LP_RD_RP_",
	"PPC_E_STH_RD__D_LP_RD_RP_",
	"PPC_E_STBU_RD__D_LP_RD_RP_",
	"PPC_E_STB_RD__D_LP_RD_RP_",
	"PPC_E_SRWIS_RD__RD__D",
	"PPC_E_SLWIS_RD__RD__D",
	"PPC_E_RLWINM_RD__RD__D__D__D",
	"PPC_E_RLWIMI_RD__RD__D__D__D",
	"PPC_E_RLWIS_RD__RD__D",
	"PPC_E_RLWS_RD__RD__RD",
	"PPC_E_ORIS_RD__RD__X",
	"PPC_E_OR2IS_RD__X",
	"PPC_E_OR2I_RD__X",
	"PPC_E_MULL2I_RD__D",
	"PPC_E_MULLI_RD__RD__D",
	"PPC_E_MCRF_CRD__CRD",
	"PPC_E_LMW_RD__D_LP_RD_RP_",
	"PPC_E_LWZU_RD__D_LP_RD_RP_",
	"PPC_E_LWZ_RD__D_LP_RD_RP_",
	"PPC_E_LIS_RD__X",
	"PPC_E_LI_RD__X",
	"PPC_E_LHZU_RD__D_LP_RD_RP_",
	"PPC_E_LHZ_RD__D_LP_RD_RP_",
	"PPC_E_LHAU_RD__D_LP_RD_RP_",
	"PPC_E_LHA_RD__D_LP_RD_RP_",
	"PPC_E_LBZU_RD__D_LP_RD_RP_",
	"PPC_E_LBZ_RD__D_LP_RD_RP_",
	"PPC_E_CRXOR_CRBD__CRBD__CRBD",
	"PPC_E_CRORC_CRBD__CRBD__CRBD",
	"PPC_E_CROR_CRBD__CRBD__CRBD",
	"PPC_E_CRNOR_CRBD__CRBD__CRBD",
	"PPC_E_CRNAND_CRBD__CRBD__CRBD",
	"PPC_E_CREQV_CRBD__CRBD__CRBD",
	"PPC_E_CRANDC_CRBD__CRBD__CRBD",
	"PPC_E_CRAND_CRBD__CRBD__CRBD",
	"PPC_E_CMPLI_CRD__RD__D",
	"PPC_E_CMPL16I_RD__D",
	"PPC_E_CMPI_CRD__RD__D",
	"PPC_E_CMPHL16I_RD__D",
	"PPC_E_CMPHL_CRD__RD__RD",
	"PPC_E_CMPH16I_RD__D",
	"PPC_E_CMPH_CRD__RD__RD",
	"PPC_E_CMP16I_RD__D",
	"PPC_E_BCS_X__X_08X",
	"PPC_E_BS_08X",
	"PPC_E_ADDICS_RD__RD__D",
	"PPC_E_AND2IS__RD__D",
	"PPC_E_AND2I__RD__D",
	"PPC_E_ADDICS_RD__RD__D_0",
	"PPC_E_ADDIS_RD__RD__D",
	"PPC_E_ADD2IS_RD__D",
	"PPC_E_ADD2I__RD__D",
	"PPC_E_ADD16I_RD__RD__D",
	"PPC_SE_SUBIS_RD__D",
	"PPC_SE_SUBF_RD__RD",
	"PPC_SE_SUB_RD__RD",
	"PPC_SE_STW_RD__D_LP_RD_RP_",
	"PPC_SE_STH_RD__D_LP_RD_RP_",
	"PPC_SE_STB_RD__D_LP_RD_RP_",
	"PPC_SE_SRWI_RD__D",
	"PPC_SE_SRW_RD__RD",
	"PPC_SE_SRAWI_RD__D",
	"PPC_SE_SRAW_RD__RD",
	"PPC_SE_SLWI_RD__D",
	"PPC_SE_SLW_RD__RD",
	"PPC_SE_SC",
	"PPC_SE_RFI",
	"PPC_SE_RFDI",
	"PPC_SE_RFCI",
	"PPC_SE_OR_RD__RD",
	"PPC_SE_NOT_RD",
	"PPC_SE_NEG_RD",
	"PPC_SE_MULLW_RD__RD",
	"PPC_SE_MTLR_RD",
	"PPC_SE_MTCTR_RD",
	"PPC_SE_MTAR_RD__RD",
	"PPC_SE_MR_RD__RD",
	"PPC_SE_MFLR_RD",
	"PPC_SE_MFCTR_RD",
	"PPC_SE_MFAR_RD__RD",
	"PPC_SE_LI_RD__D",
	"PPC_SE_LWZ_RD__D_LP_RD_RP_",
	"PPC_SE_LHZ_RD__D_LP_RD_RP_",
	"PPC_SE_LBZ_RD__D_LP_RD_RP_",
	"PPC_SE_EXTZH_RD",
	"PPC_SE_EXTZB_RD",
	"PPC_SE_EXTSH_RD",
	"PPC_SE_EXTSB_RD",
	"PPC_SE_CMPLI_RD__D",
	"PPC_SE_CMPL_RD__RD",
	"PPC_SE_CMPI_RD__D",
	"PPC_SE_CMPHL_RD__RD",
	"PPC_SE_CMPH_RD__RD",
	"PPC_SE_CMP_RD__RD",
	"PPC_SE_BTSTI_RD__D",
	"PPC_SE_BSETI_RD__D",
	"PPC_SE_BMSKI_RD__D",
	"PPC_BLRS",
	"PPC_BGENI_RD__D",
	"PPC_SE_BCTRS",
	"PPC_BCLRI_RD__D",
	"PPC_SE_BC_X__X__08X",
	"PPC_SE_BS_08X",
	"PPC_SE_ANDC_RD__RD",
	"PPC_SE_ANDI_RD__D",
	"PPC_E_ANDS_RD__RD_",
	"PPC_SE_ADDI_RD__D",
	"PPC_SE_ADD_RD_RD",
	"PPC_MFAPIDI_RD__RD",
	"PPC_TLBSYNC_0",
	"PPC_TLBIE_RD",
	"PPC_TLBIA",
	"PPC_RFI",
	"PPC_MTSRIN_RD_RD",
	"PPC_MTSR_D_RD",
	"PPC_MFSRIN_RD_RD",
	"PPC_MFSR_RD_D",
	"PPC_MTSPR_D_RD_0",
	"PPC_MTMSR_RD_0",
	"PPC_MFSPR_RD_D_0",
	"PPC_MFMSR_RD_0",
	"PPC_MFTB_RD_D",
	"PPC_ISYNC",
	"PPC_EIEIO",
	"PPC_ECOWX_RD_RD_RD",
	"PPC_ECIWX_RD_RD_RD",
	"PPC_ICBI_RD_RD_0",
	"PPC_DCBZ_RD_RD_0",
	"PPC_DCBTST_RD_RD_0",
	"PPC_DCBT_RD_RD_0",
	"PPC_DCBST_RD_RD_0",
	"PPC_DCBI_RD__RD_0",
	"PPC_DCBF_RD__RD_0",
	"PPC_DCBA_RD_RD_0",
	"PPC_MTFSFI__CRFD_D",
	"PPC_MTFSFI_CRFD_D",
	"PPC_MTFSF__D_FRD",
	"PPC_MTFSF_D_FRD",
	"PPC_MTFSB1__CRBD",
	"PPC_MTFSB1_CRBD",
	"PPC_MTFSB0__CRBD",
	"PPC_MTFSB0_CRBD",
	"PPC_MFFS__FRD",
	"PPC_MFFS_FRD",
	"PPC_MCRFS_CRFD_CRFD",
	"PPC_FCTIWZ__FRD_FRD",
	"PPC_FCTIWZ_FRD_FRD",
	"PPC_FCTIW__FRD_FRD",
	"PPC_FCTIW_FRD_FRD",
	"PPC_FRSP__FRD_FRD",
	"PPC_FRSP_FRD_FRD",
	"PPC_FNABS__FRD_FRD",
	"PPC_FNABS_FRD_FRD",
	"PPC_FABS__FRD_FRD",
	"PPC_FABS_FRD_FRD",
	"PPC_FNEG__FRD_FRD",
	"PPC_FNEG_FRD_FRD",
	"PPC_FMR__FRD_FRD",
	"PPC_FMR_FRD_FRD",
	"PPC_FCMPU_CRFD_FRD_FRD",
	"PPC_FCMPO_CRFD_FRD_FRD",
	"PPC_FNMSUBS__FRD_FRD_FRD_FRD",
	"PPC_FNMSUBS_FRD_FRD_FRD_FRD",
	"PPC_FNMSUB__FRD_FRD_FRD_FRD",
	"PPC_FNMSUB_FRD_FRD_FRD_FRD",
	"PPC_FMSUBS__FRD_FRD_FRD_FRD",
	"PPC_FMSUBS_FRD_FRD_FRD_FRD",
	"PPC_FMSUB__FRD_FRD_FRD_FRD",
	"PPC_FMSUB_FRD_FRD_FRD_FRD",
	"PPC_FNMADDS__FRD_FRD_FRD_FRD",
	"PPC_FNMADDS_FRD_FRD_FRD_FRD",
	"PPC_FNMADD__FRD_FRD_FRD_FRD",
	"PPC_FNMADD_FRD_FRD_FRD_FRD",
	"PPC_FMADDS__FRD_FRD_FRD_FRD",
	"PPC_FMADDS_FRD_FRD_FRD_FRD",
	"PPC_FMADD__FRD_FRD_FRD_FRD",
	"PPC_FMADD_FRD_FRD_FRD_FRD",
	"PPC_FDIVS__FRD_FRD_FRD",
	"PPC_FDIVS_FRD_FRD_FRD",
	"PPC_FDIV__FRD_FRD_FRD",
	"PPC_FDIV_FRD_FRD_FRD",
	"PPC_FMULS__FRD_FRD_FRD",
	"PPC_FMULS_FRD_FRD_FRD",
	"PPC_FMUL__FRD_FRD_FRD",
	"PPC_FMUL_FRD_FRD_FRD",
	"PPC_FSUBS__FRD_FRD_FRD",
	"PPC_FSUBS_FRD_FRD_FRD",
	"PPC_FSUB__FRD_FRD_FRD",
	"PPC_FSUB_FRD_FRD_FRD",
	"PPC_FADDS__FRD_FRD_FRD",
	"PPC_FADDS_FRD_FRD_FRD",
	"PPC_FADD__FRD_FRD_FRD",
	"PPC_FADD_FRD_FRD_FRD",
	"PPC_STFSUX_FRD_RD_RD",
	"PPC_STFSU_FRD_D_LP_RD_RP_",
	"PPC_STFSX_FRD_RD_RD",
	"PPC_STFS_FRD_D_LP_RD_RP_",
	"PPC_STFDUX_FRD_RD_RD",
	"PPC_STFDU_FRD_D_LP_RD_RP_",
	"PPC_STFDX_FRD_RD_RD",
	"PPC_STFD_FRD_D_LP_RD_RP_",
	"PPC_LFSUX_FRD_RD_RD",
	"PPC_LFSU_FRD_D_LP_RD_RP_",
	"PPC_LFSX_FRD_RD_RD",
	"PPC_LFS_FRD_D_LP_RD_RP_",
	"PPC_LFDUX_FRD_RD_RD",
	"PPC_LFDU_FRD_D_LP_RD_RP_",
	"PPC_LFDX_FRD_RD_RD",
	"PPC_LFD_FRD_D_LP_RD_RP_",
	"PPC_TWI_D_RD_D",
	"PPC_TW_D_RD_RD_0",
	"PPC_SYNC",
	"PPC_STWCX__RD_RD_RD_0",
	"PPC_LWARX_RD_RD_RD_0",
	"PPC_MFSPR_RD_S_0",
	"PPC_MTSPR_S_RD_0",
	"PPC_MFCR_RD_0",
	"PPC_ISEL_RD__RD__R5B__D_0",
	"PPC_MCRXR_CRFD_0",
	"PPC_MTCRF_D_RD_0",
	"PPC_MCRF_CRFD_CRFD",
	"PPC_CRORC_CRBD_CRBD_CRBD",
	"PPC_CRANDC_CRBD_CRBD_CRBD",
	"PPC_CREQV_CRBD_CRBD_CRBD",
	"PPC_CRNOR_CRBD_CRBD_CRBD",
	"PPC_CRNAND_CRBD_CRBD_CRBD",
	"PPC_CRXOR_CRBD_CRBD_CRBD",
	"PPC_CROR_CRBD_CRBD_CRBD",
	"PPC_CRAND_CRBD_CRBD_CRBD",
	"PPC_SRAW__RD_RD_RD_0",
	"PPC_SRAW_RD_RD_RD_0",
	"PPC_SRAWI__RD_RD_D_0",
	"PPC_SRAWI_RD_RD_D_0",
	"PPC_SRW__RD_RD_RD_0",
	"PPC_SRW_RD_RD_RD_0",
	"PPC_SLW__RD_RD_RD_0",
	"PPC_SLW_RD_RD_RD_0",
	"PPC_RLWIMI__RD_RD_D_D_D",
	"PPC_RLWIMI_RD_RD_D_D_D",
	"PPC_RLWNM__RD_RD_RD_D_D",
	"PPC_RLWNM_RD_RD_RD_D_D",
	"PPC_RLWINM__RD_RD_D_D_D",
	"PPC_RLWINM_RD_RD_D_D_D",
	"PPC_CNTLZW__RD__RD_0",
	"PPC_CNTLZW_RD__RD_0",
	"PPC_EXTSH__RD_RD_0",
	"PPC_EXTSH_RD_RD_0",
	"PPC_EXTSB__RD_RD_0",
	"PPC_EXTSB_RD_RD_0",
	"PPC_EQV__RD_RD_RD_0",
	"PPC_EQV_RD_RD_RD_0",
	"PPC_NAND__RD_RD_RD_0",
	"PPC_NAND_RD_RD_RD_0",
	"PPC_NOR__RD_RD_RD_0",
	"PPC_NOR_RD_RD_RD_0",
	"PPC_XORIS_RD_RD_D",
	"PPC_XORI_RD_RD_D",
	"PPC_XOR__RD_RD_RD_0",
	"PPC_XOR_RD_RD_RD_0",
	"PPC_ANDC__RD_RD_RD_0",
	"PPC_ANDC_RD_RD_RD_0",
	"PPC_ANDIS__RD_RD_D",
	"PPC_ANDI__RD_RD_D",
	"PPC_AND__RD_RD_RD_0",
	"PPC_AND_RD_RD_RD_0",
	"PPC_ORC__RD_RD_RD_0",
	"PPC_ORC_RD_RD_RD_0",
	"PPC_ORIS_RD_RD_D",
	"PPC_ORI_RD_RD_D",
	"PPC_OR__RD_RD_RD_0",
	"PPC_OR_RD_RD_RD_0",
	"PPC_CMPL_D_D_RD_RD_0",
	"PPC_CMPLI_D_D_RD_D",
	"PPC_CMP_D_D_RD_RD_0",
	"PPC_CMPI_D_D_RD_D",
	"PPC_NEGO__RD_RD_0",
	"PPC_NEGO_RD_RD_0",
	"PPC_NEG__RD_RD_0",
	"PPC_NEG_RD_RD_0",
	"PPC_DIVWUO__RD_RD_RD_0",
	"PPC_DIVWUO_RD_RD_RD_0",
	"PPC_DIVWU__RD_RD_RD_0",
	"PPC_DIVWU_RD_RD_RD_0",
	"PPC_DIVWO__RD_RD_RD_0",
	"PPC_DIVWO_RD_RD_RD_0",
	"PPC_DIVW__RD_RD_RD_0",
	"PPC_DIVW_RD_RD_RD_0",
	"PPC_MULHWU__RD_RD_RD_0",
	"PPC_MULHWU_RD_RD_RD_0",
	"PPC_MULHW__RD_RD_RD_0",
	"PPC_MULHW_RD_RD_RD_0",
	"PPC_MULLI_RD_RD_D",
	"PPC_MULLWO__RD_RD_RD_0",
	"PPC_MULLWO_RD_RD_RD_0",
	"PPC_MULLW__RD_RD_RD_0",
	"PPC_MULLW_RD_RD_RD_0",
	"PPC_SUBFZEO__RD_RD_0",
	"PPC_SUBFZEO_RD_RD_0",
	"PPC_SUBFZE__RD_RD_0",
	"PPC_SUBFZE_RD_RD_0",
	"PPC_SUBFMEO__RD_RD_0",
	"PPC_SUBFMEO_RD_RD_0",
	"PPC_SUBFME__RD_RD_0",
	"PPC_SUBFME_RD_RD_0",
	"PPC_SUBFEO__RD_RD_RD_0",
	"PPC_SUBFEO_RD_RD_RD_0",
	"PPC_SUBFE__RD_RD_RD_0",
	"PPC_SUBFE_RD_RD_RD_0",
	"PPC_SUBFCO__RD_RD_RD_0",
	"PPC_SUBFCO_RD_RD_RD_0",
	"PPC_SUBFC__RD_RD_RD_0",
	"PPC_SUBFC_RD_RD_RD_0",
	"PPC_SUBFIC_RD_RD_D",
	"PPC_SUBFO__RD_RD_RD_0",
	"PPC_SUBFO_RD_RD_RD_0",
	"PPC_SUBF__RD_RD_RD_0",
	"PPC_SUBF_RD_RD_RD_0",
	"PPC_ADDZEO__RD_RD_0",
	"PPC_ADDZEO_RD_RD_0",
	"PPC_ADDZE__RD_RD_0",
	"PPC_ADDZE_RD_RD_0",
	"PPC_ADDMEO__RD_RD_0",
	"PPC_ADDMEO_RD_RD_0",
	"PPC_ADDME__RD_RD_0",
	"PPC_ADDME_RD_RD_0",
	"PPC_ADDEO__RD_RD_RD_0",
	"PPC_ADDEO_RD_RD_RD_0",
	"PPC_ADDE__RD_RD_RD_0",
	"PPC_ADDE_RD_RD_RD_0",
	"PPC_ADDCO__RD_RD_RD_0",
	"PPC_ADDCO_RD_RD_RD_0",
	"PPC_ADDC__RD_RD_RD_0",
	"PPC_ADDC_RD_RD_RD_0",
	"PPC_ADDIC__RD_RD_D",
	"PPC_ADDIC_RD_RD_D",
	"PPC_ADDIS_RD_RD_D",
	"PPC_ADDI_RD_RD_D",
	"PPC_ADDSS_RD_RD_RD_0",
	"PPC_STSWX_RD_RD_RD_0",
	"PPC_STSWI_RD_RD_D_0",
	"PPC_STMW_RD_D_LP_RD_RP_",
	"PPC_STWBRX_RD_RD_RD_0",
	"PPC_STHBRX_RD_RD_RD_0",
	"PPC_STWUX_RD_RD_RD_0",
	"PPC_STWU_RD_D_LP_RD_RP_",
	"PPC_STWX_RD_RD_RD_0",
	"PPC_STW_RD_D_LP_RD_RP_",
	"PPC_STHUX_RD_RD_RD_0",
	"PPC_STHU_RD_D_LP_RD_RP_",
	"PPC_STHX_RD_RD_RD_0",
	"PPC_STH_RD_D_LP_RD_RP_",
	"PPC_STBUX_RD_RD_RD_0",
	"PPC_STBU_RD_D_LP_RD_RP_",
	"PPC_STBX_RD_RD_RD_0",
	"PPC_STB_RD_D_LP_RD_RP_",
	"PPC_LSWX_RD_RD_RD",
	"PPC_LSWI_RD_RD_D",
	"PPC_LMW_RD_D_LP_RD_RP_",
	"PPC_LWBRX_RD_RD_RD_0",
	"PPC_LHBRX_RD_RD_RD_0",
	"PPC_LWZUX_RD_RD_RD_0",
	"PPC_LWZU_RD_D_LP_RD_RP_",
	"PPC_LWZX_RD_RD_RD_0",
	"PPC_LWZ_RD_D_LP_RD_RP_",
	"PPC_LHAUX_RD_RD_RD_0",
	"PPC_LHAU_RD_D_LP_RD_RP_",
	"PPC_LHAX_RD_RD_RD_0",
	"PPC_LHA_RD_D_LP_RD_RP_",
	"PPC_LHZUX_RD_RD_RD_0",
	"PPC_LHZU_RD_D_LP_RD_RP_",
	"PPC_LHZX_RD_RD_RD_0",
	"PPC_LHZ_RD_D_LP_RD_RP_",
	"PPC_LBZUX_RD_RD_RD_0",
	"PPC_LBZU_RD_D_LP_RD_RP_",
	"PPC_LBZX_RD_RD_RD_0",
	"PPC_LBZ_RD_D_LP_RD_RP_",
	"PPC_SC",
	"PPC_BCLRL_D_D",
	"PPC_BCLR_D_D",
	"PPC_BCCTRL_D_D",
	"PPC_BCCTR_D_D",
	"PPC_BCLA_D_D_D",
	"PPC_BCL_D_D_D",
	"PPC_BCA_D_D_D",
	"PPC_BC_D_D_D",
	"PPC_BLA_D",
	"PPC_BL_0X08X",
	"PPC_BA_D",
	"PPC_B_D"
};

/* execution code table */
typedef void (*ppc_code_function_t)(ppc_state_t *, ppc_inst_t *);
extern ppc_code_function_t ppc_code_table[];


char *ppc_get_string_ident(ppc_ident_t id)
{
	return ppc_string_ident[id];
}

static unsigned long ppc_size_ident[] = {
	16,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32
};

unsigned long ppc_get_inst_size_from_id(ppc_ident_t id) {
	return ppc_size_ident[id];
}

unsigned long ppc_get_inst_size(ppc_inst_t* inst) {
	return ppc_size_ident[inst->ident];
}

/**
 * @typedef ppc_platform_t
 * This opaque type allows to represent an hardware and software platform.
 * It includes information about:
 * @li the hardware memories,
 * @li the module data (including system calls and interruption support).
 */


/**
 * Build a new platform for the platform ppc.
 * @return	Created platform or null if there is no more memory (see errno).
 * @note To release the platform, use ppc_unlock_platform().
 */
ppc_platform_t *ppc_new_platform(void) {
	ppc_platform_t *pf;

	/* allocation */
	pf = (ppc_platform_t *)calloc(1, sizeof(ppc_platform_t));
	if(pf == NULL) {
		errno = ENOMEM;
		return NULL;
	}
	/* the new platform is not locked yet */
	pf->usage = 0;

	/* other init */
	/*pf->entry = pf->sp = pf->argv = pf->envp = pf->aux = pf->argc = 0;*/
	pf->sys_env = calloc(1, sizeof(ppc_env_t));
	if(pf->sys_env == NULL) {
		errno = ENOMEM;
		free(pf);
		return NULL;
	}

	/* memory initialization */
	pf->mems.named.M = ppc_mem_new();
	if(pf->mems.named.M == NULL) {
		free(pf->sys_env);
		free(pf);
		return NULL;
	}


	/* module initialization */
	PPC_MEM_INIT(pf);
	PPC_GRT_INIT(pf);
	PPC_ERROR_INIT(pf);
	PPC_GEN_INT_INIT(pf);
	PPC_LOADER_INIT(pf);
	PPC_SYSCALL_INIT(pf);
	PPC_SYSPARM_INIT(pf);
	PPC_CODE_INIT(pf);
	PPC_EXCEPTION_INIT(pf);
	PPC_FPI_INIT(pf);
	PPC_ENV_INIT(pf);
	PPC_VEA_INIT(pf);


	/* return platform */
	return pf;
}


/**
 * Get a memory in the platform.
 * @param platform	Platform to get memory from.
 * @param index		Index of the memory to get.
 * @return			Requested memory.
 */
ppc_memory_t *ppc_get_memory(ppc_platform_t *platform, int index) {
	if (platform == NULL)
		return NULL;

	return platform->mems.array[index];
}


/**
 * return the system info (argc, argv ...), meaningless
 * if used when no program loaded
 * @param	platform	Platform to get system info from.
 * @return		Requested system info.
 */
ppc_env_t *ppc_get_sys_env(ppc_platform_t *platform)
{
	if (platform == NULL)
		return NULL;

	return platform->sys_env;
}


/**
 * Ensure that the platform is not released before a matching
 * ppc_platform_unlock() is performed.
 * @param platform	Platform to lock.
 */
void ppc_lock_platform(ppc_platform_t *platform) {
	if (platform == NULL)
		return;

	platform->usage++;
}


/**
 * Unlock the platform. If it the last lock on the platform,
 * the platform is freed.
 * @param platform	Platform to unlock.
 */
void ppc_unlock_platform(ppc_platform_t *platform) {
	if (platform == NULL)
		return;

	/* unlock */
	if(--platform->usage != 0)
		return;

	/* destroy the modules */
	PPC_MEM_DESTROY(platform);
	PPC_GRT_DESTROY(platform);
	PPC_ERROR_DESTROY(platform);
	PPC_GEN_INT_DESTROY(platform);
	PPC_LOADER_DESTROY(platform);
	PPC_SYSCALL_DESTROY(platform);
	PPC_SYSPARM_DESTROY(platform);
	PPC_CODE_DESTROY(platform);
	PPC_EXCEPTION_DESTROY(platform);
	PPC_FPI_DESTROY(platform);
	PPC_ENV_DESTROY(platform);
	PPC_VEA_DESTROY(platform);


	/* free the memories */
	ppc_mem_delete(platform->mems.named.M);


	/* free system info */
	free(platform->sys_env);

	/* free the platform */
	free(platform);
	platform = NULL;
}


/**
 * Load the program from the given loader.
 * @param platform		Platform.
 * @param loader		Loader to get program from.
 */
void ppc_load(ppc_platform_t *platform, ppc_loader_t *loader) {
	assert(platform);

	/* load in platform's memory */
	ppc_loader_load(loader, platform);

	/* initialize system information */
	platform->entry = ppc_loader_start(loader);
	ppc_set_brk(platform, ppc_brk_init(loader));

	/* !!TODO!! add argc,argv... init */
	/* stack initialization */
	ppc_stack_fill_env(loader, platform, platform->sys_env);
}


/**
 * Load the given program in the platform and initialize stack
 * @param platform	Platform to load in.
 * @param path		Path of the file to load.
 * @return			0 for success, -1 for error (in errno).
 */
int ppc_load_platform(ppc_platform_t *platform, const char *path) {
	ppc_loader_t *loader;
	assert(platform);

	/* open the file */
	loader = ppc_loader_open(path);
	if(loader == NULL)
		return -1;

	/* load in platform's memory */
	ppc_load(platform, loader);

	/* close the file */
	ppc_loader_close(loader);

	/* return success */
	return 0;
}



/* state management function */


/**
 * Create a new initialized state depending on a given platform
 * @param	platform	the platform helping the simulation on the created state
 * @return			a new initialized state suitable for the given platform
 */
ppc_state_t *ppc_new_state(ppc_platform_t *platform)
{
	ppc_state_t *state;

	/* allocation */
	state = (ppc_state_t *)malloc(sizeof(ppc_state_t));
	if(state == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* zeroing of all registers and memory references */
	memset(state, 0, sizeof(ppc_state_t));

	/* creating platform */
	if(platform == NULL)
	{
		free(state);
		return NULL;
	}
	state->platform = platform;

	/* locking it */
	ppc_lock_platform(state->platform);

	/* memory initialization */
	state->M = state->platform->mems.named.M;

	/* proper state initialization (from the op init) */
	PPC_MSR = 0;
	PPC_MSR = ppc_set_field32(PPC_MSR, 1, 13, 13);
	PPC_MSR = ppc_set_field32(PPC_MSR, 0, 14, 14);
	PPC_MSR = ppc_set_field32(PPC_MSR, 0, 8, 8);
	PPC_MSR = ppc_set_field32(PPC_MSR, 0, 11, 11);
	PPC_MSR = ppc_set_field32(PPC_MSR, 0, 0, 0);
	PPC_TB = ((uint64_t)(0));
	PPC_FPR[0] = ((double)(0.000000));
	PPC_FPR[1] = ((double)(0.000000));
	PPC_FPR[2] = ((double)(0.000000));
	PPC_FPR[3] = ((double)(0.000000));
	PPC_FPR[4] = ((double)(0.000000));
	PPC_FPR[5] = ((double)(0.000000));
	PPC_FPR[6] = ((double)(0.000000));
	PPC_FPR[7] = ((double)(0.000000));
	PPC_FPR[8] = ((double)(0.000000));
	PPC_FPR[9] = ((double)(0.000000));
	PPC_FPR[10] = ((double)(0.000000));
	PPC_FPR[11] = ((double)(0.000000));
	PPC_FPR[12] = ((double)(0.000000));
	PPC_FPR[13] = ((double)(0.000000));
	PPC_FPR[14] = ((double)(0.000000));
	PPC_FPR[15] = ((double)(0.000000));
	PPC_FPR[16] = ((double)(0.000000));
	PPC_FPR[17] = ((double)(0.000000));
	PPC_FPR[18] = ((double)(0.000000));
	PPC_FPR[19] = ((double)(0.000000));
	PPC_FPR[20] = ((double)(0.000000));
	PPC_FPR[21] = ((double)(0.000000));
	PPC_FPR[22] = ((double)(0.000000));
	PPC_FPR[23] = ((double)(0.000000));
	PPC_FPR[24] = ((double)(0.000000));
	PPC_FPR[25] = ((double)(0.000000));
	PPC_FPR[26] = ((double)(0.000000));
	PPC_FPR[27] = ((double)(0.000000));
	PPC_FPR[28] = ((double)(0.000000));
	PPC_FPR[29] = ((double)(0.000000));
	PPC_FPR[30] = ((double)(0.000000));
	PPC_FPR[31] = ((double)(0.000000));
	PPC_CR[0] = ((uint8_t)(0));
	PPC_CR[1] = ((uint8_t)(0));
	PPC_CR[2] = ((uint8_t)(0));
	PPC_CR[3] = ((uint8_t)(0));
	PPC_CR[4] = ((uint8_t)(0));
	PPC_CR[5] = ((uint8_t)(0));
	PPC_CR[6] = ((uint8_t)(0));
	PPC_CR[7] = ((uint8_t)(0));
	PPC_L2PM = 0;
	PPC_XER = 0;
	PPC_FPSCR = 0;
	fpi_setround(FPI_TONEAREST);
	PPC_FP_CLEAR = (FPI_INVALID | FPI_DIVBYZERO);


	/* PC initialization */
	state->NIA = platform->entry;
#	ifdef PPC_INIT_PC
		PPC_INIT_PC
#	else
		state->NIA = platform->entry;
#	endif


	/* system registers initialization (argv, envp...) */
	ppc_registers_fill_env(platform->sys_env, state);

	return state;
}


/**
 * Delete a state
 * @param	state	the state to delete
 */
void ppc_delete_state(ppc_state_t *state)
{
	if (state == NULL)
		return;

	/* unlock the platform */
	ppc_unlock_platform(state->platform);

	/* free the state */
	free(state);
	state = NULL;
}


/**
 * Return a copy of a given state, both state will share the same memory
 * and each new state's register will have the same value as in the given state.
 * the copied state may not be suitable for further simulation as the stack pointers
 * and similar address registers will be identical in two different states
 * sharing the same memory
 *
 * @param	state	the state to copy
 * @return		a fresh allocated copy (to be freed by the caller)
 */
ppc_state_t *ppc_copy_state(ppc_state_t *state)
{
	int i;

	if (state == NULL)
		return NULL;

	/* allocate a new state */
	ppc_state_t *new_state = (ppc_state_t *)malloc(sizeof(ppc_state_t));
	if(new_state == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* copy the platform and lock it */
	/* !!WARNING!! is this needed? as we may not wish to simulate with this state */
	new_state->platform = state->platform;
	ppc_lock_platform(new_state->platform);

	/* copy all the registers */
	new_state->DMISS = state->DMISS;
	new_state->L2CR = state->L2CR;
	new_state->SDR1 = state->SDR1;
	new_state->NIA = state->NIA;
	new_state->TMP_FLOTS2 = state->TMP_FLOTS2;
	new_state->CTR = state->CTR;
	new_state->SIA = state->SIA;
	new_state->IMISS = state->IMISS;
	for (i = 0; i < 16; i++)
		new_state->SR[i] = state->SR[i];
	for (i = 0; i < 8; i++)
		new_state->CR[i] = state->CR[i];
	for (i = 0; i < 16; i++)
		new_state->IBAT[i] = state->IBAT[i];
	new_state->ICMP = state->ICMP;
	new_state->EAR = state->EAR;
	new_state->VLE = state->VLE;
	new_state->DEC = state->DEC;
	for (i = 0; i < 2; i++)
		new_state->HASH[i] = state->HASH[i];
	new_state->DAR = state->DAR;
	for (i = 0; i < 4; i++)
		new_state->PMC[i] = state->PMC[i];
	new_state->TMP_XFLOT = state->TMP_XFLOT;
	new_state->TMP_FLOT1 = state->TMP_FLOT1;
	new_state->TMP_FLOT = state->TMP_FLOT;
	for (i = 0; i < 8; i++)
		new_state->SPRG[i] = state->SPRG[i];
	new_state->USIA = state->USIA;
	new_state->L2PM = state->L2PM;
	for (i = 0; i < 2; i++)
		new_state->HID[i] = state->HID[i];
	new_state->DCMP = state->DCMP;
	new_state->MSR = state->MSR;
	for (i = 0; i < 2; i++)
		new_state->UMMCR[i] = state->UMMCR[i];
	for (i = 0; i < 4; i++)
		new_state->UPMC[i] = state->UPMC[i];
	for (i = 0; i < 2; i++)
		new_state->MMCR[i] = state->MMCR[i];
	new_state->LR = state->LR;
	for (i = 0; i < 32; i++)
		new_state->GPR[i] = state->GPR[i];
	new_state->TB = state->TB;
	new_state->RPA = state->RPA;
	new_state->ICTC = state->ICTC;
	new_state->PVR = state->PVR;
	for (i = 0; i < 3; i++)
		new_state->THRM[i] = state->THRM[i];
	new_state->CIA = state->CIA;
	new_state->TMP_FLOTS = state->TMP_FLOTS;
	for (i = 0; i < 16; i++)
		new_state->DBAT[i] = state->DBAT[i];
	for (i = 0; i < 32; i++)
		new_state->FPR[i] = state->FPR[i];
	new_state->PIA = state->PIA;
	new_state->XER = state->XER;
	for (i = 0; i < 2; i++)
		new_state->SRR[i] = state->SRR[i];
	new_state->DABR = state->DABR;
	new_state->DSISR = state->DSISR;
	new_state->FPSCR = state->FPSCR;
	new_state->IABR = state->IABR;
	new_state->fp_clear = state->fp_clear;
	new_state->TMP_FLOTS1 = state->TMP_FLOTS1;
	new_state->SPEFSCR = state->SPEFSCR;

	/* copy the references to the memory */
	new_state->M = state->M;


	return new_state;
}


/**
 * Return a copy of a given state which will be intended for a further simulation,
 * both state will share the same memory
 * and each new state's register will have the same value as in the given state.
 *
 * TODO: we want to be able to simulate on this forked state
 * so we should really care about stack pointer and other address registers
 * used to write data in memory, these should have a different value
 * for each state created as we share the same memory
 *
 * @param	state	the state to fork
 * @return		a fresh allocated copy (to be freed by the caller)
 */
ppc_state_t *ppc_fork_state(ppc_state_t *state)
{
	int i;

	if (state == NULL)
		return NULL;

	/* allocate a new state */
	ppc_state_t *new_state = (ppc_state_t *)malloc(sizeof(ppc_state_t));
	if(new_state == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* copy the platform and lock it */
	new_state->platform = state->platform;
	ppc_lock_platform(new_state->platform);

	/* copy all the registers */
	new_state->DMISS = state->DMISS;
	new_state->L2CR = state->L2CR;
	new_state->SDR1 = state->SDR1;
	new_state->NIA = state->NIA;
	new_state->TMP_FLOTS2 = state->TMP_FLOTS2;
	new_state->CTR = state->CTR;
	new_state->SIA = state->SIA;
	new_state->IMISS = state->IMISS;
	for (i = 0; i < 16; i++)
		new_state->SR[i] = state->SR[i];
	for (i = 0; i < 8; i++)
		new_state->CR[i] = state->CR[i];
	for (i = 0; i < 16; i++)
		new_state->IBAT[i] = state->IBAT[i];
	new_state->ICMP = state->ICMP;
	new_state->EAR = state->EAR;
	new_state->VLE = state->VLE;
	new_state->DEC = state->DEC;
	for (i = 0; i < 2; i++)
		new_state->HASH[i] = state->HASH[i];
	new_state->DAR = state->DAR;
	for (i = 0; i < 4; i++)
		new_state->PMC[i] = state->PMC[i];
	new_state->TMP_XFLOT = state->TMP_XFLOT;
	new_state->TMP_FLOT1 = state->TMP_FLOT1;
	new_state->TMP_FLOT = state->TMP_FLOT;
	for (i = 0; i < 8; i++)
		new_state->SPRG[i] = state->SPRG[i];
	new_state->USIA = state->USIA;
	new_state->L2PM = state->L2PM;
	for (i = 0; i < 2; i++)
		new_state->HID[i] = state->HID[i];
	new_state->DCMP = state->DCMP;
	new_state->MSR = state->MSR;
	for (i = 0; i < 2; i++)
		new_state->UMMCR[i] = state->UMMCR[i];
	for (i = 0; i < 4; i++)
		new_state->UPMC[i] = state->UPMC[i];
	for (i = 0; i < 2; i++)
		new_state->MMCR[i] = state->MMCR[i];
	new_state->LR = state->LR;
	for (i = 0; i < 32; i++)
		new_state->GPR[i] = state->GPR[i];
	new_state->TB = state->TB;
	new_state->RPA = state->RPA;
	new_state->ICTC = state->ICTC;
	new_state->PVR = state->PVR;
	for (i = 0; i < 3; i++)
		new_state->THRM[i] = state->THRM[i];
	new_state->CIA = state->CIA;
	new_state->TMP_FLOTS = state->TMP_FLOTS;
	for (i = 0; i < 16; i++)
		new_state->DBAT[i] = state->DBAT[i];
	for (i = 0; i < 32; i++)
		new_state->FPR[i] = state->FPR[i];
	new_state->PIA = state->PIA;
	new_state->XER = state->XER;
	for (i = 0; i < 2; i++)
		new_state->SRR[i] = state->SRR[i];
	new_state->DABR = state->DABR;
	new_state->DSISR = state->DSISR;
	new_state->FPSCR = state->FPSCR;
	new_state->IABR = state->IABR;
	new_state->fp_clear = state->fp_clear;
	new_state->TMP_FLOTS1 = state->TMP_FLOTS1;
	new_state->SPEFSCR = state->SPEFSCR;

	/* copy the references to the memory */
	new_state->M = state->M;

}


/**
 * Dump all register values of a given state to the given output
 *
 * @param	state	the state whose registers we wish to dump
 * @param	out	the file to dump within, typically stderr or stdout
 */
void ppc_dump_state(ppc_state_t *state, FILE *out)
{
	int i;

	/* dump all the registers */
	fprintf(out, "DMISS = %08X\n", state->DMISS);
	fprintf(out, "L2CR = %08X\n", state->L2CR);
	fprintf(out, "SDR1 = %08X\n", state->SDR1);
	fprintf(out, "NIA = %08X\n", state->NIA);
	fprintf(out, "TMP_FLOTS2 = %f\n", state->TMP_FLOTS2);
	fprintf(out, "CTR = %08X\n", state->CTR);
	fprintf(out, "SIA = %08X\n", state->SIA);
	fprintf(out, "IMISS = %08X\n", state->IMISS);
	fprintf(out, "SR\n");
	for (i = 0; i < 16; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->SR[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "CR\n");
	for (i = 0; i < 8; i++) {
		fprintf(out, "\t[%d] = %02X", i, state->CR[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "IBAT\n");
	for (i = 0; i < 16; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->IBAT[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "ICMP = %08X\n", state->ICMP);
	fprintf(out, "EAR = %08X\n", state->EAR);
	fprintf(out, "VLE = %02X\n", state->VLE);
	fprintf(out, "DEC = %08X\n", state->DEC);
	fprintf(out, "HASH\n");
	for (i = 0; i < 2; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->HASH[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "DAR = %08X\n", state->DAR);
	fprintf(out, "PMC\n");
	for (i = 0; i < 4; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->PMC[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "TMP_XFLOT = %Lf\n", state->TMP_XFLOT);
	fprintf(out, "TMP_FLOT1 = %f\n", state->TMP_FLOT1);
	fprintf(out, "TMP_FLOT = %f\n", state->TMP_FLOT);
	fprintf(out, "SPRG\n");
	for (i = 0; i < 8; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->SPRG[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "USIA = %08X\n", state->USIA);
	fprintf(out, "L2PM = %08X\n", state->L2PM);
	fprintf(out, "HID\n");
	for (i = 0; i < 2; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->HID[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "DCMP = %08X\n", state->DCMP);
	fprintf(out, "MSR = %08X\n", state->MSR);
	fprintf(out, "UMMCR\n");
	for (i = 0; i < 2; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->UMMCR[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "UPMC\n");
	for (i = 0; i < 4; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->UPMC[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "MMCR\n");
	for (i = 0; i < 2; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->MMCR[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "LR = %08X\n", state->LR);
	fprintf(out, "GPR\n");
	for (i = 0; i < 32; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->GPR[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "TB = %016lX\n", state->TB);
	fprintf(out, "RPA = %08X\n", state->RPA);
	fprintf(out, "ICTC = %08X\n", state->ICTC);
	fprintf(out, "PVR = %08X\n", state->PVR);
	fprintf(out, "THRM\n");
	for (i = 0; i < 3; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->THRM[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "CIA = %08X\n", state->CIA);
	fprintf(out, "TMP_FLOTS = %f\n", state->TMP_FLOTS);
	fprintf(out, "DBAT\n");
	for (i = 0; i < 16; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->DBAT[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "FPR\n");
	for (i = 0; i < 32; i++) {
		fprintf(out, "\t[%d] = %f", i, state->FPR[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "PIA = %08X\n", state->PIA);
	fprintf(out, "XER = %08X\n", state->XER);
	fprintf(out, "SRR\n");
	for (i = 0; i < 2; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->SRR[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "DABR = %08X\n", state->DABR);
	fprintf(out, "DSISR = %08X\n", state->DSISR);
	fprintf(out, "FPSCR = %08X\n", state->FPSCR);
	fprintf(out, "IABR = %08X\n", state->IABR);
	fprintf(out, "fp_clear = %08X\n", state->fp_clear);
	fprintf(out, "TMP_FLOTS1 = %f\n", state->TMP_FLOTS1);
	fprintf(out, "SPEFSCR = %08X\n", state->SPEFSCR);

}


/**
 * return a reference (a pointer in fact) towards the platform of a given state
 *
 * @param	state	the state we want to access the platform
 * @return		the address of the platform of the given state
 */
ppc_platform_t *ppc_platform(ppc_state_t *state)
{
	if (state == NULL)
		return NULL;

	/* return the platform */
	return state->platform;
}


/* simulation functions */


/**
 * Create a new simulator structure with the given state
 * @param	state	the state on which we intend to simulate
 * @param	start_addr	the beginning of the execution (useful for executables compiled with no _start symbol),
 *				if null we leave the PC in its previous state given by the loader
 * @param	exit_addr	the explicitly given last instruction address to simulate, if null we will stop running in another way
 */
ppc_sim_t *ppc_new_sim(ppc_state_t *state, ppc_address_t start_addr, ppc_address_t exit_addr)
{
	ppc_sim_t *sim;

	if (state == NULL)
		return NULL;

	/* allocate a new simulator */
	sim = (ppc_sim_t *)malloc(sizeof(ppc_sim_t));
	if(sim == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* link the state to the new simulator */
	sim->state = state;

	/* create a new decoder */
	sim->decoder = ppc_new_decoder(ppc_platform(state));
	ppc_set_cond_state(sim->decoder, state);	if (sim->decoder == NULL)
		return NULL;
	sim->addr_exit = exit_addr;
	if (start_addr)
		sim->state->NIA = start_addr;

	/* not ended at start */
	sim->ended = 0;
	return sim;
}


//======================================================================
#if !defined(PPC_TRACE_CACHE) && !defined(PPC_DTRACE_CACHE)

/**
 * Return the next instruction to be executed by the given simulator
 *
 * this instruction is pointed by the PC
 *
 * @param	sim	the simulator which we simulate within
 * @return		the next instruction to be executed, fully decoded
 */
ppc_inst_t *ppc_next_inst(ppc_sim_t *sim)
{
	/* retrieving the instruction (which is allocated by the decoder) */
	/* we let the caller check for error */
	return ppc_decode(sim->decoder, sim->state->NIA);
}


/**
 * Execute the next instruction in the given simulator.
 * It doesn't check if we reached the last instruction, so it should be done
 * separately using the function ppc_is_sim_ended
 * @param	sim	the simulator which we simulate within
 */
void ppc_step(ppc_sim_t *sim)
{
	ppc_inst_t*  inst;
	ppc_state_t* state = sim->state;

	/* retrieving next instruction */
    inst = ppc_decode(sim->decoder, state->NIA);

	/* execute it */

	ppc_code_table[inst->ident](state, inst);

#ifndef PPC_INF_DECODE_CACHE
#ifndef PPC_FIXED_DECODE_CACHE
#ifndef PPC_LRU_DECODE_CACHE
    /* finally free it */
	ppc_free_inst(inst);
#endif
#endif
#endif

	/* ended ? */
	if(sim->addr_exit == state->NIA)
		sim->ended = 1;
}


/**
 * Straightforward execution of the simulated programm.
 * It runs and count the number of executed instructions
 * until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * @return number of executed instructions
 * */
uint64_t ppc_run_and_count_inst(ppc_sim_t *sim)
{
	uint64_t i = 0;
    ppc_state_t*   state     = sim->state;
    ppc_decoder_t* decoder   = sim->decoder;
    ppc_address_t  addr_exit = sim->addr_exit;
	ppc_inst_t* inst;
	while(!sim->ended) {
		inst = ppc_decode(decoder, state->NIA);
		ppc_code_table[inst->ident](state, inst);
#ifndef PPC_INF_DECODE_CACHE
#ifndef PPC_FIXED_DECODE_CACHE
#ifndef PPC_LRU_DECODE_CACHE
    /* finally free it */
	ppc_free_inst(inst);
#endif
#endif
#endif
		i++;
		if(addr_exit == state->NIA)
			sim->ended = 1;
	}
	return i;
}

/**
 * Straightforward execution of the simulated programm.
 * It runs until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * */
void ppc_run_sim(ppc_sim_t *sim)
{
	ppc_state_t*   state     = sim->state;
    ppc_decoder_t* decoder   = sim->decoder;
    ppc_address_t  addr_exit = sim->addr_exit;
	ppc_inst_t* inst;
	while(!sim->ended) {
		inst = ppc_decode(decoder, state->NIA);
		ppc_code_table[inst->ident](state, inst);
#ifndef PPC_INF_DECODE_CACHE
#ifndef PPC_FIXED_DECODE_CACHE
#ifndef PPC_LRU_DECODE_CACHE
    /* finally free it */
		ppc_free_inst(inst);
#endif
#endif
#endif
		if(addr_exit == state->NIA)
			sim->ended = 1;
	}
}
#endif
//======================================================================
#ifdef PPC_TRACE_CACHE
/**
 * Return the next instruction to be executed by the given simulator
 *
 * this instruction is pointed by the PC
 *
 * @param	sim	the simulator which we simulate within
 * @return		the next instruction to be executed, fully decoded
 */
ppc_inst_t *ppc_next_inst(ppc_sim_t *sim)
{
	/* retrieving the instruction (which is allocated by the decoder) */
	/* we let the caller check for error */
	return ppc_decode(sim->decoder, sim->state->NIA) + ((sim->state->NIA >> 2) & (TRACE_DEPTH-1));
}


/**
 * Execute the next instruction in the given simulator.
 * It doesn't check if we reached the last instruction, so it should be done
 * separately using the function ppc_is_sim_ended
 * @param	sim	the simulator which we simulate within
 */
void ppc_step(ppc_sim_t *sim)
{
	ppc_inst_t*  inst;
	ppc_state_t* state = sim->state;

	/* retrieving next instruction */
    inst =  ppc_decode(sim->decoder, state->NIA) + ((sim->state->NIA >> 2) & (TRACE_DEPTH-1));

	/* execute it */

	ppc_code_table[inst->ident](state, inst);

	/* ended ? */
	if(sim->addr_exit == state->NIA)
		sim->ended = 1;
}


/**
 * Straightforward execution of the simulated programm.
 * It runs and count the number of executed instructions
 * until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * @return number of executed instructions
 * */
uint64_t ppc_run_and_count_inst(ppc_sim_t *sim)
{
	uint64_t i = 0;
    uint32_t num_bloc;
    ppc_state_t*   state     = sim->state;
    ppc_decoder_t* decoder   = sim->decoder;
    ppc_address_t  addr_exit = sim->addr_exit;
    ppc_inst_t*    inst, *trace;

	while(!sim->ended)
	{
        trace    = ppc_decode(decoder, state->NIA);
        num_bloc = (state->NIA >> 2) >> TRACE_DEPTH_PW;

        while((((state->NIA >> 2)>> TRACE_DEPTH_PW) == num_bloc) && (!sim->ended) && (addr_exit != state->NIA))
        {
			inst = trace + ((state->NIA >> 2) & (TRACE_DEPTH-1));
            			}
			i++;
		}

		/* ended ? */
		if(addr_exit == state->NIA)
			sim->ended = 1;
	}
	return i;
}

/**
 * Straightforward execution of the simulated programm.
 * It runs until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * */
void ppc_run_sim(ppc_sim_t *sim)
{
    uint32_t num_bloc;
    ppc_state_t*   state     = sim->state;
    ppc_decoder_t* decoder   = sim->decoder;
    ppc_address_t  addr_exit = sim->addr_exit;
    ppc_inst_t*    inst, *trace;

	while(addr_exit != state->NIA)
	{
        trace    = ppc_decode(decoder, state->NIA);
        num_bloc = (state->NIA >> 2) >> TRACE_DEPTH_PW;

        while((((state->NIA >> 2)>> TRACE_DEPTH_PW) == num_bloc) && (addr_exit != state->NIA))
        {
			inst = trace + ((state->NIA >> 2) & (TRACE_DEPTH-1));
            		    ppc_code_table[inst->ident](state, inst);
        }
	}
}
#endif
//======================================================================
#ifdef PPC_DTRACE_CACHE
/**
 * Return the next instruction to be executed by the given simulator
 *
 * this instruction is pointed by the PC
 *
 * @param	sim	the simulator which we simulate within
 * @return		the next instruction to be executed, fully decoded
 */
ppc_inst_t *ppc_next_inst(ppc_sim_t *sim)
{
	/* retrieving the instruction (which is allocated by the decoder) */
	/* we let the caller check for error */

	/* Static variable is an optimisation hack
	 * in order to cache the current trace */
	static ppc_inst_t*  inst = 0;
	ppc_state_t* state = sim->state;

	/* retrieving next instruction */
	if(inst != 0)
	{
		inst++;
		if(inst->ident == -1)
			inst =  ppc_decode(sim->decoder, state->NIA);
	}else
	{
		inst =  ppc_decode(sim->decoder, state->NIA);
	}
	return inst;
}


/**
 * Execute the next instruction in the given simulator.
 * It doesn't check if we reached the last instruction, so it should be done
 * separately using the function ppc_is_sim_ended
 * @param	sim	the simulator which we simulate within
 */
void ppc_step(ppc_sim_t *sim)
{
	/* Static variable is an optimisation hack
	 * in order to cache the current trace */
	static ppc_inst_t*  inst = 0;
	ppc_state_t* state = sim->state;

	/* retrieving next instruction */
	if(inst != 0)
	{
		inst++;
		if(inst->ident == -1)
			inst =  ppc_decode(sim->decoder, state->NIA);
	}else
	{
		inst =  ppc_decode(sim->decoder, state->NIA);
	}


	/* execute it */

	ppc_code_table[inst->ident](state, inst);

		if(sim->addr_exit == state->NIA)
			sim->ended = 1;
}


/**
 * Straightforward execution of the simulated programm.
 * It runs and count the number of executed instructions
 * until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * @return number of executed instructions
 * */
uint64_t ppc_run_and_count_inst(ppc_sim_t *sim)
{
	uint64_t i = 0;
    ppc_state_t*   state     = sim->state;
    ppc_decoder_t* decoder   = sim->decoder;
    ppc_address_t  addr_exit = sim->addr_exit;
    ppc_inst_t*    inst;

	while(!sim->ended)
	{
        inst = ppc_decode(decoder, state->NIA);

        while( (inst->ident != -1) && (!sim->ended) && (addr_exit != state->NIA))
        {
            		    ppc_code_table[inst->ident](state, inst);
			inst++;
			i++;
        }

        /* ended ? */
		if(addr_exit == state->NIA)
			sim->ended = 1;

	}
	return i;
}

/**
 * Straightforward execution of the simulated programm.
 * It runs until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * */
void ppc_run_sim(ppc_sim_t *sim)
{
    uint32_t num_bloc;
    ppc_state_t*   state     = sim->state;
    ppc_decoder_t* decoder   = sim->decoder;
    ppc_address_t  addr_exit = sim->addr_exit;
    ppc_inst_t*    inst;

	while(!sim->ended)
	{
        inst = ppc_decode(decoder, state->NIA);

        while( (inst->ident != -1) && (addr_exit != state->NIA))
        {
            		    ppc_code_table[inst->ident](state, inst);
			inst++;
        }

        /* ended ? */
		if(addr_exit == state->NIA)
			sim->ended = 1;
	}
}

#endif
//======================================================================
/**
 * @fn int ppc_is_sim_ended(ppc_sim_t *sim);
 * Indicate if the simulation is finished on the given simulator
 * @param	sim	the simulator which we simulate within
 * @return	whether or not the simulation is ended (0 => false, anything!=0 => true)
 */

/**
 * destruction of a simulator object, the associated state and decoder are also destroyed
 * @param	sim	the simulator to be deleted
 */
void ppc_delete_sim(ppc_sim_t *sim)
{
	if (sim == NULL)
		return;

	/* delete the decoder */
	ppc_delete_decoder(sim->decoder);

	/* delete the state */
	ppc_delete_state(sim->state);

	/* delete the sim */
	free(sim);
}


/**
 * Get the address of the next instruction to be executed,
 * indicated by PC
 * @param sim	Simulator to work with.
 * @return		Address of the current instruction.
 */
ppc_address_t  ppc_next_addr(ppc_sim_t *sim) {
	assert(sim);
	return sim->state->NIA;
}


/**
 * Set the address of the next instruction.
 * @param sim		Current simulator.
 * @param address	Next address.
 */
void ppc_set_next_address(ppc_sim_t *sim, ppc_address_t address) {
	assert(sim);
	sim->state->NIA = address;
}


/**
 * Set the exit address for simulation.
 * @param sim		Current simulator.
 * @param address	Exit address.
 */
void ppc_set_exit_address(ppc_sim_t *sim, ppc_address_t address) {
	sim->addr_exit = address;
}


/**
 * Null-name ended list, provides the list of available decoding modes.
 */
ppc_mode_t ppc_modes[] = {
	{ "PPC", ppc_decode_PPC },	{ "VLE", ppc_decode_VLE },
	{ 0, 0 }
};

/* Generated by gep (117/07/07 15:08:30) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <ppc/fetch.h>
#include <ppc/decode.h> /* api.h will be in it, for fetch functions, decode_table.h also */
#include <ppc/config.h> /* for memory endiannesses */
#include <ppc/gen_int.h>
#include "decode_table.h"

#define ppc_error(e) fprintf(stderr, "%s\n", (e))


/* external functions */
			struct Table_Decodage_32;
ppc_ident_t ppc_fetch_32(ppc_fetch_t *fetch, ppc_address_t address, uint32_t *code, struct Table_Decodage_32 *table);
					struct Table_Decodage_CISC;
ppc_ident_t ppc_fetch_CISC(ppc_fetch_t *fetch, ppc_address_t address, mask_t *code, struct Table_Decodage_CISC *table);
			


/* external tables */
	extern struct Table_Decodage_32 *ppc_table_0;
	extern struct Table_Decodage_CISC *ppc_table_1;
	

/* decode structure */
struct ppc_decoder_t
{
	/* the fetch unit used to retrieve instruction ID */
	ppc_fetch_t *fetch;
	/* help determine which decode type if several instr sets defined */
	ppc_state_t *state;
	ppc_platform_t *pf;};

/* Extern Modules */
/* Constants */
/* Variables & Fonctions */
/* decoding */
ppc_inst_t *ppc_decode(ppc_decoder_t *decoder, ppc_address_t address);


/* initialization and destruction of ppc_decode_t object */
static int number_of_decoder_objects = 0;

static void init_decoder(ppc_decoder_t *d, ppc_platform_t *pf)
{
	d->fetch = NULL;
	d->state = NULL;
	d->pf = pf;
	}

static void halt_decoder(ppc_decoder_t *d)
{
        ppc_delete_fetch(d->fetch);
     
}

ppc_decoder_t *ppc_new_decoder(ppc_platform_t *pf) {
	assert(pf);
    ppc_decoder_t *res = malloc(sizeof(ppc_decoder_t));
    if (res == NULL)
                ppc_error("not enough memory to create a ppc_decoder_t object"); /* I assume error handling will remain the same, we use ppc_error istead of iss_error ? */
    init_decoder(res, pf);
    number_of_decoder_objects++;
    return res;
}

void ppc_delete_decoder(ppc_decoder_t *decode)
{
    if (decode == NULL)
        /* we shouldn't try to free a void decoder_t object, should this output an error ? */
                ppc_error("cannot delete an NULL ppc_decoder_t object");
    number_of_decoder_objects--;
    /*assert(number_of_decode_objects >= 0);*/
    halt_decoder(decode);
    free(decode);
    
}

/** set the state which is used to determine which instruction set we decode for,
 *  selection conditions are expressions using some state registers,
 *  the registers of the given state will be used after a call to this function.
 *  The fetch object will be created here for multi set descriptions.
 *  Does nothing if only one instr set is defined.
*/
void ppc_set_cond_state(ppc_decoder_t *decoder, ppc_state_t *state) {
	assert(decoder);
	
		decoder->state = state;
	decoder->fetch = ppc_new_fetch(decoder->pf, state);
	
}



/* Fonctions Principales */
ppc_inst_t *ppc_decode_32(ppc_decoder_t *decoder, ppc_address_t address)
{
	ppc_inst_t *res = 0;
	ppc_ident_t id;
	code_t code;
	
	/* first, fetch the instruction at the given address */
	id = ppc_fetch(decoder->fetch, address, &code);
	
	/* then decode it */
	res = ppc_decode_table[id](&code);
	res->addr = address;
    
	return res;
}
/* Fonctions Principales */
ppc_inst_t *ppc_decode_CISC(ppc_decoder_t *decoder, ppc_address_t address)
{
	ppc_inst_t *res = 0;
	ppc_ident_t id;
	code_t code;
	/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[32 / 32 + (32 % 32? 1: 0)];
	mask_t mask = { i_buff, 0 };
	code.mask = &mask;
	
	/* first, fetch the instruction at the given address */
	id = ppc_fetch(decoder->fetch, address, &code);
	
	/* then decode it */
	res = ppc_decode_table[id](&code);
	res->addr = address;
    
	return res;
}

/* decoding functions for one specific instr set */

/* access to a specific fetch table */
/* decoding function for instr set 0, named PPC */
ppc_inst_t *ppc_decode_PPC(ppc_decoder_t *decoder, ppc_address_t address)
{
	ppc_inst_t *res = 0;
	ppc_ident_t id;
	code_t code;
	
	/* first, fetch the instruction at the given address, call specialized fetch */
	id = ppc_fetch_32(decoder->fetch, address, &code.u32, ppc_table_0);
		
	
	/* then decode it */
	res = ppc_decode_table[id](&code);
	res->addr = address;
    
	return res;
}
/* decoding function for instr set 1, named VLE */
ppc_inst_t *ppc_decode_VLE(ppc_decoder_t *decoder, ppc_address_t address)
{
	ppc_inst_t *res = 0;
	ppc_ident_t id;
	code_t code;
	/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[32 / 32 + (32 % 32? 1: 0)];
	mask_t mask = { i_buff, 0 };
	code.mask = &mask;
	
	/* first, fetch the instruction at the given address, call specialized fetch */
	id = ppc_fetch_CISC(decoder->fetch, address, code.mask, ppc_table_1);	
	
	/* then decode it */
	res = ppc_decode_table[id](&code);
	res->addr = address;
    
	return res;
}


ppc_inst_t *ppc_decode(ppc_decoder_t *decoder, ppc_address_t address)
{
	ppc_state_t *state = decoder->state;
		if ((((uint32_t)(PPC_VLE)) == 0)) {
		return ppc_decode_32(decoder, address);
			}
		if ((((uint32_t)(PPC_VLE)) == 1)) {
		return ppc_decode_CISC(decoder, address);	}
	
}


/* End of file ppc_decode.c */

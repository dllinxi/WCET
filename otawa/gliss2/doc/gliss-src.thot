====== Generated Sources ======

===== Oranization of sources =====

The sources generated by GLISS are organized in different directories:
  * ''src/'' -- sources of the simulation library,
  * ''include/''//proc// -- header files of the API of the simulation library,
  * ''sim/'' -- source of the simple simulator (option ''-S'' of ''gep''),
  * ''disasm/'' -- source files of the disassembler.

The ''src/'' contains sources of the simulation the library that are
made of module source files and the following generated files:
  * ''code_table.h'' -- a function for each instruction, simulating its behaviour;
  * ''decode_table.h'' -- a decoding function for each instruction (extracting arguments form the instruction word);
  * ''fetch_table.h'' -- the fetch table to scan the instruction word and get the instruction identifier
(if the processor supports multiple instruction sets, one table for each instruction set);

Once the project has been compiled, the following files becomes available:
  * ''src/lib''//proc//''.a'' -- the simulation library (static linkage);
  * ''src/''//proc//''-config'' -- compilation configuration program;
  * ''sim/''//proc//''-sim'' -- default simulator for the current architecture;
  * ''disasm/''//proc//''-disasm'' -- default diassembler for the current architecture.

===== Generated commands =====

This section explains the interface of the generated commands.

==== proc-config ====

**SYNTAX:** proc-config [--cflags] [--libs]

Display options to compile with the simulation library.
  * ''--cflags'' -- display C flags to get acces to the API header files,
  * ''--libs'' -- display C flags to link with the simulation library.


==== proc-sim ====

**SYNTAX:** proc-sim OPTIONS EXECUTABLE_PATH ARGUMENTS

This command launch the simulator on the program found at //EXECUTABLE_PATH//.
The following arguments are considered as argument passed to the program
//EXECUTABLE_PATH// and not scanned as proc-sim arguments.

As a default, the program is simulated until it ends (call of ''_exit()'' function).

//OPTIONS// include:
  * ''-exit=''//ADDRESS// -- execute until the given address (in hexadecimal);
  * ''-f''|''-fast'' -- activate the fast execution mode (no statistics are produced);
  * ''-h''|''-help'' -- display this help;
  * ''-more-stats'' -- display more statistics;
  * ''-p''|''--profile=''//PATH// -- create or append instruction execution frequency to the given //PATH// (generate profile for ''gep'' optimization);
  * ''-s'' -- display statistics (execution time, number of instructions, etc);
  * ''-start=''//ADDRESS// -- starts the simulation at the given address (in hexadecimal);
  * ''-t=''//TIME// -- stops the simulations after //TIME// seconds;
  * ''-v''|''-verbose'' -- display the simulated instructions and other simulation details. 


==== proc-disasm ====

**SYNTAX**: proc-disasm EXECUTABLE_PATH

Read the program in //EXECUTABLE_PATH// and disassemble it.


===== Makefile =====

GEP generates the sources and header files for the simulation library
and utilities but cannot generate the ''Makefile'' launching itself.
Therefore, we present here a template of ''Makefile'' to do the job.
You processor generator does not require such a ''Makefile'' but we
think it may useful in usual work with @(GLISS).

<code make>
# Makefile for the MY_PROC architecture using GLISS V2

# configuration
GLISS_PREFIX	=../gliss2
WITH_DISASM		= 1	# comment it to prevent disassembler building
WITH_SIM		= 1	# comment it to prevent simulator building

MEMORY=vfast_mem
#PROFILE=PPC.profile # Here goes the path of your profiling file if you have one
LOADER=old_elf
SYSCALL=syscall-linux

# project definitions
PROC		=MY_PROC
MAIN_NMP	=$(PROC).nmp
MAIN_NML	=$(patsubst $(MAIN_NMP),%.nmp,%.nml)
MAIN_IRG	=$(patsubst $(MAIN_NMP),%.nmp,%.irg)
NMP_LIST	=$(MAIN_NMP)


# goals definition
GOALS		=
SUBDIRS		=	src
CLEAN		=	$(MAIN_NML) $(MAIN_IRG)
DISTCLEAN	=	include src

ifdef WITH_DISASM
GOALS		+= $(PROC)-disasm
SUBDIRS		+= disasm
DISTCLEAN	+= disasm
endif

ifdef WITH_SIM
GOALS		+=	$(PROC)-sim
SUBDIRS		+=	sim
DISTCLEAN	+=	sim
endif

GFLAGS = \
	-m mem:$(MEMORY) \
	-m loader:$(LOADER) \
	-m syscall:$(SYSCALL) \
	-m sysparm:sysparm-reg32 \
	-m code:code \
	-m exception:extern/exception \
	-m fpi:extern/fpi \
	-m env:linux_env \
	-a disasm.c

# targets
all: lib $(GOALS)

$(MAIN_NML): $(NMP_LIST)
	$(GLISS_PREFIX)/gep/gliss-nmp2nml.pl $< $@

$(MAIN_IRG): $(MAIN_NML)
	$(GLISS_PREFIX)/irg/mkirg $< $@

src include: $(MAIN_IRG)
	$(GLISS_PREFIX)/gep/gep $(GFLAGS) $< -S

check: $(MAIN_IRG)
	$(GLISS_PREFIX)/gep/gep $(GFLAGS) $< -S -c

lib: src include/$(PROC)/config.h src/disasm.c
	(cd src; make -j)

$(PROC)-disasm:
	cd disasm; make -j3

$(PROC)-sim:
	cd sim; make -j3

include/$(PROC)/config.h: config.tpl
	test -d include/$(PROC) || mkdir include/$(PROC)
	cp config.tpl $@

src/disasm.c: ppc.irg
	$(GLISS_PREFIX)/gep/gliss-disasm $< -o $@ -c

distclean: clean
	-for d in $(SUBDIRS); do test -d $$d && (cd $$d; make distclean || exit 0); done
	-rm -rf $(DISTCLEAN)

clean: only-clean
	-for d in $(SUBDIRS); do test -d $$d && (cd $$d; make clean || exit 0); done

only-clean:
	-rm -rf $(CLEAN)
</code>

First, you have to define the name of the processor in ''PROC'' definition
and then to you the main NMP file //PROC//''.nmp''. Yet, this policy
may be changed by setting definitions of ''MAIN_NMP'', ''MAIN_NML'' and/or
''MAIN_IRG''. The full list of NMP files may be given in ''NMP_LIST''.
This is mainly used to track modification and recompile the simulator
each time an NMP file is modified.

Then, this ''Makefile'' supposes that @(GLISS) has been downloaded,
expanded and compiled in a directory at the same level of the directory
containing your simulator. If it is not the case, the ''GLISS_PREFIX''
definition may be changed.

The ''# configuration'' part is dedicated to paramaters that may be changed
by the user while the the ''# project definition'' parts contains only
definition that may be customized by the simulator writer.

Finally, the ''# target'' contains the ''Makefile'' target:
  * ''all'' -- build all (simulation library, simulator and disassembler);
  * ''check'' -- does not compile the executable but juste check the NMP file consistency (only @(GLISS) front-end is applied);
  * ''only-clean'' -- remove IRG and NML files;
  * ''clean'' -- remove temporaries files (mainly ''.o'' files);
  * ''dist-clean'' -- remove all generated files.

The current ''Makefile'' requires also a file called ''config.tpl''
that is copied as-is in ''include/''//proc//''/config.h''. This file
contains specified definitions for the current processor to support
some module portability. It may be left empty but it usually contains
several macros described in the following section.

===== config.tpl =====

''config.tpl'' contains C code defining some configurations for
portability of some modules.

Whatever the simulator you are generating, you will need the following macros:

''#define TARGET_ENDIANNESS''

Define the endianness of the simulated processor: one of ''big'' or ''little''.

''#define HOST_ENDIANNESS''

Define the endianness of the host processor: one of ''big'' or ''little''.

''#define PPC_GET_GPR(s, i)'' ...

Get the //i//th register of the generic register bank stored in the currant state //s//.



The macros below are required if you are using a system call simulating module.

''#define PPC_SYSCALL_CODE(i, s)'' ...

Define a macro to get the code of system call. //i// is the current instruction
causing the system call and ''s'' the current simulation state. The content
of ''...'' is completely architecture-dependent.

''#define PPC_SYSCALL_MEM(s) ( (s)->M )''

Define a macro to get the main memory during a system call.

''#define PPC_SYSPARM_REG32_RCNT'' //N//

Define the number of arguments passed in register during a system call.

''#define PPC_SYSPARM_REG32_REG(s, i)'' ...

Get the //i//th argument for a register argument. //s// is the current simulation state.

''#define PPC_SYSPARM_REG32_SP(s)'' ...

Get the value of the current stack pointer from the state //s//.

''#define PPC_SYSPARM_REG32_RETURN(s, v)'' ...

Return the value //v// from the performed system call in the current state //s//.

''#define PPC_SYSPARM_REG32_SUCCEED(s)'' ...

Informs that the current system has succeeded in the state //s//.

''#define PPC_SYSPARM_REG32_FAILED(s)'' ...

Informs that the current system has failed in the state //s//.

''#define GLISS_ORDER_BYTES_CISC ...''

This definition is invoked once four bytes of instruction has been read.
These bytes are stored in array ''uint8_t buff[4]'' and must be stored
re-ordered in ''uint32_t word''. This definition is only used
in CISC mode fetching, that is, when the instructions have different
sizes.

''#define GLISS_ORDER_BYTESNN ...''

This macro is invoked when a fixed-size instruction set is fetched.
It allows to re-order bytes to the instruction word according to
an unusual policy. //NN// must be replaced by the size in bits of the
instruction set (usually 16 or 32). The read bytes are stored in the array
''uint8_t buff[4]'' and lust be reordered to make the word ''uint32_t word''.

''#define GLISS_PROCESS_CODE_LABEL(a) ...''

If defined, this macro may apply a specific process on the address
of a code label. It useful, for example, on processor like ARM
where the less significant bit of the label address is used to encode
the processor mode.






/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <$(proc)/mem.h>
#include <$(proc)/fetch.h>
$(if is_CISC_present)#include <$(proc)/gen_int.h>$(end)

#include <$(proc)/macros.h>
#include "fetch_table.h"

#define $(proc)_error(e) fprintf(stderr, "%s\n", (e))


/**
 * Halt the fetch module.
 */
static void halt_fetch(void) {
}

/**
 * Initialize the fetch module.
 */
static void init_fetch(void) {
}



/**
 *  initialization and destruction of $(proc)_fetch_t object
 */
static int number_of_fetch_objects = 0;


/**
 * Initialize a fetch handler.
 * @param pf	Current platform.
 * $(if is_multi_set)@param state	State to fetch instruction from.$(end)
 */
$(proc)_fetch_t *$(proc)_new_fetch($(proc)_platform_t *pf$(if is_multi_set), $(proc)_state_t *state$(end))
{
	$(proc)_fetch_t *res = malloc(sizeof($(proc)_fetch_t));
	if (res == NULL)
		$(proc)_error("not enough memory to create a $(proc)_fetch_t object"); /* I assume error handling will remain the same, we use $(proc)_error istead of iss_error ? */
	res->mem = $(proc)_get_memory(pf, $(PROC)_MAIN_MEMORY);
	$(if is_multi_set)res->state = state;$(end)
	if (number_of_fetch_objects == 0)
		init_fetch();
	number_of_fetch_objects++;
	return res;
}


/**
 * Delete the given fetch handler.
 * @param fetch		Fetch handler to delete.
 */
void $(proc)_delete_fetch($(proc)_fetch_t *fetch)
{
	if (fetch == NULL)
		/* we shouldn't try to free a void fetch_t object, should this output an error ? */
		$(proc)_error("cannot delete an NULL $(proc)_fetch_t object");
	free(fetch);
	number_of_fetch_objects--;
	/*assert(number_of_fetch_objects >= 0);*/
	if (number_of_fetch_objects == 0)
		halt_fetch();
}

$(foreach instr_sets_sizes)
$(if is_RISC_size)			//$ RISC instruction set

/**
 * Assemble bits representing the opcode.
 * @param	instr	Instruction work.
 * @param	mask	Mask of bits to group.
 * @return			Opcode.
 */
static uint$(C_size)_t make_opcode$(C_size)(uint$(C_size)_t instr, uint$(C_size)_t mask) {
	int i;
	uint$(C_size)_t tmp_mask;
	uint$(C_size)_t res = 0;

	tmp_mask = mask;
	for (i = $(C_size) - 1; i >= 0; i--) {
		if (tmp_mask & $(msb_size_mask)) {
			res <<= 1;
			res |= ((instr >> i) & 0x01);
		}
		tmp_mask <<= 1;
	}
	return res;
}


/**
 * Fetch the instruction at the given address.
 * @param fetch		Fetch handler.
 * @param address	Address to fetch from.
 * @param code		Bytes to store instruction code in.
$(if is_multi_set) * @param table	Table to get decoding tree from.$(end)
 */
$(if is_multi_set)//$ 		RISC multi-set
$(proc)_ident_t $(proc)_fetch_$(C_size)($(proc)_fetch_t *fetch, $(proc)_address_t address, uint$(C_size)_t *code, Table_Decodage_$(C_size) *table) {
$(else)//$ 					RISC mono-set
$(proc)_ident_t $(proc)_fetch($(proc)_fetch_t *fetch, $(proc)_address_t address, uint$(C_size)_t *code) {
$(end)
	uint$(C_size)_t valeur;
	Table_Decodage$(if is_multi_set)_$(C_size)$(end) *ptr;
	Table_Decodage$(if is_multi_set)_$(C_size)$(end) *ptr2 = $(if !is_multi_set)$(proc)_$(end)table;
	*code = $(proc)_mem_read$(C_size)(fetch->mem, address);
#	ifdef $(PROC)_ORDER_BYTES$(C_size) 
		{ uint8_t *buff = (uint8_t *)code; $(PROC)_ORDER_BYTES$(C_size); }
#	endif
	do {
		valeur = make_opcode$(C_size)(*code, ptr2->mask);
		ptr  = ptr2;
		ptr2 = ptr->table[valeur].ptr;
	} while(ptr->table[valeur].type == TABLEFETCH);
	return ($(proc)_ident_t)ptr->table[valeur].ptr;
}

$(else)//$ 					CISC instruction set

/**
 * Fetch and decode an instruction (for CISC instruction set).
 * @param fetch		Fetch handler.
 * @param address	Address of instruction to fetch.
 * @param code		Bytes to store instruction word in.
$(if is_multi_set) * @param table	Fetch table to use.$(end)
 * @return			Index of the fetched instruction.
 */
$(if is_multi_set)
$(proc)_ident_t $(proc)_fetch_CISC($(proc)_fetch_t *fetch, $(proc)_address_t address, mask_t *code, Table_Decodage_CISC *table) {
$(else)
$(proc)_ident_t $(proc)_fetch($(proc)_fetch_t *fetch, $(proc)_address_t address, mask_t *code) {
$(end)
	uint32_t value;
	Table_Decodage_CISC *ptr;
	Table_Decodage_CISC *ptr2 = $(if !is_multi_set)$(proc)_$(end)table;

	do {
		
		/* if inst buffer has not enough bits to apply mask, read and add what's needed, read a 32 bit chunk (like in mask_t) at a time */
		while (get_mask_length(code) < get_mask_length(ptr2->mask)) {
			uint8_t buff[4];
			uint32_t word;
			$(proc)_mem_read(fetch->mem, address + (get_mask_length(code) >> 3), buff, 4);
#			ifdef $(PROC)_ORDER_BYTES_CISC
				$(PROC)_ORDER_BYTES_CISC;
#			elif HOST_ENDIANNESS == TARGET_ENDIANNESS
				word = (buff[0] << 24) | (buff[1] << 16) | (buff[2] << 8) | buff[3];
#			endif
			set_mask_chunk(code, get_mask_length(code) >> 5, word);
			set_mask_length(code, get_mask_length(code) + 32);
		}

		/* compute value on mask */
		value = value_on_mask(code, ptr2->mask);
                ptr  = ptr2;
		ptr2 = ptr->table[value].ptr;

	} while (ptr->table[value].type == TABLEFETCH);

	return ($(proc)_ident_t)ptr->table[value].ptr;
}
$(end)
$(end)


$(if is_multi_set)//$ 		for multiset, single entry must be generated
/**
 * Fetch the instruction at the given address.
 * @param fetch		Fetch handler.
 * @param address	Address to fetch from.
 * @param code		Bytes to store instruction code in.
 */
$(proc)_ident_t $(proc)_fetch($(proc)_fetch_t *fetch, $(proc)_address_t address, code_t *code) {
	$(proc)_state_t *state = fetch->state;
	assert(state);
	$(foreach instruction_sets)
	if ($(select_iset)) {
		$(if is_RISC_iset)return $(proc)_fetch_$(C_size_iset)(fetch, address, &code->u$(C_size_iset), $(proc)_table_$(idx));
		$(else)return $(proc)_fetch_CISC(fetch, address, code->mask, $(proc)_table_$(idx));$(end)
	}
	$(end)
}
$(end)

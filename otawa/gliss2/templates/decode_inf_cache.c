/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */
/* decode:decode32_inf_cache */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <$(proc)/fetch.h>
#include <$(proc)/decode.h> /* api.h will be in it, for fetch functions, decode_table.h also */
#include <$(proc)/config.h> /* for memory endiannesses */

#include "decode_table.h"

#define $(proc)_error(e) fprintf(stderr, "%s\n", (e))


/* Only works if tablelength == 2^N */
#define INDEX_FOR(tablelength, hash) (hash & (tablelength - 1u))

#ifndef CACHE_SIZE
#define CACHE_SIZE (4096*2) // Must be a power of two
#endif


typedef struct $(proc)_entry {
	$(proc)_address_t key;
	$(proc)_inst_t *value;
	struct $(proc)_entry *next;
} $(proc)_entry_t;

typedef struct $(proc)_hashtable_t {
	unsigned int tablelength;
	$(proc)_entry_t **table;
} $(proc)_hashtable_t;

/* decode structure */
struct $(proc)_decoder_t
{
	/* the fetch unit used to retrieve instruction ID */
	$(proc)_fetch_t*     fetch;
	$(proc)_hashtable_t* cache;
$(if is_multi_set)	/* help determine which decode type if several instr sets defined */
	$(proc)_state_t *state;
	$(proc)_platform_t *pf;$(end)
};


/** ! Size must be a power of two ! */
static $(proc)_hashtable_t* create_hashtable (unsigned int size);
static void hashtable_destroy($(proc)_hashtable_t* h );
static void hashtable_insert($(proc)_hashtable_t* h, $(proc)_address_t key, $(proc)_inst_t* value);
static $(proc)_inst_t* hashtable_search($(proc)_hashtable_t* h, $(proc)_address_t key);

/* Extern Modules */
/* Constants */
/* Variables & Fonctions */
/* decoding */
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address);

/* initialization and destruction of $(proc)_decode_t object */
static int number_of_decoder_objects = 0;

static void init_decoder($(proc)_decoder_t *d, $(proc)_platform_t *pf)
{
        $(if is_multi_set)d->fetch = NULL;
	d->state = NULL;
	d->pf = pf;
	$(else)d->fetch = $(proc)_new_fetch(pf);
	$(end)
        d->cache = create_hashtable(CACHE_SIZE);

}

static void halt_decoder($(proc)_decoder_t *d)
{
        $(proc)_delete_fetch(d->fetch);
        hashtable_destroy(d->cache);
}

$(proc)_decoder_t *$(proc)_new_decoder($(proc)_platform_t *pf)
{
        $(proc)_decoder_t *res = malloc(sizeof($(proc)_decoder_t));
    if (res == NULL)
                $(proc)_error("not enough memory to create a $(proc)_decoder_t object"); /* I assume error handling will remain the same, we use $(proc)_error istead of iss_error ? */
    /*assert(number_of_decode_objects >= 0);*/
    init_decoder(res, pf);
    number_of_decoder_objects++;
    return res;
}

void $(proc)_delete_decoder($(proc)_decoder_t *decode)
{
    if (decode == NULL)
        /* we shouldn't try to free a void decoder_t object, should this output an error ? */
                $(proc)_error("cannot delete an NULL $(proc)_decoder_t object");
    number_of_decoder_objects--;
    /*assert(number_of_decode_objects >= 0);*/
    halt_decoder(decode);
    free(decode);
}

/** set the state which is used to determine which instruction set we decode for,
 *  selection conditions are expressions using some state registers,
 *  the registers of the given state will be used after a call to this function.
 *  The fetch object will be created here for multi set descriptions.
 *  Does nothing if only one instr set is defined.
*/
void $(proc)_set_cond_state($(proc)_decoder_t *decoder, $(proc)_state_t *state)
{
	$(if is_multi_set)if (decoder == NULL)
                $(proc)_error("cannot set cond state for a NULL $(proc)_decoder_t object");
	if (state == NULL)
                $(proc)_error("cannot set cond state with a NULL $(proc)_state_t object");
	decoder->state = state;
	/* state is given, we can finally create fetch object here */
	decoder->fetch = $(proc)_new_fetch(decoder->pf, state);
	$(end)
}


/* Fonctions Principales */


$(if !is_multi_set)
/** @brief decode an instruction given address
 *  @warning The decode instruction is cache into an infinite hashtable.
 *  the memory could bloat at any moment. Be aware of that flow,
 *  and use this function at your own risk !
 *  @param address of the instruction addr to be decoded
 *  @return a heap allocated intruction which would be freed at the earliest
 *  when the object decoder is erased.
 * */
$(if is_RISC)
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	uint$(C_inst_size)_t code;

	/* Is the instruction inside the cache ? */
	res = hashtable_search(decoder->cache, address);
	if( !res ) {
		/* If not found : */
		/* first, fetch the instruction at the given address */
		id   = $(proc)_fetch(decoder->fetch, address, &code);
		/* then decode it */
$(if GLISS_NO_MALLOC)
		res = ($(proc)_inst_t*)malloc(sizeof($(proc)_inst_t));
		$(proc)_decode_table[id](code, res);
$(else)
		res = $(proc)_decode_table[id](code);
$(end)
		res->addr = address;

		/* and last cache the instruction */
		hashtable_insert(decoder->cache, address, res);
	}
	return res;
}
$(else)
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	mask_t code = {i_buff, 0};

	/* Is the instruction inside the cache ? */
	res = hashtable_search(decoder->cache, address);
	if( !res ) {
		/* If not found : */
		/* first, fetch the instruction at the given address */
		id   = $(proc)_fetch(decoder->fetch, address, &code);
		/* then decode it */
$(if GLISS_NO_MALLOC)
		res = ($(proc)_inst_t*)malloc(sizeof($(proc)_inst_t));
		$(proc)_decode_table[id](&code, res);
$(else)
		res = $(proc)_decode_table[id](&code);
$(end)
		res->addr = address;

		/* and last cache the instruction */
		hashtable_insert(decoder->cache, address, res);
	}
	return res;
}
$(end)$(end)

$(if is_multi_set)
$(foreach instr_sets_sizes)
/** @brief decode an instruction given address
 *  @warning The decode instruction is cache into an infinite hashtable.
 *  the memory could bloat at any moment. Be aware of that flow,
 *  and use this function at your own risk !
 *  @param address of the instruction addr to be decoded
 *  @return a heap allocated intruction which would be freed at the earliest
 *  when the object decoder is erased.
 * */
$(proc)_inst_t *$(proc)_decode_$(if is_RISC_size)$(C_size)$(else)CISC$(end)($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	code_t code;
	$(if !is_RISC_size)/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	code.mask = {i_buff, 0};$(end)

	/* Is the instruction inside the cache ? */
	res = hashtable_search(decoder->cache, address);
	if( !res ) {
		/* If not found : */
		/* first, fetch the instruction at the given address */
		id   = $(proc)_fetch(decoder->fetch, address, &code);
		/* then decode it */
$(if GLISS_NO_MALLOC)
		res = ($(proc)_inst_t*)malloc(sizeof($(proc)_inst_t));
		$(proc)_decode_table[id](&code, res);
$(else)
		res = $(proc)_decode_table[id](&code);
$(end)
		res->addr = address;

		/* and last cache the instruction */
		hashtable_insert(decoder->cache, address, res);
	}
	return res;
}
$(end)$(end)

$(if is_multi_set)/* decoding functions for one specific instr set */

/* access to a specific fetch table */
#include "fetch_table.h"
$(foreach instruction_sets)/* decoding function for instr set $(idx), named $(iset_name) */

$(proc)_inst_t *$(proc)_decode_$(iset_name)($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	code_t code;
	$(if !is_RISC_iset)/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	code.mask = {i_buff, 0};$(end)
	int i;

	/* Is the instruction inside the cache ? */
	res = hashtable_search(decoder->cache, address);
	if( !res ) {
		/* If not found : */
		/* first, fetch the instruction at the given address */
		$(if is_RISC_iset)id = $(proc)_fetch_$(C_size_iset)(decoder->fetch, address, &code.u$(C_size_iset), table_$(idx));
		$(else)id = $(proc)_fetch_CISC(decoder->fetch, address, &code.mask, table_$(idx));$(end)
		/* then decode it */
$(if GLISS_NO_MALLOC)
		res = ($(proc)_inst_t*)malloc(sizeof($(proc)_inst_t));
		$(proc)_decode_table[id](&code, res);
$(else)
		res = $(proc)_decode_table[id](&code);
$(end)
		res->addr = address;

		/* and last cache the instruction */
		hashtable_insert(decoder->cache, address, res);
	}
	return res;
}
$(end)


$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_state_t *state = decoder->state;
	$(foreach instruction_sets)
	if ($(select_iset)) {
		$(if is_RISC_iset)return $(proc)_decode_$(C_size_iset)(decoder, address);
		$(else)return $(proc)_decode_CISC(decoder, address)$(end)
	}
	$(end)
}

$(end)




static $(proc)_hashtable_t* create_hashtable( unsigned int size )
{
    $(proc)_hashtable_t* h;
    unsigned int i;
    /* Check requested hashtable isn't too large */
    assert (size < (1u << 30));
    assert( size  != 0 );
    /* Check requested size and depth is a power of two */
    if( (size &(size -1)) != 0 ) size = pow(2., ceil(log(size ) / log(2.)) );

    h = ($(proc)_hashtable_t*)malloc( sizeof($(proc)_hashtable_t) );
    if (NULL == h) return NULL; /*oom*/

    h->table = ($(proc)_entry_t **)malloc( sizeof($(proc)_entry_t*) * size );
    if (NULL == h->table)
    {
        free(h);
        return NULL;
    } /*oom*/

    for(i = 0; i < size; i++)
        h->table[i] = NULL;

    h->tablelength  = size;
    return h;
}


static void hashtable_insert($(proc)_hashtable_t* h, $(proc)_address_t key, $(proc)_inst_t* value)
{
    /* This method allows duplicate keys - but they shouldn't be used */
    unsigned int   index;
    $(proc)_entry_t* entry;
    entry = ($(proc)_entry_t*)malloc( sizeof($(proc)_entry_t) );

    index        = INDEX_FOR(h->tablelength, key);
    entry->key   = key;
    entry->value = value;
    entry->next  = h->table[index];
    h->table[index] = entry;
}


static $(proc)_inst_t* hashtable_search($(proc)_hashtable_t* h, $(proc)_address_t key)
{
    $(proc)_entry_t* entry = h->table[INDEX_FOR(h->tablelength, key)];

    while (NULL != entry)
    {
        /* Check hash value to short circuit heavier comparison */
        if (key == entry->key) return entry->value;
        entry = entry->next;
    }

    return NULL;
}

static void hashtable_destroy($(proc)_hashtable_t* h)
{
    unsigned int i;
    $(proc)_entry_t *e, *f;
    $(proc)_entry_t **table = h->table;

    for (i = 0; i < h->tablelength; i++)
    {
        e = table[i];
        while (NULL != e){
            f = e;
            e = e->next;

            free(f->value);
            free(f);
        }
    }

    free(h->table);
    free(h);
}
/* End of file $(proc)_decode.c */

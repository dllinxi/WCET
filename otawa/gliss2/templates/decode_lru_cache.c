/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <$(proc)/fetch.h>
#include <$(proc)/decode.h> /* api.h will be in it, for fetch functions, decode_table.h also */
#include <$(proc)/config.h> /* for memory endiannesses */

#include "decode_table.h"

#define $(proc)_error(e) fprintf(stderr, "%s\n", (e))


/* Optimized modulo : only works if tablelength == 2^N */
#define MODULO(x, length) (x & (length - 1u))

#ifndef CACHE_DEPTH
#define CACHE_DEPTH 8     // Must be greater or equal to 2
#endif
#ifndef CACHE_SIZE
#define CACHE_SIZE (4096) // Must be a power of 2
#endif

// Double linked list (linked as a ring)
typedef struct $(proc)_entry {
	$(proc)_address_t key;
$(if GLISS_NO_MALLOC)
	$(proc)_inst_t value;
$(else)
	$(proc)_inst_t *value;
$(end)
	struct $(proc)_entry *next;
} $(proc)_entry_t;

typedef struct $(proc)_hashtable {
	$(proc)_entry_t *entry_tab;
	$(proc)_entry_t *table[CACHE_SIZE];
} $(proc)_hashtable_t;

/* decode structure */
struct $(proc)_decoder_t
{
	/* the fetch unit used to retrieve instruction ID */
    $(proc)_fetch_t *fetch;
    $(proc)_hashtable_t* cache;
$(if is_multi_set)	/* help determine which decode type if several instr sets defined */
	$(proc)_state_t *state;
	$(proc)_platform_t *pf;$(end)
};


/** ! Size must be a power of two ! */
static $(proc)_hashtable_t* create_hashtable (unsigned int size, unsigned int depth);

static void hashtable_destroy($(proc)_hashtable_t* h );
static void hashtable_insert($(proc)_hashtable_t* h, $(proc)_address_t key, $(proc)_inst_t* value);
static $(proc)_inst_t* hashtable_search($(proc)_hashtable_t* h, $(proc)_address_t key);

/* Extern Modules */
/* Constants */
/* Variables & Fonctions */
/* decoding */
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address);


/* initialization and destruction of $(proc)_decode_t object */
static int number_of_decoder_objects = 0;

static void init_decoder($(proc)_decoder_t *d, $(proc)_platform_t *pf)
{
        $(if is_multi_set)d->fetch = NULL;
	d->state = NULL;
	d->pf = pf;
	$(else)d->fetch = $(proc)_new_fetch(pf);
	$(end)
        d->cache = create_hashtable(CACHE_SIZE, CACHE_DEPTH);
}

static void halt_decoder($(proc)_decoder_t *d)
{
        $(proc)_delete_fetch(d->fetch);
        hashtable_destroy(d->cache);
}

$(proc)_decoder_t *$(proc)_new_decoder($(proc)_platform_t *pf)
{
        $(proc)_decoder_t *res = malloc(sizeof($(proc)_decoder_t));
    if (res == NULL)
                $(proc)_error("not enough memory to create a $(proc)_decoder_t object"); /* I assume error handling will remain the same, we use $(proc)_error istead of iss_error ? */
    /*assert(number_of_decode_objects >= 0);*/
    init_decoder(res, pf);
    number_of_decoder_objects++;
    return res;
}

void $(proc)_delete_decoder($(proc)_decoder_t *decode)
{
    if (decode == NULL)
        /* we shouldn't try to free a void decoder_t object, should this output an error ? */
                $(proc)_error("cannot delete an NULL $(proc)_decoder_t object");
    number_of_decoder_objects--;
    /*assert(number_of_decode_objects >= 0);*/
    halt_decoder(decode);
    free(decode);
}

/** set the state which is used to determine which instruction set we decode for,
 *  selection conditions are expressions using some state registers,
 *  the registers of the given state will be used after a call to this function.
 *  The fetch object will be created here for multi set descriptions.
 *  Does nothing if only one instr set is defined.
*/
void $(proc)_set_cond_state($(proc)_decoder_t *decoder, $(proc)_state_t *state)
{
	$(if is_multi_set)if (decoder == NULL)
                $(proc)_error("cannot set cond state for a NULL $(proc)_decoder_t object");
	if (state == NULL)
                $(proc)_error("cannot set cond state with a NULL $(proc)_state_t object");
	decoder->state = state;
	/* state is given, we can finally create fetch object here */
	decoder->fetch = $(proc)_new_fetch(decoder->pf, state);
	$(end)
}


/* Fonctions Principales */


/**
 * check if the cache contains the decoded instr at the given address
 * 
 * @param decoder	decoder struct giving access to instr cache
 * @param address  	address whose instr is searched in cache
 * @param res	decoded instr, if found, is stored here
 * @return 1 if an instr is found, if so, instr is be stored in res,
 * 0 if no instr is found (res points to the next place where to store an instr)
 **/
int cache_lookup($(proc)_decoder_t *decoder, $(proc)_address_t address, $(proc)_inst_t **res)
{
	$(proc)_ident_t id;
	uint32_t code;

	/* Is the instruction inside the cache ? */
	unsigned int i;
	unsigned int  hash = MODULO(address, CACHE_SIZE);
	$(proc)_entry_t **table = decoder->cache->table;
	$(proc)_entry_t *current = table[hash];
	$(proc)_entry_t *init = current;
	$(proc)_entry_t *prev;

	// If it's the first element no need to handle LRU policy
	if (address == current->key) {
$(if GLISS_NO_MALLOC)
		*res = &(current->value);
$(else)
		*res = current->value;
$(end)
		return 1;
	}

	prev = current;
	current = current->next;

	// "FOR" has the advantage that gcc can unroll the loop if necessary
	// Anyway I've not seen any improvements by unrolling manualy this loop
	for (i = 0; i < (CACHE_DEPTH-2); i++) {
		if (address == current->key) {
			prev->next = current->next;
			current->next = init;
			table[hash] = current;
$(if GLISS_NO_MALLOC)
			*res = &(current->value);
$(else)
			*res = current->value;
$(end)
			return 1;
		}
		prev = current;
		current = current->next;
	}

	// If it's last element LRU can be simplify
	current->next = init;
	//prev->next = NULL; useless because we don't rely on that
	table[hash] = current;
	
	if (address == current->key)
	{
$(if GLISS_NO_MALLOC)
		*res = &(current->value);
$(else)
		*res = current->value;
$(end)
		return 1;
	}
	
	/* If not found: */
	current->key = address;
$(if GLISS_NO_MALLOC)
	*res = &(current->value);
$(else)
	*res = current->value;
$(end)
	return 0;
}



$(if !is_multi_set)
/** @brief decode an instruction given address
 *  @warning The decode instruction is cache into an infinite hashtable.
 *  the memory could bloat at any moment. Be aware of that flow,
 *  and use this function at your own risk !
 *  @param address of the instruction addr to be decoded
 *  @return a heap allocated intruction which would be freed at the earliest
 *  when the object decoder is erased.
 * */
$(if is_RISC)
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_inst_t *tmp = 0;
	$(proc)_ident_t id;
	uint$(C_inst_size)_t code;

	/* Is the instruction inside the cache ? */
	int inst_in_cache = cache_lookup(decoder, address, &res);
	if (inst_in_cache) {
		return res;
	}

	/* Not in the cache */
	/* first, fetch the instruction at the given address */
	id = $(proc)_fetch(decoder->fetch, address, &code);
	/* then decode it */
$(if GLISS_NO_MALLOC)
	//res = &(current->value); // done by cache_lookup
	tmp = res;
	$(proc)_decode_table[id](code, tmp);
$(else)
	tmp = $(proc)_decode_table[id](code);
$(end)
	tmp->addr = address;
		
	/* and last cache the instruction */
$(if !GLISS_NO_MALLOC)
	free(res);
	res = tmp;
$(end)
	return res;
}
$(else)
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	mask_t code = {i_buff, 0};

	/* Is the instruction inside the cache ? */
	int inst_in_cache = cache_lookup(decoder, address, &res);
	if (inst_in_cache) {
		return res;
	}

	/* Not in the cache */
	/* first, fetch the instruction at the given address */
	id = $(proc)_fetch(decoder->fetch, address, &code);
	/* then decode it */
$(if GLISS_NO_MALLOC)
	//res = &(current->value); // done by cache_lookup
	tmp = res;
	$(proc)_decode_table[id](&code, tmp);
$(else)
	tmp = $(proc)_decode_table[id](&code);
$(end)
	tmp->addr = address;
		
	/* and last cache the instruction */
$(if !GLISS_NO_MALLOC)
	free(res);
	res = tmp;
$(end)
	return res;
}
$(end)$(end)


$(if is_multi_set)
$(foreach instr_sets_sizes)
$(proc)_inst_t *$(proc)_decode_$(if is_RISC_size)$(C_size)$(else)CISC$(end)($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	code_t code;
	$(if !is_RISC_size)/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	code.mask = {i_buff, 0};$(end)

	/* Is the instruction inside the cache ? */
	int inst_in_cache = cache_lookup(decoder, address, &res);
	if (inst_in_cache) {
		return res;
	}

	/* Not in the cache */
	/* first, fetch the instruction at the given address */
	id = $(proc)_fetch(decoder->fetch, address, &code);
	/* then decode it */
$(if GLISS_NO_MALLOC)
	//res = &(current->value); // done by cache_lookup
	tmp = res;
	$(proc)_decode_table[id](&code, tmp);
$(else)
	tmp = $(proc)_decode_table[id](&code);
$(end)
	tmp->addr = address;
		
	/* and last cache the instruction */
$(if !GLISS_NO_MALLOC)
	free(res);
	res = tmp;
$(end)
	return res;
}
$(end)$(end)

$(if is_multi_set)/* decoding functions for one specific instr set */

/* access to a specific fetch table */
#include "fetch_table.h"
$(foreach instruction_sets)/* decoding function for instr set $(idx), named $(iset_name) */
$(proc)_inst_t *$(proc)_decode_$(iset_name)($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	code_t code;
	$(if !is_RISC_iset)/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	code.mask = {i_buff, 0};$(end)

	/* Is the instruction inside the cache ? */
	int inst_in_cache = cache_lookup(decoder, address, &res);
	if (inst_in_cache) {
		return res;
	}

	/* Not in the cache */
	/* first, fetch the instruction at the given address */
	/* call specialized fetch */
	$(if is_RISC_iset)id = $(proc)_fetch_$(C_size_iset)(decoder->fetch, address, &code.u$(C_size_iset), table_$(idx));
	$(else)id = $(proc)_fetch_CISC(decoder->fetch, address, &code.mask, table_$(idx));$(end)
	/* then decode it */
$(if GLISS_NO_MALLOC)
	//res = &(current->value); // done by cache_lookup
	tmp = res;
	$(proc)_decode_table[id](&code, tmp);
$(else)
	tmp = $(proc)_decode_table[id](&code);
$(end)
	tmp->addr = address;
		
	/* and last cache the instruction */
$(if !GLISS_NO_MALLOC)
	free(res);
	res = tmp;
$(end)
	return res;
}
$(end)


$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_state_t *state = decoder->state;
	$(foreach instruction_sets)
	if ($(select_iset)) {
		$(if is_RISC_iset)return $(proc)_decode_$(C_size_iset)(decoder, address);
		$(else)return $(proc)_decode_CISC(decoder, address)$(end)
	}
	$(end)
}

$(end)



/**
 * @param depth  must greater or equal to 2
 */
static $(proc)_hashtable_t* create_hashtable( unsigned int size, unsigned int depth )
{
    $(proc)_entry_t* init;
    $(proc)_entry_t* tmp0;
    $(proc)_entry_t* tmp1;
    $(proc)_hashtable_t* h;
    unsigned int i, j;
    /* Check requested hashtable isn't too large */
    assert (size < (1u << 30));
    assert( size  != 0 );
    assert( depth >= 2 );
    /* Chech requested size and depth is a power of two */
    if( (size &(size -1)) != 0 ) size  = pow(2., ceil(log(size ) / log(2.)) );

    h = ($(proc)_hashtable_t*)malloc( sizeof($(proc)_hashtable_t) );
    if (NULL == h) return NULL;

    h->entry_tab = ($(proc)_entry_t*)malloc(sizeof($(proc)_entry_t)*depth*size);

    for(i = 0; i < size; ++i)
    {
        init = h->entry_tab + i*depth;
        if( init == NULL)
        {
            hashtable_destroy(h);
            return NULL;
        }
        tmp0 = init;
        init->key   = -1;
$(if !GLISS_NO_MALLOC)
        init->value = NULL;
$(end)
        for(j = 0; j < (depth-1); ++j)
        {
            tmp1 = h->entry_tab + i*depth +j+1;
            if( tmp1 == NULL)
            {
                hashtable_destroy(h);
                return NULL;
            }
            tmp1->key   = -1;
$(if !GLISS_NO_MALLOC)
			tmp1->value = NULL;
$(end)

            tmp0->next = tmp1;
            tmp0       = tmp1;
        }
        tmp1->next  = NULL;
        h->table[i] = init;
    }

    return h;
}

static void hashtable_destroy($(proc)_hashtable_t* h)
{
    unsigned int i, j;
    $(proc)_entry_t** table;
    $(proc)_entry_t*  init;
    $(proc)_entry_t*  it;
    $(proc)_entry_t*  tmp;

    if( h != NULL )
    {
		table = h->table;
        if( table != NULL )
        {
            for (i = 0; i < CACHE_SIZE; i++)
            {
                init = table[i];
                it   = init;

                for (j = 0; j < CACHE_DEPTH; j++)
                {
                    if(it != NULL)
                    {
						tmp = it;
$(if !GLISS_NO_MALLOC)
                        free(tmp->value);
$(end)
                        // Erase each entry
                        it = it->next;
                    }
                    else
                        break;
                }
            }
        }
        // Erase every chained list :
        free( h->entry_tab);
        // Erase $(proc)_hashtable_t
        free(h);
    }
}

/* End of file $(proc)_decode.c */

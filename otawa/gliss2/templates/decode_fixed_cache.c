/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <gliss/fetch.h>
#include <gliss/decode.h> /* api.h will be in it, for fetch functions, decode_table.h also */
#include <gliss/config.h> /* for memory endiannesses */

#include "decode_table.h"

#define gliss_error(e) fprintf(stderr, "%s\n", (e))


/* Optimized modulo : only works if tablelength == 2^N */
#define MODULO(x, length) (x & (length - 1u))

#ifndef CACHE_DEPTH
#define CACHE_DEPTH 8     // Must be a power of two
#endif
#ifndef CACHE_SIZE
#define CACHE_SIZE (4096*2) // Must be a power of two
#endif


typedef struct gliss_entry {
	gliss_address_t key;
$(if GLISS_NO_MALLOC)
	gliss_inst_t value;
$(else)
	gliss_inst_t *value;
$(end)
} gliss_entry_t;

typedef struct gliss_entry_ring {
	gliss_entry_t *entries;
	unsigned int idx;
} gliss_entry_ring_t;

typedef struct gliss_hashtable {
	unsigned int tablelength; // Table size
	unsigned int tabledepth;  // Nb entries per table cell
	gliss_entry_ring_t **table;
} gliss_hashtable_t;

/* decode structure */
struct gliss_decoder_t
{
	/* the fetch unit used to retrieve instruction ID */
	gliss_fetch_t *fetch;
	gliss_hashtable_t* cache;
$(if is_multi_set)	/* help determine which decode type if several instr sets defined */
	$(proc)_state_t *state;
	$(proc)_platform_t *pf;$(end)
};


/** ! Size must be a power of two ! */
static gliss_hashtable_t* create_hashtable (unsigned int size, unsigned int depth);

static void hashtable_destroy(gliss_hashtable_t* h );
static void hashtable_insert(gliss_hashtable_t* h, gliss_address_t key, gliss_inst_t* value);
static gliss_inst_t* hashtable_search(gliss_hashtable_t* h, gliss_address_t key);

/* Extern Modules */
/* Constants */
/* Variables & Fonctions */
/* decoding */
gliss_inst_t *gliss_decode(gliss_decoder_t *decoder, gliss_address_t address);

/* initialization and destruction of gliss_decode_t object */
static int number_of_decoder_objects = 0;

static void init_decoder(gliss_decoder_t *d, gliss_platform_t *pf)
{
        $(if is_multi_set)d->fetch = NULL;
	d->state = NULL;
	d->pf = pf;
	$(else)d->fetch = $(proc)_new_fetch(pf);
	$(end)
        d->cache = create_hashtable(CACHE_SIZE, CACHE_DEPTH);
}

static void halt_decoder(gliss_decoder_t *d)
{
	gliss_delete_fetch(d->fetch);
	hashtable_destroy(d->cache);
}

gliss_decoder_t *gliss_new_decoder(gliss_platform_t *pf)
{
        gliss_decoder_t *res = malloc(sizeof(gliss_decoder_t));
    if (res == NULL)
                gliss_error("not enough memory to create a gliss_decoder_t object"); /* I assume error handling will remain the same, we use gliss_error istead of iss_error ? */
    /*assert(number_of_decode_objects >= 0);*/
    init_decoder(res, pf);
    number_of_decoder_objects++;
    return res;
}

void gliss_delete_decoder(gliss_decoder_t *decode)
{
    if (decode == NULL)
        /* we shouldn't try to free a void decoder_t object, should this output an error ? */
                gliss_error("cannot delete an NULL gliss_decoder_t object");
    number_of_decoder_objects--;
    /*assert(number_of_decode_objects >= 0);*/
    halt_decoder(decode);
    free(decode);
}

/** set the state which is used to determine which instruction set we decode for,
 *  selection conditions are expressions using some state registers,
 *  the registers of the given state will be used after a call to this function.
 *  The fetch object will be created here for multi set descriptions.
 *  Does nothing if only one instr set is defined.
*/
void $(proc)_set_cond_state($(proc)_decoder_t *decoder, $(proc)_state_t *state)
{
	$(if is_multi_set)if (decoder == NULL)
                $(proc)_error("cannot set cond state for a NULL $(proc)_decoder_t object");
	if (state == NULL)
                $(proc)_error("cannot set cond state with a NULL $(proc)_state_t object");
	decoder->state = state;
	/* state is given, we can finally create fetch object here */
	decoder->fetch = $(proc)_new_fetch(decoder->pf, state);
	$(end)
}


/* Fonctions Principales */


$(if !is_multi_set)
/** @brief decode an instruction given an address
 *  The instruction is cached into a fixed hashtable.
 *  The hashtable free an instruction when a new one is cached,
 *  so a second call to gliss_decode might free the last decoded instruction !
 *  @param address of the instruction addr to be decoded
 *  @return a heap allocated intruction which would be freed at the earliest
 *  when gliss_decode is called a second time.      
 * */
$(if is_RISC)
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	uint$(C_inst_size)_t code;

	/* Is the instruction inside the cache ? */
	unsigned int i;
	gliss_entry_ring_t *ring = decoder->cache->table[MODULO(address, CACHE_SIZE)];

	i = ring->idx;
	do {
		/* Check hash value to short circuit heavier comparison */
		if (address == ring->entries[i].key) 
$(if GLISS_NO_MALLOC)
			return &(ring->entries[i].value);
$(else)
			return ring->entries[i].value;
$(end)
		i = MODULO((i-1), CACHE_DEPTH);
	} while( i != ring->idx);

	/* If not found: */
	/* first, fetch the instruction at the given address */
	id   = gliss_fetch(decoder->fetch, address, &code);
	/* then decode it */
$(if GLISS_NO_MALLOC)
	res = &(ring->entries[i].value);
	gliss_decode_table[id](code, res);
$(else)
	res  = gliss_decode_table[id](code);
	if (ring->entries[ring->idx].value != NULL)
		free(ring->entries[ring->idx].value);
	ring->entries[ring->idx].value = res;
$(end)
	res->addr = address;
	
	ring->entries[ring->idx].key   = address;
	ring->idx = MODULO((ring->idx+1), CACHE_DEPTH);
	
	return res;
}
$(else)
$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	mask_t code = {i_buff, 0};

	/* Is the instruction inside the cache ? */
	unsigned int i;
	gliss_entry_ring_t *ring = decoder->cache->table[MODULO(address, CACHE_SIZE)];

	i = ring->idx;
	do {
		/* Check hash value to short circuit heavier comparison */
		if (address == ring->entries[i].key) 
$(if GLISS_NO_MALLOC)
			return &(ring->entries[i].value);
$(else)
			return ring->entries[i].value;
$(end)
		i = MODULO((i-1), CACHE_DEPTH);
	} while( i != ring->idx);

	/* If not found: */
	/* first, fetch the instruction at the given address */
	id   = gliss_fetch(decoder->fetch, address, &code);
	/* then decode it */
$(if GLISS_NO_MALLOC)
	res = &(ring->entries[i].value);
	gliss_decode_table[id](&code, res);
$(else)
	res  = gliss_decode_table[id](&code);
	if (ring->entries[ring->idx].value != NULL)
		free(ring->entries[ring->idx].value);
	ring->entries[ring->idx].value = res;
$(end)
	res->addr = address;
	
	ring->entries[ring->idx].key   = address;
	ring->idx = MODULO((ring->idx+1), CACHE_DEPTH);
	
	return res;
}
$(end)$(end)

$(if is_multi_set)
$(foreach instr_sets_sizes)
/** @brief decode an instruction given an address
 *  The instruction is cached into a fixed hashtable.
 *  The hashtable free an instruction when a new one is cached,
 *  so a second call to gliss_decode might free the last decoded instruction !
 *  @param address of the instruction addr to be decoded
 *  @return a heap allocated intruction which would be freed at the earliest
 *  when gliss_decode is called a second time.      
 * */
$(proc)_inst_t *$(proc)_decode_$(if is_RISC_size)$(C_size)$(else)CISC$(end)($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	code_t code;
	$(if !is_RISC_size)/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	code.mask = {i_buff, 0};$(end)

	/* Is the instruction inside the cache ? */
	unsigned int i;
	gliss_entry_ring_t *ring = decoder->cache->table[MODULO(address, CACHE_SIZE)];

	i = ring->idx;
	do {
		/* Check hash value to short circuit heavier comparison */
		if (address == ring->entries[i].key) 
$(if GLISS_NO_MALLOC)
			return &(ring->entries[i].value);
$(else)
			return ring->entries[i].value;
$(end)
		i = MODULO((i-1), CACHE_DEPTH);
	} while( i != ring->idx);

	/* If not found: */
	/* first, fetch the instruction at the given address */
	id   = gliss_fetch(decoder->fetch, address, &code);
	/* then decode it */
$(if GLISS_NO_MALLOC)
	res = &(ring->entries[i].value);
	gliss_decode_table[id](&code, res);
$(else)
	res  = gliss_decode_table[id](&code);
	if (ring->entries[ring->idx].value != NULL)
		free(ring->entries[ring->idx].value);
	ring->entries[ring->idx].value = res;
$(end)
	res->addr = address;
	
	ring->entries[ring->idx].key   = address;
	ring->idx = MODULO((ring->idx+1), CACHE_DEPTH);
	
	return res;
}
$(end)$(end)

$(if is_multi_set)/* decoding functions for one specific instr set */

/* access to a specific fetch table */
#include "fetch_table.h"
$(foreach instruction_sets)/* decoding function for instr set $(idx), named $(iset_name) */

$(proc)_inst_t *$(proc)_decode_$(iset_name)($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_inst_t *res = 0;
	$(proc)_ident_t id;
	code_t code;
	$(if !is_RISC_iset)/* init a buffer for the read instr, size should be max instr size for the given arch */
	uint32_t i_buff[$(max_instruction_size) / 32 + ($(max_instruction_size) % 32? 1: 0)];
	code.mask = {i_buff, 0};$(end)

	/* Is the instruction inside the cache ? */
	unsigned int i;
	gliss_entry_ring_t *ring = decoder->cache->table[MODULO(address, CACHE_SIZE)];

	i = ring->idx;
	do {
		/* Check hash value to short circuit heavier comparison */
		if (address == ring->entries[i].key) 
$(if GLISS_NO_MALLOC)
			return &(ring->entries[i].value);
$(else)
			return ring->entries[i].value;
$(end)
		i = MODULO((i-1), CACHE_DEPTH);
	} while( i != ring->idx);

	/* If not found: */
	/* first, fetch the instruction at the given address */
	$(if is_RISC_iset)id = $(proc)_fetch_$(C_size_iset)(decoder->fetch, address, &code.u$(C_size_iset), table_$(idx));
	$(else)id = $(proc)_fetch_CISC(decoder->fetch, address, &code.mask, table_$(idx));$(end)
	/* then decode it */
$(if GLISS_NO_MALLOC)
	res = &(ring->entries[i].value);
	gliss_decode_table[id](&code, res);
$(else)
	res  = gliss_decode_table[id](&code);
	if (ring->entries[ring->idx].value != NULL)
		free(ring->entries[ring->idx].value);
	ring->entries[ring->idx].value = res;
$(end)
	res->addr = address;
	
	ring->entries[ring->idx].key   = address;
	ring->idx = MODULO((ring->idx+1), CACHE_DEPTH);
	
	return res;
}
$(end)


$(proc)_inst_t *$(proc)_decode($(proc)_decoder_t *decoder, $(proc)_address_t address)
{
	$(proc)_state_t *state = decoder->state;
	$(foreach instruction_sets)
	if ($(select_iset)) {
		$(if is_RISC_iset)return $(proc)_decode_$(C_size_iset)(decoder, address);
		$(else)return $(proc)_decode_CISC(decoder, address)$(end)
	}
	$(end)
}

$(end)



static gliss_hashtable_t* create_hashtable( unsigned int size, unsigned int depth )
{
    gliss_hashtable_t* h;
    unsigned int i, j;
    /* Check requested hashtable isn't too large */
    assert (size < (1u << 30));

    assert( size  != 0 );
    assert( depth != 0 );
    /* Chech requested size and depth is a power of two */
    if( (size &(size -1)) != 0 ) size  = pow(2., ceil(log(size ) / log(2.)) );
    if( (depth&(depth-1)) != 0 ) depth = pow(2., ceil(log(depth) / log(2.)) );

    h = (gliss_hashtable_t*)malloc( sizeof(gliss_hashtable_t) );
    if (NULL == h) return NULL; /*oom*/

    h->table = (gliss_entry_ring_t **)malloc( sizeof(gliss_entry_ring_t*) * size );
    if (NULL == h->table)
    {
        free(h);
        return NULL;
    } /*oom*/

    for(i = 0; i < size; ++i)
    {
        h->table[i] = (gliss_entry_ring_t *)malloc(sizeof(gliss_entry_ring_t));
        if( h->table[i] == NULL)
        {
            hashtable_destroy(h);
            return NULL;
        }

        h->table[i]->idx = 0;
        h->table[i]->entries = (gliss_entry_t*)malloc(sizeof(gliss_entry_t)*depth);

        if( h->table[i]->entries == NULL)
        {
            hashtable_destroy(h);
            return NULL;
        }

        for(j = 0; j < depth; ++j)
        {
            h->table[i]->entries[j].key   = -1;
$(if !GLISS_NO_MALLOC)
            h->table[i]->entries[j].value = NULL;
$(end)
        }
    }

    h->tablelength  = size;
    h->tabledepth   = depth;

    return h;
}

static void hashtable_destroy($(proc)_hashtable_t* h)
{
    unsigned int i, j;
    gliss_entry_ring_t** table;

    if( h != NULL )
    {
        table = h->table;
        if( table != NULL )
        {
            for (i = 0; i < h->tablelength; i++)
            {
                if(table[i] != NULL)
                {
                    if(table[i]->entries != NULL){
                        j = table[i]->idx;
                        do{
                            // Erase each instruction
$(if !GLISS_NO_MALLOC)
                            free(table[i]->entries[j].value);
$(end)
                            j = MODULO((j-1), h->tabledepth);
                        }while( j != table[i]->idx);
                        // Erase each entry array of gliss_entry_t
                        free(table[i]->entries);
                    }
                    // Erase each struct gliss_entry_ring_t
                    free(table[i]);
                }
            }
            // Erase the hashtable array of gliss_entry_ring_t*
            free(table);
        }
        // Erase gliss_hashtable_t
        free(h);
    }
}
/* End of file gliss_decode.c */

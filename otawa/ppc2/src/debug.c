/* Generated by gep (117/07/07 15:08:27) copyright (c) 2011 IRIT - UPS */

#include <assert.h>
#include <ppc/debug.h>
#include <ppc/macros.h>
#include <ppc/grt.h>

#define GLISS_IDX		idx
#define GLISS_I			r.iv
#define GLISS_L			r.lv
#define GLISS_F			r.fv
#define GLISS_D			r.dv
#define GLISS_GET_I(a)	r.iv = a
#define GLISS_GET_L(a)	r.lv = a
#define GLISS_GET_F(a)	r.fv = a
#define GLISS_GET_D(a)	r.dv = a

static register_bank_t ppc_registers[] = {
	{
		4,
		"DMISS",
		"DMISS",
		1,
		RTYPE_INT,
		32
	},
	{
		5,
		"L2CR",
		"L2CR",
		1,
		RTYPE_INT,
		32
	},
	{
		6,
		"SDR1",
		"SDR1",
		1,
		RTYPE_INT,
		32
	},
	{
		8,
		"NIA",
		"NIA",
		1,
		RTYPE_ADDR,
		32
	},
	{
		9,
		"TMP_FLOTS2",
		"TMP_FLOTS2",
		1,
		RTYPE_FLOAT,
		32
	},
	{
		10,
		"CTR",
		"CTR",
		1,
		RTYPE_INT,
		32
	},
	{
		11,
		"SIA",
		"SIA",
		1,
		RTYPE_INT,
		32
	},
	{
		12,
		"IMISS",
		"IMISS",
		1,
		RTYPE_INT,
		32
	},
	{
		16,
		"SR",
		"SR%d",
		16,
		RTYPE_INT,
		32
	},
	{
		17,
		"CR",
		"CR%d",
		8,
		RTYPE_INT,
		4
	},
	{
		18,
		"IBAT",
		"IBAT%d",
		16,
		RTYPE_INT,
		32
	},
	{
		20,
		"ICMP",
		"ICMP",
		1,
		RTYPE_INT,
		32
	},
	{
		23,
		"EAR",
		"EAR",
		1,
		RTYPE_INT,
		32
	},
	{
		24,
		"VLE",
		"VLE",
		1,
		RTYPE_INT,
		1
	},
	{
		25,
		"DEC",
		"DEC",
		1,
		RTYPE_INT,
		32
	},
	{
		26,
		"HASH",
		"HASH%d",
		2,
		RTYPE_INT,
		32
	},
	{
		27,
		"DAR",
		"DAR",
		1,
		RTYPE_INT,
		32
	},
	{
		28,
		"PMC",
		"PMC%d",
		4,
		RTYPE_INT,
		32
	},
	{
		30,
		"TMP_XFLOT",
		"TMP_XFLOT",
		1,
		RTYPE_FLOAT,
		80
	},
	{
		31,
		"TMP_FLOT1",
		"TMP_FLOT1",
		1,
		RTYPE_FLOAT,
		64
	},
	{
		33,
		"TMP_FLOT",
		"TMP_FLOT",
		1,
		RTYPE_FLOAT,
		64
	},
	{
		34,
		"SPRG",
		"SPRG%d",
		8,
		RTYPE_INT,
		32
	},
	{
		35,
		"USIA",
		"USIA",
		1,
		RTYPE_INT,
		32
	},
	{
		37,
		"L2PM",
		"L2PM",
		1,
		RTYPE_INT,
		32
	},
	{
		38,
		"HID",
		"HID%d",
		2,
		RTYPE_INT,
		32
	},
	{
		40,
		"DCMP",
		"DCMP",
		1,
		RTYPE_INT,
		32
	},
	{
		44,
		"MSR",
		"MSR",
		1,
		RTYPE_INT,
		32
	},
	{
		45,
		"UMMCR",
		"UMMCR%d",
		2,
		RTYPE_INT,
		32
	},
	{
		46,
		"UPMC",
		"UPMC%d",
		4,
		RTYPE_INT,
		32
	},
	{
		48,
		"MMCR",
		"MMCR%d",
		2,
		RTYPE_INT,
		32
	},
	{
		53,
		"LR",
		"LR",
		1,
		RTYPE_INT,
		32
	},
	{
		54,
		"GPR",
		"GPR%d",
		32,
		RTYPE_INT,
		32
	},
	{
		55,
		"TB",
		"TB",
		1,
		RTYPE_INT,
		64
	},
	{
		56,
		"RPA",
		"RPA",
		1,
		RTYPE_INT,
		32
	},
	{
		59,
		"ICTC",
		"ICTC",
		1,
		RTYPE_INT,
		32
	},
	{
		60,
		"PVR",
		"PVR",
		1,
		RTYPE_INT,
		32
	},
	{
		61,
		"THRM",
		"THRM%d",
		3,
		RTYPE_INT,
		32
	},
	{
		63,
		"CIA",
		"CIA",
		1,
		RTYPE_INT,
		32
	},
	{
		64,
		"TMP_FLOTS",
		"TMP_FLOTS",
		1,
		RTYPE_FLOAT,
		32
	},
	{
		67,
		"DBAT",
		"DBAT%d",
		16,
		RTYPE_INT,
		32
	},
	{
		69,
		"FPR",
		"FPR%d",
		32,
		RTYPE_FLOAT,
		64
	},
	{
		70,
		"PIA",
		"PIA",
		1,
		RTYPE_INT,
		32
	},
	{
		71,
		"XER",
		"XER",
		1,
		RTYPE_INT,
		32
	},
	{
		72,
		"SRR",
		"SRR%d",
		2,
		RTYPE_INT,
		32
	},
	{
		73,
		"DABR",
		"DABR",
		1,
		RTYPE_INT,
		32
	},
	{
		74,
		"DSISR",
		"DSISR",
		1,
		RTYPE_INT,
		32
	},
	{
		75,
		"FPSCR",
		"FPSCR",
		1,
		RTYPE_INT,
		32
	},
	{
		76,
		"IABR",
		"IABR",
		1,
		RTYPE_INT,
		32
	},
	{
		79,
		"fp_clear",
		"fp_clear",
		1,
		RTYPE_INT,
		32
	},
	{
		82,
		"TMP_FLOTS1",
		"TMP_FLOTS1",
		1,
		RTYPE_FLOAT,
		32
	},
	{
		83,
		"SPEFSCR",
		"SPEFSCR",
		1,
		RTYPE_INT,
		32
	},
	{
		-1
	}
};


/**
 * Get the description of registers of the architecture.
 * @return		Array of registers (last one has a negative identifier).
 */
register_bank_t *ppc_get_registers(void) {
	return ppc_registers;
}

/**
 * Get the value of a register.
 * @param state		Current state.
 * @param id		Register identifier (from register_bank_t).
 * @param idx		Index in the bank (ignored for non-mutiple register bank).
 * @return			Value of the register.
 */
register_value_t ppc_get_register(ppc_state_t *state, int id, int idx) {
	register_value_t r;
	switch(id) {
	case 4: {
				GLISS_GET_I(PPC_DMISS);

		} break;
	case 5: {
				GLISS_GET_I(PPC_L2CR);

		} break;
	case 6: {
				GLISS_GET_I(PPC_SDR1);

		} break;
	case 8: {
				GLISS_GET_I(PPC_NIA);

		} break;
	case 9: {
				GLISS_GET_F(PPC_TMP_FLOTS2);

		} break;
	case 10: {
				GLISS_GET_I(PPC_CTR);

		} break;
	case 11: {
				GLISS_GET_I(PPC_SIA);

		} break;
	case 12: {
				GLISS_GET_I(PPC_IMISS);

		} break;
	case 16: {
				GLISS_GET_I(PPC_SR[GLISS_IDX]);

		} break;
	case 17: {
				GLISS_GET_I(PPC_CR[GLISS_IDX]);

		} break;
	case 18: {
				GLISS_GET_I(PPC_IBAT[GLISS_IDX]);

		} break;
	case 20: {
				GLISS_GET_I(PPC_ICMP);

		} break;
	case 23: {
				GLISS_GET_I(PPC_EAR);

		} break;
	case 24: {
				GLISS_GET_I(PPC_VLE);

		} break;
	case 25: {
				GLISS_GET_I(PPC_DEC);

		} break;
	case 26: {
				GLISS_GET_I(PPC_HASH[GLISS_IDX]);

		} break;
	case 27: {
				GLISS_GET_I(PPC_DAR);

		} break;
	case 28: {
				GLISS_GET_I(PPC_PMC[GLISS_IDX]);

		} break;
	case 30: {
				GLISS_GET_D(PPC_TMP_XFLOT);

		} break;
	case 31: {
				GLISS_GET_D(PPC_TMP_FLOT1);

		} break;
	case 33: {
				GLISS_GET_D(PPC_TMP_FLOT);

		} break;
	case 34: {
				GLISS_GET_I(PPC_SPRG[GLISS_IDX]);

		} break;
	case 35: {
				GLISS_GET_I(PPC_USIA);

		} break;
	case 37: {
				GLISS_GET_I(PPC_L2PM);

		} break;
	case 38: {
				GLISS_GET_I(PPC_HID[GLISS_IDX]);

		} break;
	case 40: {
				GLISS_GET_I(PPC_DCMP);

		} break;
	case 44: {
				GLISS_GET_I(PPC_MSR);

		} break;
	case 45: {
				GLISS_GET_I(PPC_UMMCR[GLISS_IDX]);

		} break;
	case 46: {
				GLISS_GET_I(PPC_UPMC[GLISS_IDX]);

		} break;
	case 48: {
				GLISS_GET_I(PPC_MMCR[GLISS_IDX]);

		} break;
	case 53: {
				GLISS_GET_I(PPC_LR);

		} break;
	case 54: {
				GLISS_GET_I(PPC_GPR[GLISS_IDX]);

		} break;
	case 55: {
				GLISS_GET_L(PPC_TB);

		} break;
	case 56: {
				GLISS_GET_I(PPC_RPA);

		} break;
	case 59: {
				GLISS_GET_I(PPC_ICTC);

		} break;
	case 60: {
				GLISS_GET_I(PPC_PVR);

		} break;
	case 61: {
				GLISS_GET_I(PPC_THRM[GLISS_IDX]);

		} break;
	case 63: {
				GLISS_GET_I(PPC_CIA);

		} break;
	case 64: {
				GLISS_GET_F(PPC_TMP_FLOTS);

		} break;
	case 67: {
				GLISS_GET_I(PPC_DBAT[GLISS_IDX]);

		} break;
	case 69: {
				GLISS_GET_D(PPC_FPR[GLISS_IDX]);

		} break;
	case 70: {
				GLISS_GET_I(PPC_PIA);

		} break;
	case 71: {
				GLISS_GET_I(PPC_XER);

		} break;
	case 72: {
				GLISS_GET_I(PPC_SRR[GLISS_IDX]);

		} break;
	case 73: {
				GLISS_GET_I(PPC_DABR);

		} break;
	case 74: {
				GLISS_GET_I(PPC_DSISR);

		} break;
	case 75: {
				GLISS_GET_I(PPC_FPSCR);

		} break;
	case 76: {
				GLISS_GET_I(PPC_IABR);

		} break;
	case 79: {
				GLISS_GET_I(PPC_FP_CLEAR);

		} break;
	case 82: {
				GLISS_GET_F(PPC_TMP_FLOTS1);

		} break;
	case 83: {
				GLISS_GET_I(PPC_SPEFSCR);

		} break;

	default:
		assert(0);
	}
	return r;
}


/**
 * Set the value of a register in the given state.
 * @param state		Current state.
 * @param id		Register identifier (from register_bank_t).
 * @param idx		Index in the bank (ignored for non-mutiple register bank).
 * @param value		Value to put in register.
 */
void ppc_set_register(ppc_state_t *state, int id, int idx, register_value_t r) {
	switch(id) {
	case 4: {
				PPC_DMISS = GLISS_I;

		} break;
	case 5: {
				PPC_L2CR = GLISS_I;

		} break;
	case 6: {
				PPC_SDR1 = GLISS_I;

		} break;
	case 8: {
				PPC_NIA = GLISS_I;

		} break;
	case 9: {
				PPC_TMP_FLOTS2 = GLISS_F;

		} break;
	case 10: {
				PPC_CTR = GLISS_I;

		} break;
	case 11: {
				PPC_SIA = GLISS_I;

		} break;
	case 12: {
				PPC_IMISS = GLISS_I;

		} break;
	case 16: {
				PPC_SR[GLISS_IDX] = GLISS_I;

		} break;
	case 17: {
				PPC_CR[GLISS_IDX] = GLISS_I;

		} break;
	case 18: {
				PPC_IBAT[GLISS_IDX] = GLISS_I;

		} break;
	case 20: {
				PPC_ICMP = GLISS_I;

		} break;
	case 23: {
				PPC_EAR = GLISS_I;

		} break;
	case 24: {
				PPC_VLE = GLISS_I;

		} break;
	case 25: {
				PPC_DEC = GLISS_I;

		} break;
	case 26: {
				PPC_HASH[GLISS_IDX] = GLISS_I;

		} break;
	case 27: {
				PPC_DAR = GLISS_I;

		} break;
	case 28: {
				PPC_PMC[GLISS_IDX] = GLISS_I;

		} break;
	case 30: {
				PPC_TMP_XFLOT = GLISS_D;

		} break;
	case 31: {
				PPC_TMP_FLOT1 = GLISS_D;

		} break;
	case 33: {
				PPC_TMP_FLOT = GLISS_D;

		} break;
	case 34: {
				PPC_SPRG[GLISS_IDX] = GLISS_I;

		} break;
	case 35: {
				PPC_USIA = GLISS_I;

		} break;
	case 37: {
				PPC_L2PM = GLISS_I;

		} break;
	case 38: {
				PPC_HID[GLISS_IDX] = GLISS_I;

		} break;
	case 40: {
				PPC_DCMP = GLISS_I;

		} break;
	case 44: {
				PPC_MSR = GLISS_I;

		} break;
	case 45: {
				PPC_UMMCR[GLISS_IDX] = GLISS_I;

		} break;
	case 46: {
				PPC_UPMC[GLISS_IDX] = GLISS_I;

		} break;
	case 48: {
				PPC_MMCR[GLISS_IDX] = GLISS_I;

		} break;
	case 53: {
				PPC_LR = GLISS_I;

		} break;
	case 54: {
				PPC_GPR[GLISS_IDX] = GLISS_I;

		} break;
	case 55: {
				PPC_TB = GLISS_L;

		} break;
	case 56: {
				PPC_RPA = GLISS_I;

		} break;
	case 59: {
				PPC_ICTC = GLISS_I;

		} break;
	case 60: {
				PPC_PVR = GLISS_I;

		} break;
	case 61: {
				PPC_THRM[GLISS_IDX] = GLISS_I;

		} break;
	case 63: {
				PPC_CIA = GLISS_I;

		} break;
	case 64: {
				PPC_TMP_FLOTS = GLISS_F;

		} break;
	case 67: {
				PPC_DBAT[GLISS_IDX] = GLISS_I;

		} break;
	case 69: {
				PPC_FPR[GLISS_IDX] = GLISS_D;

		} break;
	case 70: {
				PPC_PIA = GLISS_I;

		} break;
	case 71: {
				PPC_XER = GLISS_I;

		} break;
	case 72: {
				PPC_SRR[GLISS_IDX] = GLISS_I;

		} break;
	case 73: {
				PPC_DABR = GLISS_I;

		} break;
	case 74: {
				PPC_DSISR = GLISS_I;

		} break;
	case 75: {
				PPC_FPSCR = GLISS_I;

		} break;
	case 76: {
				PPC_IABR = GLISS_I;

		} break;
	case 79: {
				PPC_FP_CLEAR = GLISS_I;

		} break;
	case 82: {
				PPC_TMP_FLOTS1 = GLISS_F;

		} break;
	case 83: {
				PPC_SPEFSCR = GLISS_I;

		} break;

	default:
		assert(0);
	}
}


/* handle of exceptions */


/* list of exceptions */
static ppc_exception_t exceptions[] = {
	{ 0, 0, 0 }
};


/**
 * Get the list of exceptions.
 * @return	List of exceptions ended by an item whose name is null.
 */
ppc_exception_t *ppc_exceptions(void) {
	return exceptions;
}


/* Generated by gep ($(date)) copyright (c) 2008 IRIT - UPS */

#ifndef GLISS_$(PROC)_INCLUDE_$(PROC)_DECODE_TABLE_H
#define GLISS_$(PROC)_INCLUDE_$(PROC)_DECODE_TABLE_H

#if defined(__cplusplus)
extern  "C"
{
#endif

#include <assert.h>
#include <$(proc)/api.h>
#include <$(proc)/macros.h>
#include <$(proc)/gen_int.h>

$(foreach modules)
#include <$(proc)/$(name).h>
$(end)

/* TODO: add some error messages when malloc fails */
#define gliss_error(e) fprintf(stderr, "%s\n", (e))

/* hack : Enable cache if gep option is on 
(without having to  move decode.c to templates) */
$(if GLISS_INF_DECODE_CACHE)
#define $(PROC)_INF_DECODE_CACHE
$(end)
$(if GLISS_FIXED_DECODE_CACHE)
#define $(PROC)_FIXED_DECODE_CACHE
$(end)
$(if GLISS_LRU_DECODE_CACHE)
#define $(PROC)_LRU_DECODE_CACHE
$(end)
$(if GLISS_NO_MALLOC)
#define $(PROC)_NO_MALLOC
$(end)


/* decoder macros */
$(if !is_multi_set)$(if is_RISC)
#define __EXTRACT(mask, offset_mask, inst)	  ( (uint$(C_inst_size)_t)((inst) & (mask)) >> (offset_mask))
#define __EXTS(mask, offset_mask, inst, n)    (((int$(C_inst_size)_t)__EXTRACT(mask, offset_mask, inst) << ($(C_inst_size) - n)) >> ($(C_inst_size) - n))
$(else)
/* CISC, decoded parameters should be 64 bit max */
#define __EXTRACT(mask, inst)	extract_mask(inst, mask)
#define __EXTS(mask, inst, n)	(((int64_t)__EXTRACT(mask, inst) << (64 - n)) >> (64 - n))
$(end)$(end)
$(if is_multi_set)
$(foreach instr_sets_sizes)
$(if is_RISC_size)
#define __EXTRACT_$(C_size)(mask, offset_mask, inst)	  ( (uint$(C_size)_t)((inst) & (mask)) >> (offset_mask))
#define __EXTS_$(C_size)(mask, offset_mask, inst, n)    (((int$(C_size)_t)__EXTRACT_$(C_size)(mask, offset_mask, inst) << ($(C_size) - (n))) >> ($(C_size) - (n)))
$(else)
/* decoded parameters should be 64 bit max */
#define __EXTRACT_CISC(mask, inst)	extract_mask(inst, mask)
#define __EXTS_CISC(mask, inst, n)	(((int64_t)__EXTRACT_CISC(mask, inst) << (64 - (n))) >> (64 - (n)))
$(end)$(end)$(end)


static$(if !GLISS_NO_MALLOC) $(proc)_inst_t *$(else) void $(end)$(proc)_instr_UNKNOWN_decode($(code_read_param_decl)code_inst$(if GLISS_NO_MALLOC), $(proc)_inst_t *inst$(end))
{
$(if !GLISS_NO_MALLOC)
	$(proc)_inst_t *inst = malloc(sizeof($(proc)_inst_t));
$(end)
	inst->ident = $(PROC)_UNKNOWN;

	$(if !GLISS_NO_MALLOC)return inst;$(end)

}

$(foreach instructions)
static$(if !GLISS_NO_MALLOC) $(proc)_inst_t *$(else) void $(end)$(proc)_instr_$(IDENT)_decode($(code_read_param_decl)code_inst$(if GLISS_NO_MALLOC), $(proc)_inst_t *inst$(end)) {

$(if has_param)$(if is_complex_decode)	/* complex decoding */
$(if !is_RISC_inst)$(mask_decl_all)$(end)
$(else)$(if !is_RISC_inst)	/* parameter masks */
$(foreach params)	$(mask_decl)$(end)$(end)$(end)
	
$(if !GLISS_NO_MALLOC)
	$(proc)_inst_t *inst = ($(proc)_inst_t *)malloc(sizeof($(proc)_inst_t));
$(end)
	inst->ident = $(PROC)_$(IDENT);

	/* put other parameters */
$(if is_complex_decode)	/* complex decoding */
$(foreach params)	$(PROC)_$(IDENT)_$(PARAM) = $(decoder_complex);
$(end)$(else)
$(foreach params)	$(PROC)_$(IDENT)_$(PARAM) = $(decoder);
$(end)$(end)
$(predecode)
	$(if !GLISS_NO_MALLOC)return inst;
$(end)

}

$(else)$(if !GLISS_NO_MALLOC)$(proc)_inst_t *inst = malloc(sizeof($(proc)_inst_t));
	
$(end)	
	inst->ident = $(PROC)_$(IDENT);
$(predecode)
	$(if !GLISS_NO_MALLOC)return inst;$(end)

}

$(end)$(end)


typedef $(if !GLISS_NO_MALLOC)$(proc)_inst_t *$(else)void $(end)$(proc)_decode_function_t($(code_read_param_decl)code_inst$(if GLISS_NO_MALLOC), $(proc)_inst_t *inst$(end));

static $(proc)_decode_function_t *$(proc)_decode_table[] =
{
	$(proc)_instr_UNKNOWN_decode$(foreach instructions),
	$(proc)_instr_$(IDENT)_decode$(end)
};

/* free a dynamically allocated instruction, we try not to free an already freed or NULL pointer */
void $(proc)_free_inst($(proc)_inst_t *inst) {
	assert(inst);
	// NB : inst->instrinput is allocate with the same malloc which allocate an instr

	$(if !GLISS_NO_MALLOC)$(if !GLISS_INF_DECODE_CACHE)$(if !GLISS_FIXED_DECODE_CACHE)$(if !GLISS_LRU_DECODE_CACHE)
    /* finally free it */
	free(inst);
	$(end)$(end)$(end)$(end)
}

#if defined(__cplusplus)
}
#endif

#endif /* GLISS_$(PROC)_INCLUDE_$(PROC)_DECODE_TABLE_H */
